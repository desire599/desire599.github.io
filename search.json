[{"title":"C++梁哥笔记day11","url":"/2020/12/31/C++梁哥笔记day11/","content":"\n# 类与对象\n\n## 一、运算符重载\n\n运算符重载，就是对已有的运算符进行重新定义，赋予另一种功能，以适应不同的数据类型。  \n\n<!-- more -->\n\n运算符重载只是一种“语法上的方便”，也就是它只是另一种函数调用的方式。  \n在C++中，可以定义一个处理类的新运算符。这种定义很像一个普通的函数定义，只是函数的名字由关键字`operator`及其紧跟的运算符组成。差别仅此而已。它像任何其他很熟一样也是一个函数，当编译器遇到适合的模式时，就会调用这个函数。  \n语法：定义重载的运算符就像定义函数，只是改函数的名字是`operator@`，这里的@代表了被重载函数的运算符。函数参数中参数个数取决于两个因素。运算符是一元（一个参数）的还是二元（两个参数）；运算符被定义为全局函数（对于一元是一个参数，对于二元是两个参数）还是成员函数（对与一元没有参数，对于二元是一个参数，此时该类的对象用作左耳参数）  \n\n【两个极端】有些人很容易滥用运算符重载，它确实是一个有趣的工具，但是应该注意，它仅仅是一种语法上的方便而已，是另外一种函数调用的方式。从这个角度来看，只有在能使涉及类的代码更易写，尤其是读时（请记住，读代码的机会比我们写代码多多了）才有理由重载运算符。如果不是这样，就改用其他更易用、更易读的方式，对于运算符重载，另外一个常见的反应就是恐慌：突然之间，C运算符的含义变得不同寻常了，一切都变了，所有C代码的功能都要改变！并非如此，对于内置的数据类型的表达式的运算符是不可能改变的。（例如想重载int类型数据的+号）\n\n* 重载双左尖括号`<<`\n\n```C++\nclass Person{\n    friend ostream& operator<<(ostream &out,Person ob);\nprivate:\n    char *name;\n    int age;\npublic:\n    Person(){\n        cout<<\"无参构造\"<<endl;\n    }\n    Person(char *name,int age){\n        cout<<\"有参构造\"<<endl;\n        this->name = new char[strlen(name)+1];\n        strcpy(this->name,name);\n        this->age = age;\n    }\n    ~Person(){\n        cout<<\"析构函数\"<<endl;\n        if(this->name != NULL){\n            delete [] this->name;\n        }\n    }\n    Person(const Person &ob){\n        cout<<\"拷贝构造函数\"<<endl;\n        this->age = ob.age;\n        this->name = new char[strlen(name)+1];\n        strcpy(this->name,ob.name);\n    }\n    void showPerson(){\n        cout<<\"name:\"<<this->name<<\",age:\"<<this->age<<endl;\n    }\n};\nostream& operator<<(ostream &out,Person ob){\n    out<<\"name:\"<<ob.name<<\",age:\"<<ob.age<<endl;\n    return out;\n}\n\nvoid test01(){\n    Person ob1(\"lucy\",18);\n    ob1.showPerson();\n    //operator<<(cout,ob1);直接将其看做一个函数也是可以的，但是这样比较麻烦\n    Person ob2(\"bob\",20);\n    cout<<ob1<<ob2<<endl;\n}\n```\n运行结果：  \n![图片](./pic1.png)  \n\n注意点：  \n1. 这个函数重载函数为全局函数，要使用Person类中的私有的成员，需要将这个函数设置为Person类的友类。\n2. 要实现`out<<ob1<<ob2<<endl;`后面还要连接其他的，需要返回值设置为out。\n\n\n* 全局友元函数实现重载加法运算符`+`\n\n```C++\n#include <iostream>\n#include <cstring>\nusing namespace std;\nclass Person{\n    friend ostream& operator<<(ostream &out,Person ob);\n    friend Person operator+(Person &ob1,Person &ob2);\nprivate:\n    char *name;\n    int age;\npublic:\n    Person(){\n        cout<<\"无参构造\"<<endl;\n    }\n    Person(char *name,int age){\n        cout<<\"有参构造\"<<endl;\n        this->name = new char[strlen(name)+1];\n        strcpy(this->name,name);\n        this->age = age;\n    }\n    ~Person(){\n        cout<<\"析构函数\"<<endl;\n        if(this->name != NULL){\n            delete [] this->name;\n        }\n    }\n    Person(const Person &ob){\n        cout<<\"拷贝构造函数\"<<endl;\n        this->age = ob.age;\n        this->name = new char[strlen(name)+1];\n        strcpy(this->name,ob.name);\n    }\n    void showPerson(){\n        cout<<\"name:\"<<this->name<<\",age:\"<<this->age<<endl;\n    }\n};\nostream& operator<<(ostream &out,Person ob){\n    out<<\"name:\"<<ob.name<<\",age:\"<<ob.age<<endl;\n    return out;\n}\nPerson operator+(Person &ob1,Person &ob2){\n    //1、拼接name\n    char *tmp_name = new char[strlen(ob1.name) + strlen(ob2.name) + 1];\n    strcpy(tmp_name,ob1.name);\n    strcat(tmp_name,ob2.name);\n    //2、age相加\n    int tmp_age = ob1.age + ob2.age;\n    Person ob3 = Person(tmp_name,tmp_age);\n    return ob3;\n}\nvoid test01(){\n    Person ob1(\"lucy\",18);\n    ob1.showPerson();\n    Person ob2(\"bob\",20);\n    cout<<ob1<<ob2<<endl;\n}\nvoid test02(){\n    Person ob1(\"lucy\",18);\n    Person ob2(\"bob\",20);\n    Person ob3 = ob1+ob2;\n    cout<<ob3;\n    cout<<(ob1+ob2);\n    //cout<<operator+(ob1,ob2);//出现段错误 不知道原因\n    Person ob4 = operator +(ob1,ob2);\n    ob4.showPerson();\n    //cout<<ob4;//出现段错误  不知道原因\n\n}\n\nint main(int argc, char *argv[])\n{\n    test02();\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic2.png)  \n\n注意点：  \n1. 这个`operator +`函数重载函数为全局函数，要使用Person类中的私有的成员，需要将这个函数设置为Person类的友类。\n2. 思考：要实现多个（超过两个）对象相加如何实现？\n\n* 成员函数实现重载加法运算符`+`\n\n```C++\n#include <iostream>\n#include <cstring>\nusing namespace std;\nclass Person{\n    friend ostream& operator<<(ostream &out,Person ob);\nprivate:\n    char *name;\n    int age;\npublic:\n    Person operator+(Person &ob){\n        //1、拼接name\n        char *tmp_name = new char[strlen(this->name) + strlen(ob.name) + 1];\n        strcpy(tmp_name,this->name);\n        strcat(tmp_name,ob.name);\n        //2、age相加\n        int tmp_age = this->age + ob.age;\n        Person ob3 = Person(tmp_name,tmp_age);\n        return ob3;\n    }\n    Person(){\n        cout<<\"无参构造\"<<endl;\n    }\n    Person(char *name,int age){\n        cout<<\"有参构造\"<<endl;\n        this->name = new char[strlen(name)+1];\n        strcpy(this->name,name);\n        this->age = age;\n    }\n    ~Person(){\n        cout<<\"析构函数\"<<endl;\n        if(this->name != NULL){\n            delete [] this->name;\n        }\n    }\n    Person(const Person &ob){\n        cout<<\"拷贝构造函数\"<<endl;\n        this->age = ob.age;\n        this->name = new char[strlen(name)+1];\n        strcpy(this->name,ob.name);\n    }\n    void showPerson(){\n        cout<<\"name:\"<<this->name<<\",age:\"<<this->age<<endl;\n    }\n};\nostream& operator<<(ostream &out,Person ob){\n    out<<\"name:\"<<ob.name<<\",age:\"<<ob.age<<endl;\n    return out;\n}\n\nvoid test01(){\n    Person ob1(\"lucy\",18);\n    ob1.showPerson();\n    Person ob2(\"bob\",20);\n    cout<<ob1<<ob2<<endl;\n}\nvoid test02(){\n    Person ob1(\"lucy\",18);\n    Person ob2(\"bob\",20);\n    Person ob3 = ob1.operator +(ob2);\n    cout<<ob3;\n    Person ob4 = ob1 + ob2;\n    cout<<ob4;\n}\n\nint main(int argc, char *argv[])\n{\n    test02();\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic3.png)  \n\n注意点：\n1. 成员函数实现运算符重载其一个参数利用this指针代替了  \n2. 调用方式与全局函数实现运算符重载完全一致\n\n\n---------------","tags":["随记"],"categories":["C++"]},{"title":"C++梁哥笔记day10","url":"/2020/12/31/C++梁哥笔记day10/","content":"\n\n# 类与对象\n\n## 一、const修饰成员函数\n\n用const修饰的成员函数，const修饰this指针指向的内存区域，成员函数体内不可以修改本类中的任何普通成员变量，当成员变量类型符用mutable修饰时例外。\n\n<!-- more -->\n\n```C++\n//const 修饰的是成员函数\nvoid myFun() const{\n//函数体内部不能修改普通成员变量 mutable修饰时除外\n}\n```\n```C++\nclass Data{\nprivate:\n    int data;\n    mutable int num;\npublic:\n    Data(){\n        cout<<\"无参构造\"<<endl;\n    }\n    Data(int data){\n        this->data = data;\n        cout<<\"有参构造\"<<endl;\n    }\n    Data(Data const &ob){\n        cout<<\"拷贝构造\"<<endl;\n    }\n    ~Data(){\n        cout<<\"析构函数\"<<endl;\n    }\n    void myfun() const\n    {\n        //data = 200;//error: assignment of member 'Data::data' in read-only object\n        num = 1000;//声明前面加了mutable 可以修改（打破规则）\n    }\n};\n```\n运行结果：\n![图片](./pic1.png)  \n\n\n----------------\n\n\n## 二、const修饰对象（常对象）\n常对象只能调用const的成员函数，常对象可访问const或非const数据成员，不能修改，除非成员用mutable修饰  \n一般const修饰对象与const修饰成员函数配合使用 \n\n```C++\nclass Data{\nprivate:\n    int data;\n    mutable int num;\npublic:\n    int data1;\n    mutable int num1;\npublic:\n    Data(){\n        cout<<\"无参构造\"<<endl;\n        data1 = 10;\n        num1 = 20;\n    }\n    Data(int data){\n        this->data = data;\n        cout<<\"有参构造\"<<endl;\n    }\n    Data(Data const &ob){\n        cout<<\"拷贝构造\"<<endl;\n    }\n    ~Data(){\n        cout<<\"析构函数\"<<endl;\n    }\n    void myfun() const\n    {\n        //data = 200;//error: assignment of member 'Data::data' in read-only object\n        num = 1000;//声明前面加了mutable 可以修改（打破规则）\n    }\n    void myfun1(){\n\n    }\n    void myfun2() const{\n\n    }\n\n};\n\nvoid test01(){\n    const Data ob1;\n    cout<<ob1.data1<<endl;\n    cout<<ob1.num1<<endl;\n    //ob1.data1 = 100;//error: assignment of member 'Data::data' in read-only object\n    ob1.num1 = 200;//加了mutable 可以 修改\n\n    cout<<ob1.data1<<endl;\n    cout<<ob1.num1<<endl;\n\n\n    cout<<\"-------------------\"<<endl;\n    //myfun1()即使里面没有修改成员变量的值也会报错 因为编译器不知道到底用户有没有修改 它不是智能的 所以编译器会认为你修改了 所以不能调用\n    //如果要调用成员函数必须加const修饰 比如myfun2()\n    //ob1.myfun1();//error: passing 'const Data' as 'this' argument discards qualifiers [-fpermissive]               ^\n\n    //myfun2()不能修改成员变量 除非加了mutable修饰的成员变量\n    ob1.myfun2();\n}\n```\n运行结果：\n![图片](./pic2.png)  \n\n\n-----------------------\n\n\n## 三、友元\n类的主要特点之一是数据隐藏，即类的私有成员无法在类的外部访问，但是有时候需要在类的外部访问类的私有成员而不借助公有的函数，怎么办呢？解决办法是使用友元函数，友元函数是一种特权函数，C++允许这个特权函数访问私有成员。这一点从现实生活中也可以很好的理解：比如你的家，有客厅，有你的卧室，那么你的客厅是public的，所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去，但是呢，你也可以允许你的闺蜜好基友进去。程序员可以把一个全局函数、某个类中的成员函数、甚至整个类声明为友元。  \n\n友元语法：  \n`friend `关键字只出现在声明处，其他类、类成员函数、全局函数都可声明为友元，友元函数不是类的成员，不带`this`指针，友元函数可访问对象任意成员属性，包括私有属性。  \n\n\n* 普通全局函数作为友元\n\n将全局函数在类中加friend关键字声明\n\n```C++\nclass Room{\n    //在类中加friend关键字声明，放在类中任何位置都可，private、public中都行\n    friend void goodFoundationFriends(Room &ob);\nprivate:\n    string livingRoom;\n    string bedRoom;\npublic:\n    Room(){\n        livingRoom = \"客厅\";\n        bedRoom = \"卧室\";\n    }\n};\nvoid goodFoundationFriends(Room &ob){\n    //这里为什么要传入类的对象呢？ 因为一个全局函数不一定是一个类的友元，需要传入类的对象确定访问的是哪一个类。\n    cout<<\"好基友访问了\"<<ob.livingRoom<<endl;\n    cout<<\"好基友访问了\"<<ob.bedRoom<<endl;\n}\n\nint main(int argc, char *argv[])\n{\n    Room ob1;\n    goodFoundationFriends(ob1);\n    return 0;\n}\n```\n运行结果：\n![图片](./pic3.png)  \n\n\n* 类的成员函数作为另一个类的友元\n\n    1. 问题一：为什么会报错？\n    ![图片](./pic4.png)  \n    类Room的定义在GoodFriend类后面，当编译到GoodFriend中有Room的时候，Room还没有定义。但是不能将Room的定义提前在GoodFriend类前，这样还是会出现问题，报错GoodFriends和其中的visit未定义。可以在GoodFriend前对Room进行声明.`class Room;`\n    2. 问题二\n    ![图片](./pic5.png)  \n    将Room类声明后没有报错了，但是出现了类中成员未定义的错误，如果我们将成员也去声明那就没有意义，那怎么做呢？\n    我们将GoodFriend中的visit1函数在类中声明，在类外定义，定义的时候在Room类之后就行了。\n    3. 问题三\n    ![图片](./pic6.png)  \n    这个报错怎么解决呢？为什么还是没有权限操作私有的成员。在类中对visit1方法的声明要表明其属于类，不然就跟普通全局函数一样了。\n\n```C++\n#include <iostream>\n\nusing namespace std;\nclass Room;\nclass GoodFriends{\npublic:\n//    void visit1(Room &ob){\n//        cout<<\"好朋友访问了你的\"<<ob.livingRoom<<endl;\n//        cout<<\"好朋友访问了你的\"<<ob.bedRoom<<endl;\n//    }\n    void visit1(Room &ob);\n};\n\nclass Room{\n    friend void GoodFriends::visit1(Room &ob);\nprivate:\n    string livingRoom;\n    string bedRoom;\npublic:\n    Room(){\n        livingRoom = \"客厅\";\n        bedRoom = \"卧室\";\n    }\n};\nvoid GoodFriends::visit1(Room &ob){\n    cout<<\"好朋友访问了你的\"<<ob.livingRoom<<endl;\n    cout<<\"好朋友访问了你的\"<<ob.bedRoom<<endl;\n}\nint main(int argc, char *argv[])\n{\n    Room ob1;\n    GoodFriends ob2;\n    ob2.visit1(ob1);\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic7.png)  \n\n\n* 一个类的整体作为另一个类的友元  \n\n即一个类的所有函数都可以访问另一个类的私有数据\n\n这个时候可以在上面`类的成员函数作为另一个类的友元`的基础上，将友元声明部分修改成类的友元就行，或者将两个类调换顺序，将Room类放在GoodFriends类的前面。对GoodFriends类在Room之前进行一下声明就行，但是好像不声明也不会报错。\n\n```C++\n#include <iostream>\n\nusing namespace std;\nclass GoodFriends;\nclass Room{\n    friend class GoodFriends;\nprivate:\n    string livingRoom;\n    string bedRoom;\npublic:\n    Room(){\n        livingRoom = \"客厅\";\n        bedRoom = \"卧室\";\n    }\n};\n\nclass GoodFriends{\npublic:\n    void visit1(Room &ob){\n        cout<<\"好朋友访问了你的\"<<ob.livingRoom<<endl;\n        cout<<\"好朋友访问了你的\"<<ob.bedRoom<<endl;\n    }\n};\nint main(int argc, char *argv[])\n{\n    Room ob1;\n    GoodFriends ob2;\n    ob2.visit1(ob1);\n    return 0;\n}\n```\n![图片](./pic7.png)  \n\n","tags":["随记"],"categories":["C++"]},{"title":"C++梁哥笔记day9","url":"/2020/12/30/C++梁哥笔记day9/","content":"\n\n\n# 类与对象\n\n## 一、（续day8）静态成员变量详解\n\n<!-- more -->\n\n* 静态成员函数的引出  \n在类定义中，前面有static说明的成员函数称为静态成员函数。静态成员函数使用方式和静态变量一样，同样在对象没有创建前，即可通过类名调用。静态成员函数主要为了访问静态变量，但是不能访问普通成员变量。静态成员函数的意义，不在于信息共享、数据沟通，而在于管理静态数据成员，完成静态数据成员的封装。\n静态成员函数只能访问静态成员变量，不能访问普通成员变量，静态成员函数的使用和静态成员变量一样，静态成员函数也有访问权限，普通成员函数可访问静态成员变量、也可以访问非静态成员变量。但是普通成员函数是依赖对象的，必须有对象后才能使用，但是对于私有静态成员通常我们不想通过创建对象后再调用方法使用、如果类没有实例化对象，难道就不能使用data了吗，解决这些问题就要用到静态成员函数。\n\n\n* 静态成员函数\n\n1、静态成员函数 属于类 可以通过类名称直接访问.  \n\n2、也可以通过对象名来访问\n```C++\nclass Data\n{\nprivate:\n    int num;//普通成员变量\n    static int data;//静态成员变量\npublic:\n    Data() {}\n    int getData(){\n        return data;\n    }\n    //静态成员函数\n    static int getStaticData(){\n        return data;\n    }\n};\nint Data::data = 100;\nvoid test01(){\n    //cout<<\"data:\"<<Data::data<<endl;//error: 'int Data::data' is private\n    //cout<<\"data:\"<<Data::getData()<<endl;//error: cannot call member function 'int Data::getData()' without object\n    cout<<\"data:\"<<Data::getStaticData()<<endl;\n}\n```\n运行结果：\n![图片](./pic1.png)  \n\n\n注意：  \n1、静态成员函数，存在的意义就是操作静态成员  \n2、静态成员函数不能访问普通成员变量  \n3、普通成员函数，既可以访问普通成员函数，也可以访问静态成员函数。\n\n* `const`修饰静态成员变量  \n如果一个类的成员，既要实现共享，又要实现不可改变，那就`static const`修饰。定义静态`const`数据成员时，最好在类内部初始化，类外定义要加`const`。\n\n```C++\nclass Data{\npublic:\n    static const int num1;\n    const static int num2;\n    const static int num3 = 30;\n};\nconst static int Data::num2 = 20;\n```\n\n\n> 练习：静态成员变量统计当前对象个数。\n\n* 单例模式设计（重要）\n单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只用一个实例而且该实例易于外界访问。从而方便对实例个数的控制并节约系统资源。如果在系统中某个类的对象只能存在一个，单例模式是最好的方案。\n![图片](./pic2.png)  \n\nSingleton（单例）：在单例类的内部实现只生成一个实例，同时它提供一个静态的getInstance()工厂方法，让客户可以访问它的唯一实例；为了防止在外部对其实例化，将其默认构造函数和拷贝函数拷贝构造函数设计为私有；在单例类内部定义了一个Singleton类型的静态对象，作为外部共享的唯一实例。  \n\n用单例模式，模拟公司员工使用打印机场景，打印机可以打印员工要输入的内容，并且可以累积打印机的使用次数。\n\n步骤一：在单例类内部定义一个Singleton类型的静态对象，作为外部共享的唯一实例  \n步骤二：提供一个静态方法，让客户可以访问它的唯一实例。  \n步骤三：为了防止在外部对其实例化，将其默认构造函数和拷贝构造函数设计为私有  \n\n```C++\nclass Data\n{\nprivate:\n    int num;//普通成员变量\n    static int data;//静态成员变量\npublic:\n    Data() {}\n    int getData(){\n        return data;\n    }\n    //静态成员函数\n    static int getStaticData(){\n        return data;\n    }\n};\nint Data::data = 100;\nvoid test01(){\n    //cout<<\"data:\"<<Data::data<<endl;//error: 'int Data::data' is private\n    //cout<<\"data:\"<<Data::getData()<<endl;//error: cannot call member function 'int Data::getData()' without object\n    cout<<\"data:\"<<Data::getStaticData()<<endl;\n}\nclass Printer{\nprivate:\n    //1.定义一个静态的对象指针变量 保存唯一实例\n    static Printer * singlePrint;\npublic:\n    //2.提供一个方法获得单例指针\n    static Printer * getSinglePrint(){\n        return singlePrint;\n    }\n    //3.防止该类实例化其他对象 将类构造方法 全部私有化\nprivate:\n    Printer(){count = 0;}\n    Printer(const Printer &ob){}\npublic:\n    //4.设置功能函数(自定义)\n    void printText(char *str){\n        cout<<\"打印\"<<str<<endl;\n        count++;\n    }\n    int count;\n};\nPrinter *Printer::singlePrint = new Printer;//这个定义相当于在类中 可以调用私有的默认构造方法 实例化对象不会报错\nint main(){\n    //打印任务1\n    Printer *p1 = Printer::getSinglePrint();\n    p1->printText(\"打印任务1-1\");\n    p1->printText(\"打印任务1-2\");\n\n    //打印任务2\n    Printer *p2 = Printer::getSinglePrint();\n    p2->printText(\"打印任务2-1\");\n    p2->printText(\"打印任务2-2\");\n    (*p2).printText(\"打印任务2-3\");\n\n    cout<<\"打印任务个数\"<<p1->count<<endl;\n    cout<<\"打印任务个数\"<<p2->count<<endl;\n    return 0;\n}\n```\n运行结果：\n![图片](./pic3.png)  \n\n\n\n\n---------------------\n\n\n## 二、C++面向对象模型初探\n\n* 成员变量和函数的存储  \n在C语言中，“分开来声明的，也就是说，语言本省并没有支持‘数据’和‘函数’之间的关联性，我们把这种程序方法称为‘程序性的’，由一组分布在各个以功能为导航的函数中”的算法驱动，他们处理的是共同的外部数据。\nC++实现了“封装”，那么数据（成员属性）和操作（成员函数）是什么样的呢？“数据”和“数理数据的操作（函数）”是分开存储的。C++中的非静态成员直接内含在类对象中，就像C中的struct一样。成员函数虽然内含在class声明之内，却不出现在对象中。每一个非内联成员函数只会诞生一份函数实例。  \n`总结：C++将数据和方法封装在一起，但是数据和方法是分开存储的，每个对象拥有独立的数据，每个对象共享同一个方法。`\n\n* `this`指针\n\n![图片](./pic4.png)\n哪个对象调用方法，那么方法中的this就指向哪个对象。\n\n* `this`指针的注意点\n    1. this指针是隐含在对象成员函数内的一种指针\n    2. 成员函数通过this指针即可知道操作的是哪个对象的数据\n    3. 静态成员函数内部没有this指针，静态成员函数不能操作非静态成员变量  \n    （静态成员函数属于类，函数内部没有this指针，无法判断操作的是哪个对象，所以不能操作）\n\n    模拟this指针：  \n    ![图片](./pic5.png)\n\n* `this`的应用\n    1. 当形参和成员变量同名时，可以用`this`指针来区分\n    ```C++\n    void setNum(int num){\n        this->num = num;\n    }\n    ```\n\n    2. 在类的非静态成员函数中返回对象本身，可以使用`return *this;`\n    ```C++\n    class MyCout\n    {\n    public:\n        MyCout& mycout(char *str){\n            cout<<str;\n            return *this;\n        }\n    };\n    void test02(){\n        MyCout ob;\n        ob.mycout(\"haha\").mycout(\"heihei\").mycout(\"xixi\");\n    }\n    ```\n    运行结果：\n    ![图片](./pic6.png)\n\n","tags":["随记"],"categories":["C++"]},{"title":"C++梁哥笔记day8","url":"/2020/12/29/C++梁哥笔记day8/","content":"\n# 类与对象\n\n## 一、`new`运算符\n\nC++中解决动态内存分配的方案是把创建一个对象所需要的操作都结合在一个称为`new`的运算符里。当用`new`创建一个对象时，它就在堆里为对象分配内存并调用构造函数完成初始化。\n\n<!-- more -->\n\n```C++\nPerson *person = new Person;  \n相当于：  \nPerson *person = (Person *)malloc(sizeof(Person));\nif(person == NULL){\n    return 0;\n}\n```\n\n* `new` 给基本类型创建空间\n```C++\nvoid test01(){\n    //基本类型\n    int *p = NULL;\n    //p = (int *)malloc(sizeof(int));\n    p = new int(100);//等价于 p = new int;*p = 100;\n    cout<<\"*p = \"<<*p<<endl;\n    //free(p);\n    delete p;\n}\n```\n运行结果：  \n![图片](./pic1.png)\n\n* `new` 给基本类型数组申请空间\n```\n//创建字符数组\nchar *pStr = new char[100];\n//创建整型数组\nint *pArr1 = new int[100];\n//创建字符数组并初始化\nchar *pStr = new char[5]{\"hello\"};//错误\nchar *pStr = new char[5]{'h','e','l','l','o'};//正确\n//创建整型数组并初始化\nint *pArr2 = new int[5]{1,2,3,4,5};\n\n//释放数组内存\ndelete[] pStr;\ndelete[] pArr1;\ndelete[] pArr2;\n```\n\n```C++\nvoid test02(){\n    int *arr = NULL;\n    //arr = (int *)malloc(sizeof(int)*5);\n    arr = new int[5]{0,1,2,3,4};\n    for(int i = 0; i < 5; i++){\n        cout<<arr[i]<<endl;\n    }\n    //数组空间的释放\n    delete [] arr;\n}\n```\n运行结果：  \n![图片](./pic2.png)\n\n> 注意：  \n>    1、new没有加[] delete释放的时候就不加[]  \n>    2、new加[] delete释放的时候就加[]\n\n* `new` 从堆区实例化对象 (使用`new`创建一个类 )\n```C++\nclass Person{\nprivate:\n    char m_name[32];\n    int m_num;\npublic:\n    Person(){\n        cout<<\"无参构造函数\"<<endl;\n    }\n\n    Person(char *name,int num){\n        strcpy(m_name,name);\n        m_num = num;\n        cout<<\"有参构造函数\"<<endl;\n    }\n    ~Person(){\n        cout<<\"析构函数\"<<endl;\n    }\n    void showPerson(){\n        cout<<\"name:\"<<m_name<<\" m_num:\"<<m_num<<endl;\n    }\n};\nvoid test03(){\n    Person *p1 = new Person;\n    Person *p2 = new Person(\"lucy\",100);\n    // p2->showPerson();\n    //delete 先调用析构函数 再释放空间\n    delete p1;\n    delete p2;\n}\n```\n运行结果：  \n![图片](./pic3.png)\n\n* 对象数组 \n本质是数组，元素是对象\n当创建一个对象数组的时候，必须对数组中的每一个对象调用构造函数，处理在栈上可以聚合初始化，必须提供一个默认的构造函数 \n\n```C++\nvoid test04(){\n    //定义对象数组的时候 系统会自动给数组中的每个元素调用构造函数\n    //自动调用无参构造函数\n    Person arr1[5];\n}\n```\n\n运行结果：  \n![图片](./pic4.png)  \n\n如果想让对象数组中的元素调用有参构造 必须人为使用有参构造初始化\n\n```C++\nvoid test05(){\n    //初始化部分调用有参构造函数 未初始化部分调用默认构造函数\n    Person arr1[5]={Person(\"lucy\",20),Person(\"bob\",18)};\n    //arr1[0]就是第0个元素Person对象\n    arr1[0].showPerson();\n    arr1[1].showPerson();\n}\n```\n运行结果：  \n![图片](./pic5.png)  \n\n* `new`创建对象数组\n\n```C++\nvoid test06(){\n    //第一种方式\n    Person *arr1 = new Person[5];//调用五个无参构造\n\n    //第二种方式\n    Person *arr2 = new Person[5]{Person(\"lucy\",20),Person(\"bob\",18)};//调用两个有参构造 和 三个无参构造函数\n\n    delete [] arr1;\n    delete [] arr2;\n}\n```\n运行结果：  \n![图片](./pic6.png)  \n\n* delete void *可能会出错  \n如果对一个void *指针执行delete操作，这将可能成为一个程序错误，除非指针指向的内容是非常简单的，因为它将不执行析构函数，以下代码未调用析构函数，导致可能内存减少\n```C++\nvoid test07(){\n    Person *p1 = new Person(\"lucy\",100);\n    p1->showPerson();\n    void *p2 = p1;\n    delete p2;\n}\n```\n运行结果：  \n![图片](./pic7.png)  \n没有调用析构函数\n\n> 尽量不要用delete释放void *\n\n为什么没有调用析构呢？  \n`void *`系统不知道所指向的类型，不知道去调用哪个对象的析构函数，\n\n\n* malloc、free和new、delete可以混搭使用吗？  \n不可以。\n--------------\n\n\n## 二、静态成员变量详解\n在类定义中，它的成员（包括成员变量和成员函数），这些成员可以用关键字static声明为静态的，成员静态成员。不管这个类创建了多少个对象，静态成员只有一个拷贝，这个拷贝被所有属于这个类的对象共享。\n\n* 静态成员变量  \n在一个类中，若将一个成员变量声明为static，这种成员称为静态成员变量，与一般的数据成员不同的，无论建立多少个对象，都只有一个静态数据的拷贝。静态成员变量，属于某个类，所有对象共享。静态变量，是在编译阶段就分配空间，对象还没有创建时，就已经分配了空间。  \n静态成员变量必须`在类中声明，类外定义。`静态数据成员不属于某个对象，在为对象分配空间中不包括静态成员所占空间。静态数据成员可以通过类名或者对象名来引用。  \n总结：1、静态变量，是在编译阶段就分配空间，对象还没有创建时，就已经分配了空间。2、静态成员变量必须`在类中声明，类外定义。`\n\n> 成员包括：成员变量、成员方法（函数）\n\n```C++\nclass Data{\npublic:\n    int num;//普通成员变量\n    static int data;//静态成员变量（类中声明，类外定义）\n};\n//定义的时候不需要加static\nint Data::data = 100;//类外定义，初始化\nvoid test01(){\n    //data是公有静态成员变量 是属于类 没有定义对象 也可以通过类名称直接访问\n    cout<<\"data=\"<<Data::data<<endl;\n    Data::data = 200;//赋值\n    cout<<\"data=\"<<Data::data<<endl;\n\n    //data静态变量 也是属于所有对象的 是共享的 也可以通过对象名访问\n    Data ob1;\n    ob1.data = 300;\n    cout<<\"data:\"<<ob1.data<<endl;\n}\n```\n运行结果：  \n![图片](./pic8.png)  \n\n\n* 静态成员函数的引出  \n在类定义中，前面有static说明的成员函数称为静态成员函数。静态成员函数使用方式和静态变量一样，同样在对象没有创建前，即可通过类名调用。静态成员函数主要为了访问静态变量，但是不能访问普通成员变量。静态成员函数的意义，不在于信息共享、数据沟通，而在于管理静态数据成员，完成静态数据成员的封装。\n静态成员函数只能访问静态成员变量，不能访问普通成员变量，静态成员函数的使用和静态成员变量一样，静态成员函数也有访问权限，普通成员函数可访问静态成员变量、也可以访问非静态成员变量。但是普通成员函数是依赖对象的，必须有对象后才能使用，但是对于私有静态成员通常我们不想通过创建对象后再调用方法使用、如果类没有实例化对象，难道就不能使用data了吗，解决这些问题就要用到静态成员函数。\n","tags":["随记"],"categories":["C++"]},{"title":"C++梁哥笔记day7","url":"/2020/12/27/C++梁哥笔记day7/","content":"# 类与对象\n\n## 一、构造函数的调用规则\n默认情况下，c++编译器至少为我们写的类增加三个函数：  \n\n<!-- more -->\n\n1、默认构造函数（无参、函数体为空）   \n2、默认析构函数（无参、函数体为空）  \n3、默认拷贝构造函数（对类中非静态成员属性进行简单的值拷贝<浅拷贝>）  \n\n>1.如果用户提供了有参构造，将屏蔽默认构造函数  \n2.如果用户定义了析构函数，将会屏蔽默认析构函数，不会屏蔽默认构造函数和拷贝构造函数  \n3.如果用户定义了拷贝构造函数，将屏蔽默认构造函数和默认拷贝构造函数\n\n总结：为了避免以上的情况，用户定义的类一般要实现，无参构造函数、有参构造函数、拷贝构造函数和析构函数\n\n\n------------------\n\n## 二、深拷贝和浅拷贝\n\n* 浅拷贝  \n同一个类型的对象之间可以赋值，使得两个对象的成员变量的值相同，两个对象仍然是独立的两个对象，这种情况被称为浅拷贝，一般情况下，浅拷贝是没有任何副作用的，但是当类中有指针，并且指针指向动态分配的内存空间，而浅拷贝的赋值只是将引用进行了赋值，两个指针指向的是同一片空间，当析构函数做动态内存释放的时候会导致内存重复释放。  \n`仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。`\n![图片](./pic1.png)\n\n* 深拷贝  \n`在计算机中开辟一块新的内存地址用于存放复制的对象。`\n![图片](./pic2.png)\n\n> 在拷贝构造函数中实现深拷贝\n\n\n---------------------\n\n## 三、初始化列表\n构造函数和其他函数不同，除了有名字，参数列表，函数体之外还有初始化列表。  \n初始化列表的简单使用：\n```C++\nclass Data{\n    private:\n        int m_a;\n        int m_b;\n        int m_c;\n    public:\n        Data(){}\n        /*传统方法初始化\n        Data(int a,int b,int c){\n            m_a = a;\n            m_b = b;\n            m_c = c;\n        }\n        */\n        Data(int a,int b,int c):m_a(a),m_b(b),m_c(c)\n        {\n\n        }\n        void showData(){\n            cout<<\"m_a=\"<<m_a<<\" m_b=\"<<m_b<<\" m_c=\"<<m_c<<endl;\n        }\n};\nvoid test02(){\n    Data ob(10,20,30);\n    ob.showData();\n}\n```\n运行结果：  \n![图片](./pic3.png)  \n\n> 注意：初始化成员列表（参数列表）只能在构造函数中使用。\n\n---------------------\n\n\n## 四、类的对象作为另一个类的成员（初始化列表的用途）\n\n在类中定义的数据成员一般都是基本的数据类型。但是类中的成员也可以是对象，叫做对象成员。C++中对对象的初始化是非常重要的操作，当创建一个对象的时候，C++编译器必须确保调用了所有子对象的构造函数。如果所有子对象有默认构造函数，编译器可以自动调用他们。但是如果自对象没有默认的构造函数，或者想指定调用某个构造函数怎么办？那么是否可以在类的构造函数直接调用子类的属性完成初始化呢？但是如果子类的成员属性是私有的，我们没有办法访问并完成初始化。解决办法非常简单：对于子类调用构造函数，C++为此提供了专门的语法，即构造函数初始化列表。当调用构造函数时，首先按各对象成员在类定义中的顺序（和参数列表的顺序无关）依次调用它们的构造函数，对这些对象初始化，最后在调用本身的函数体。也就是说，先调用对象成员的构造函数，再调用本身的构造函数。析构函数和构造函数的调用相反，先构造，后析构。\n\n```C++\nclass A{\nprivate:\n    int m_a;\npublic:\n    A(){\n        cout<<\"A无参构造函数\"<<endl;\n    }\n    A(int a){\n        m_a = a;\n        cout<<\"A有参构造函数\"<<endl;\n    }\n};\nclass B{\nprivate:\n    int m_b;\npublic:\n    B(){\n        cout<<\"A无参构造函数\"<<endl;\n    }\n    B(int b){\n        m_b = b;\n        cout<<\"A有参构造函数\"<<endl;\n    }\n};\nclass Data{\n    private:\n        A oba;//对象成员\n        B obb;\n        int data;\n    public:\n        Data(){\n            cout<<\"Data无参构造函数\"<<endl;\n        }\n        ~Data(){\n            cout<<\"Data析构函数\"<<endl;\n        }\n\n};\nvoid test03(){\n    Data ob;\n}\n```\n运行结果：  \n![图片](./pic4.png)  \n\n\n```C++\nclass A{\nprivate:\n    int m_a;\npublic:\n    A(){\n        cout<<\"A无参构造函数\"<<endl;\n    }\n    A(int a){\n        m_a = a;\n        cout<<\"A有参构造函数\"<<endl;\n    }\n};\nclass B{\nprivate:\n    int m_b;\npublic:\n    B(){\n        cout<<\"A无参构造函数\"<<endl;\n    }\n    B(int b){\n        m_b = b;\n        cout<<\"A有参构造函数\"<<endl;\n    }\n};\n\nclass Data{\n    private:\n        A oba;//对象成员\n        B obb;\n        int data;\n    public:\n        Data(){\n            cout<<\"Data无参构造函数\"<<endl;\n        }\n        Data(int a,int b,int c):oba(a),obb(b),data(c)\n        {\n            cout<<\"Data有参构造函数\"<<endl;\n        }\n        ~Data(){\n            cout<<\"Data析构函数\"<<endl;\n        }\n\n};\nvoid test04(){\n    Data ob(10,20,30);\n}\n```\n运行结果：  \n![图片](./pic5.png)  \n\n\n---------------\n\n## 五、explicit关键字\n\nC++提供了关键字`explicit`，禁止通过构造函数进行的隐式转换。声明为`explicit`的构造函数不能在隐式转换中使用。  \n注意：`explicit`用于修饰构造函数，防止隐式转化。是针对单参数的构造函数(或者除了第一个参数外其余参数都有默认值的多参数构造函数而言)\n\n```C++\nclass Data{\n    private:\n        int data;\n    public:\n        Data(){}\n        Data(int a){\n            data = a;\n        }\n        void showData(){\n            cout<<\"data=\"<<data<<endl;\n        }\n\n};\nvoid test05(){\n    Data ob = 30;\n    ob.showData();\n\n}\n```\n运行结果：  \n![图片](./pic6.png)  \n\n```C++\nclass Data{\n    private:\n        int data;\n    public:\n        Data(){}\n        explicit Data(int a){\n            data = a;\n        }\n        void showData(){\n            cout<<\"data=\"<<data<<endl;\n        }\n\n};\nvoid test05(){\n    Data ob = 30;//隐式转换 Data ob(30);\n    ob.showData();\n\n}\n```\n运行结果：  \n![图片](./pic7.png)  \n\n\n------------------------\n\n## 六、new delete 与 malloc 的区别\n对象的动态创建\n\n* 对象的创建  \n    当创建一个C++对象时会发生两件事   \n    1. 为对象分配内存\n    2. 调用构造函数来初始化那块内存，第一步我们能保证实现，需要我们确保第二步一定能发生。C++强迫我们这么做事因为使用未初始化对象是程序出错的一个重要的原因。\n* C动态内存分配的方法  \n    为了在运行时动态分配内存，C在它的标准库中提供了一些函数，malloc以及他的变种calloc和realloc，释放内存的free，这些函数是有效的，但是它们是原始的，需要程序员理解和小心使用。为了使用C动态内存分配函数在堆上创建一个类的实例我们必须要申请空间啊、判断啊，这就比较麻烦。\n\n* 问题：\n    1. 程序员必须确定对象的长度\n    2. malloc返回一个void指针，c++不允许将void赋值给其他任何指针，必须进行强制类型转换。\n    3. malloc可能会申请失败，所以必须判断返回值来确保内存分配成功。\n    4. 用户在使用对象之前必须记住对他进行初始化化，构造函数不能显示调用初始化（构造函数是由编译器调用），用户有可能忘记调用初始化函数。\n    5. !!! malloc不会调用构造函数 free不会调用析构函数（重点）  \n\n```C++\nclass Data{\n    public:\n        int data;\n    public:\n        Data(){\n            cout<<\"Data无参构造函数\"<<endl;\n        }\n        Data(int n)\n        {\n            data = n;\n            cout<<\"Data有参构造函数\"<<endl;\n        }\n        ~Data(){\n            cout<<\"Data析构函数\"<<endl;\n        }\n        void showData(){\n            cout<<\"data=\"<<data<<endl;\n        }\n};\nvoid test06(){\n    Data *p = (Data *)malloc(sizeof(Data));\n    if(NULL == p){\n        return;\n    }\n    p->data = 10;\n    p->showData();\n    free(p);\n}\n```\n运行结果：  \n![图片](./pic8.png)  \n不能调用构造函数 也不能调用析构函数\n\n------------\n\n","tags":["随记"],"categories":["C++"]},{"title":"C++梁哥笔记day6","url":"/2020/12/27/C++梁哥笔记day6/","content":"\n# 类与对象\n\n## 一、类的扩展\n1. 类的大小  \n成员函数不占用类的大小 成员函数在代码区\n\n<!-- more -->\n\n```C++\nclass Data{\n    private:\n        int num;\n    public:\n        int getNum(){\n            return num;\n        }\n        void setNum(int n){\n            num = n;\n        }\n};\nvoid test01(){\n    cout<<\"sizeof(Data):\"<<sizeof(Data)<<endl;\n}\n```\n运行结果：  \n![图片](./pic1.png)\n\n2. 在类里声明成员函数 在类外定义\n\n```C++\nclass Data{\n    private:\n        int num;\n    public:\n        int getNum();\n        void setNum(int n);\n};\nint Data::getNum(){\n    return num;\n}\nvoid Data::setNum(int n){\n    num = n;\n}\nvoid test02(){\n    Data d1;\n    d1.setNum(100);\n    cout<<\"num:\"<<d1.getNum()<<endl;\n}\n```\n运行结果：  \n![图片](./pic2.png)\n\n3. 分文件实现类（类的定义在头文件,成员函数在cpp中实现）  \n![图片](./pic3.png)  \n\n`data.h`  \n```C++\n#ifndef DATA_H\n#define DATA_H\n\nclass Data\n{\nprivate:\n    int num;\npublic:\n     int getNum();\n     void setNum(int n);\n};\n\n#endif // DATA_H\n\n```\n`data.cpp`\n```C++\n#include \"data.h\"\n\nint Data::getNum(){\n    return num;\n}\nvoid Data::setNum(int n){\n    num = n;\n}\n\n```\n`main.cpp`\n```C++\n#include <iostream>\nusing namespace std;\n#include \"data.h\"\nvoid test03(){\n    Data d1;\n    d1.setNum(100);\n    cout<<\"num:\"<<d1.getNum()<<endl;\n}\nint main(int argc, char *argv[])\n{\n    test03();\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic4.png)\n\n\n\n\n------------------------------\n\n\n\n## 二、对象的构造和析构\n构造函数和析构函数，这两个函数将会被编译器自动调用，构造函数完成对象的初始化动作，析构函数在对象结束的时候完成清理工作。  \n注意：对象的初始化和清理工作是编译器强制我们要做的事情，即使你不提供初始化操作和清理操作，编译器也会给你增加默认的操作，只是这个默认的初始化操作不会做任何事情。（空的函数）\n\n### 1. 构造函数和析构函数的概述   \n构造函数主要用于创建对象时为对象的成员属性赋值，构造函数由编译器自动调动，无需手动调用。析构函数主要用于对象销毁前系统自动调用，执行一些清理工作。  \n\n构造函数：实例化对象的时候系统自动调用。  \n析构函数：对象释放的时候系统自动调用。\n\n### 2. 构造函数和析构函数的定义\n\n构造函数的语法：`构造函数函数名和类名相同，没有返回值，不能有void，但可以有参数，可以重载。 ClassName(){}`  \n\n析构函数的语法：`析构函数函数名是在类名前加\"~\"组成，没有返回值，不能有void，不能有参数，不能进行函数重载 ~ClassName(){}`\n\n```C++\nclass Data1\n{\nprivate:\n    int num;\npublic:\n    Data1(){\n        num  = 0;\n        cout<<\"无参构造函数\"<<endl;\n    }\n    Data1(int n){\n        num = n;\n        cout<<\"带参构造函数\"<<endl;\n    }\n    ~Data1(){\n        cout<<\"析构函数\"<<endl;\n    }\n    int getNum(){\n    return num;\n    }\n    void setNum(int n){\n        num = n;\n    }\n};\nvoid test10(){\n    Data1 num1;\n}\n\nint main(int argc, char *argv[])\n{\n    test10();\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic5.png)  \n\n### 3.构造函数的分类以及调用\n\n1. 构造函数的分类\n- 按参数类型：分为无参构造函数和有参构造函数\n- 按类型分类：普通构造函数和拷贝构造函数（复制构造函数）\n\n2. 构造函数的调用   \n+ 无参构造的调用形式：  \n    * 实例化对象时：\n        - 隐式调用：`Data d1;`\n        - 显示调用：`Data d2  = Data();`\n+ 有参构造的调用形式：  \n    * 实例化对象时：\n        - 隐式调用：`Data d3(10);`\n        - 显示调用：`Data d4  = Data(20);`\n        - 隐式转换的方式（针对于只有一个数据成员）：`Data d5 = 30;//转化成Data d5(30)`（尽量不用）\n        - 匿名对象(当前语句结束，匿名对象立即释放)：`Data(50)`;  \n\n\n千万不要以以下代码这种方式调用无参构造函数：  \n```C++\nint main(){\n    Data d1();//编译器不会认为是实例化对象d1，而是看成了函数d1的声明\n    return 0;\n}\n```\n\n> 注意：在同一作用域中，构造和析构的顺序相反，即最先构造的最后析构（释放）\n\n\n\n### 4.拷贝构造函数的调用\n1. 拷贝构造函数  \n```C++\n//拷贝构造函数\n    Data(const Data &d){\n        cout<<\"拷贝构造函数\"<<endl;\n        num = d.num;\n    }\n```\n```C++\nclass Data\n{\nprivate:\n    int num;\npublic:\n    Data(){\n        num  = 0;\n        cout<<\"无参构造函数\"<<endl;\n    }\n    Data(int n){\n        num = n;\n        cout<<\"带参构造函数\"<<endl;\n    }\n    ~Data(){\n        cout<<\"析构函数\"<<endl;\n    }\n    //拷贝构造函数\n    Data(const Data &d){\n        cout<<\"拷贝构造函数\"<<endl;\n    }\n    int getNum(){\n    return num;\n    }\n    void setNum(int n){\n        num = n;\n    }\n};\n```\n\n如果用户没有定义拷贝构造函数，系统会提供一个默认的拷贝构造函数，进行的赋值操作（浅拷贝）\n\n```C++\nvoid test11(){\n    Person lucy;\n    lucy.setAge(20);\n    lucy.setName(\"lucy\");\n    //如果用户没有实现构造函数，系统将调用默认的拷贝构造函数\n    //默认的拷贝构造函数：淡出的整体赋值（浅拷贝）\n    //如果用户实现了拷贝构造函数，系统将调用用户实现的拷贝构造函数，不会调用默认的拷贝构造函数了\n    Person bob = lucy;\n    lucy.showPerson();\n    bob.showPerson();\n}\n```\n运行结果：  \n![图片](./pic6.png)  \n\n2. 拷贝构造函数的调用形式   \n* 隐式调用拷贝构造函数：`Person bob(lucy);`\n* 显式调用拷贝构造函数：`Person bob = Person(lucy);`\n* 隐式转换调用：`Person bob = lucy;`（用的最多）\n\n> 什么时候会调用拷贝构造函数：记住一句话，旧对象初始化为新对象，才会调用拷贝构造函数。\n\n下面的代码就不会调用拷贝构造函数：只是赋值\n```C++\nvoid test11(){\n    Person lucy;\n    lucy.setAge(20);\n    lucy.setName(\"lucy\");\n    Person bob;\n    bob = lucy;\n    lucy.showPerson();\n    bob.showPerson();\n}\n```\n运行结果：  \n![图片](./pic7.png)  \n\n3. 拷贝构造函数的注意事项：\n    * 不能调用拷贝构造函数去初始化匿名对象，也是就说以下代码不正确\n    ```C++\n        void test12(){\n            Data d1(10);//有参构造\n\n            //调用不了拷贝构造函数 错\n            Data(d1);//Data(d1) ==> Data d1;造成d1重定义\n        }\n    ```\n\n    * 对象作为函数的参数，如果实参与形参都是普通对象，那么会调用拷贝构造函数\n    ```C++\n        //函数的形参是在函数调用的时候开辟空间\n        //此处的ob 就会调用拷贝构造\n        void myPrintData(Data ob){//Data ob = ob1;\n            cout<<\"num = \"<<ob.num<<endl;\n        }\n        void test13(){\n            Data ob1(10);\n            myPrintData(ob1);\n        }\n    ```\n\n    * 函数返回局部对象，在qtcreate中会被编译器优化，从而调用不了拷贝构造函数\n    ```C++\n    Data returnData(){\n        Data ob1(10);//调用有参构造函数\n        return ob1;\n    }\n    void test14(){\n        Data ob2 = returnData();\n        //实际上是ob2指向了ob1的空间，ob2的引用等于ob1的引用，并没有调用拷贝构造函数\n    }\n    ```\n\n\n\n","tags":["随记"],"categories":["C++"]},{"title":"C++梁哥笔记day5","url":"/2020/12/26/C++梁哥笔记day5/","content":"\n# 类和对象 \n## 一、封装\n1. 把变量（属性）和函数（操作）合成一个整体，封装在一个类中\n2. 对变量和函数进行访问控制，访问权限的设置（公有的、私有的、保护的）\n<!-- more -->\n3. 在类的内部（作用域范围内），没有访问权限之分，所有成员都可以相互访问\n4. 在类的外部，访问权限才有意义：public、protected、private\n5. 在类的外部，只有public修饰的成员才能被访问，在没有涉及继承与派生时，private和protected是同等级的，外部不允许访问。  \n\n|访问属性|属性|对象内部|对象外部|\n|:---:|:---:|:---:|:---:|\n|public|公有|可访问|可访问|\n|protected|保护|可访问|不可访问|\n|private|私有|不可访问|不可访问|  \n\n> 权限是对外不对内的\n\n## 二、类的初始\n```C++\nclass 类名{//抽象的概念 系统不会为其分配空间\n    \n    private://私有的 类的外部 不可直接访问\n    protected://保护的 类的外部 不可直接访问\n    public://公有的 类的外部 可以直接访问\n    数据\n    方法\n    //在类的内部没有权限之分 都可以相互访问\n};\n```\n系统不会为类分配空间但是他占有空间，当实例化或定义一个对象的时候系统才会为其分配空间\n\n* class与struct的区别：class默认访问权限为private，struct默认访问权限为public。\n\n### 将成员变量设置为private\n1. 可以赋予客户端访问数据的一致性。如果成员变量不是public，客户端唯一能够访问对象的方法就是通过成员函数。如果类中所有public权限的成员都是函数，客户在访问类成员时只会默认访问函数，不需要考虑访问的成员需不需要添加(),这就省下了许多搔首弄耳的时间。\n2. 可细微划分访问控制。使用成员函数可使得我们对变量的控制处理更加精细。如果我们让所有的成员变量为public，每个人都可以读写它。如果我们设置为private，我们可以实现不准访问、只读访问、读写访问，甚至你可以写出只写访问。\n\n**练习**  \n请设计一个Person类，Person类具有name和age属性，提供初始化函数Init(),并对name和age的读写函数set()、get()，但必须确保age的赋值在有效范围0~100，超出有效范围，拒绝赋值，并提供方法输出姓名和年龄。\n```C++\nclass Person{\n    private:\n        char m_name[32];\n        int m_age;\n    public:\n        void Init(char *name,int age){\n            if(name != NULL)\n                strcpy(m_name,name);\n            if(age <100 && age>0){\n                m_age = age;\n            }else{\n                cout<<\"输入数据无效\"<<endl;\n            }\n        }\n        void setName(char *name){\n            if(name != NULL)\n                strcpy(m_name,name);\n        }\n        char *getName(){\n            return m_name;\n        }\n        void setAge(int age){\n            if(age <100 && age>0){\n                m_age = age;\n            }else{\n                cout<<\"输入数据无效\"<<endl;\n            }\n        }\n        int getAge(){\n            return m_age;\n        }\n        void showPerson(){\n            cout<<\"name:\"<<m_name<<\" age:\"<<m_age<<endl;\n        }\n};\nint main(int argc, char *argv[])\n{\n    Person p1;\n    p1.Init(\"lucy\",20);\n    p1.showPerson();\n    cout<<p1.getAge()<<endl;\n    p1.setAge(30);\n    p1.setName(\"bob\");\n    p1.showPerson();\n    cout<<p1.getName()<<endl;\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic1.png)","tags":["随记"],"categories":["C++"]},{"title":"C++梁哥笔记day4","url":"/2020/12/25/C++梁哥笔记day4/","content":"\n# 一、内联函数\n## 宏函数与内联函数的比较\nc++从c中继承的一个重要的特征就是效率。假如c++的效率明显低于c的效率，那么就会有很大的一批程序员不去用c++了。在c中我们经常把一些短并且执行频繁的计算写成宏，而不是函数，这样做的理由是为了执行效率，宏可以避免函数调用的开销，这些都由预处理来完成。但是c++出现之后，使用预处宏会出现两个问题：第一个在c中也会出现，宏看起来像一个函数调用，但是会有隐藏一些难以发现的错误。第二个问题是c++特有的，预处理器不允许访问类的成员，也就是说预处理宏不能用作类的成员函数。  \n<!-- more -->\n为了保持预处理宏的效率又增加安全性，而且还能像一般成员函数那样可以在类里访问自如，c++引入了内联函数（inline function）  \n内联函数为了继承宏函数的效率，没有函数调用时的开销，然后又可以像普通函数那样，可以进行参数、返回值类型的安全检查，有可以作为成员函数。\n\n## 预处理宏的缺陷\n* 问题一：\n```C++\n#define ADD(x,y) x+y\ninline int Add(int x,int y){\n    return x + y;\n}\nvoid test01(){\n    int ret1 = ADD(10,20) * 10;//希望的结果是300 实际上是210\n    int ret2 = Add(10,20) * 10;//希望的结果是300 实际上也是300\n    cout<<\"ret1=\"<<ret1<<endl;\n    cout<<\"ret2=\"<<ret2<<endl;\n}\n```\n运行结果：  \n![图片](./pic1.png)\n\n这个问题可以通过添加括号来解决 `#define ADD(x,y) x+y  ---> #define ADD(x,y) (x+y)` ,问题二则无法解决  \n* 问题二：\n```C++\n#define COMPARE(x,y) ((x) < (y) ? (x) : (y))\ninline int Compare(int x,int y){\n    return x < y ? x : y;\n}\nvoid test02(){\n    int a=1;\n    int b=3;\n    cout<<\"COMPARE(++a,b)=\"<<COMPARE(++a,b)<<endl;//3\n    cout<<\"Compare(++a,b)=\"<<Compare(++a,b)<<endl;//2\n}\n```\n运行结果：  \n![图片](./pic2.png)\n\n按道理运行结果应该是`3 2`，实际上运行出来都是`3`，我有点迷啊\n\n* 问题三：\n预定于宏函数没有作用域概念，无法作为一个类的成员函数，也就是说预定义宏没有办法表示类的范围。\n\n\n## 内联函数的概率\n在c++中，预定义宏的概念是用内联函数来实现的，而内联函数本身也是一个真正的函数。内联函数具有普通函数的所有行为。唯一不同之处在于内联函数会在适当的地方像预定于宏一样展开，所以不需要函数调用的开销（压栈入栈）。因此应该不使用宏，使用内联函数。在普通函数（非成员函数）前面加上`inline`关键字使之成为内联函数。但是必须注意必须函数体和声明结合在一起，否则编译器将它作为普通函数来对待。inline void func(int a);以上写法没有任何效果，仅仅是声明函数，应该如下方式来做：inline void func(int a){ return a++;}  \n注意：编译器将会检查参数列表使用是否正确，并返回值（进行必要的转换）。这些是预处理器无法完成的。内联函数的确占用空间，但是内联函数相对于普通函数的优势只是省去了函数调用时候的压栈、跳转、返回的开销。我们可以理解为内联函数是以空间换时间。\n\n* 类内部的内联函数  \n  为了定义内联函数，通常必须在函数第一前面放一个inline关键字，但是类内部定义内联函数时并不是必须的。任何类内部定义的函数自动成为内联函数。\n```C++\nclass Person{\npublic:\n        Person(){\n            cout<<\"构造函数\"<<endl;\n        }\n        void PrintPerson(){\n            cout<<\"输出Person！\"<<endl;\n        }\n}\n```\n* 内联函数和编译器的关系  \n    内联函数并不是何时何地都有效，为了理解内联函数何时有效，应该要知道编译器碰到内联函数会怎么处理？  \n    对于任何类型的函数，编译器会将函数类型（包括函数名字、参数类型、返回值类型）放到符号表中。同样，当编译器看到内联函数，并且对内联函数体进行分析没有发现错误时，也会将内联函数放到符号表。当的调用一个内联函数的时候，编译器首先确保传入参数类型是正确匹配的，或者如果类型不正确匹配，但是可以将其转换为正确类型，并且返回值在目标表达式里匹配正确类型，或者可以转换为目标类型，内联函数就会直接替换函数调用，这就消除了函数调用的开销。假如内联函数是成员函数，对象this指针也会被放入合适位置。类型检查和类型转换、包括在合适位置放入对象this指针这些都是预处理器并完成的。\n    \n    > 但是c++内联编译会有一些限制，以下情况编译器可能考虑不会将函数进行内联编译：  \n    > 1、 不能存在任何形式的循环语句\n    > 2、 不能存在过多的条件判断语句\n    > 3、 函数体不能过于庞大，不能对函数进行取址操作\n\n    内联仅仅只是给编译器一个建议，编译器不一定会接受这种建议，如果你没有将函数声明为内联函数，那么编译器也可能将此函数进行内联编译。一个好的编译器将会内联小的、简单的函数。\n\n\n-------------------------------------------------------------\n\n\n# 二、缺省函数 函数的默认（缺省 ）参数\n\nc++在声明函数原型的时候可以为一个或者多个参数指定默认（缺省）的参数值，当函数调用的时候如果没有指定这个值，表一起会自动用默认值代替。\n\n```C++\nint my_add(int x=10,int y=20){\n    return x + y;\n}\nvoid test03(){\n    cout<<my_add()<<endl;//30\n    cout<<my_add(20)<<endl;//40\n    cout<<my_add(100,200)<<endl;//300\n}\n```\n运行结果：  \n![图片](./pic3.png)\n\n注意：  \n1. 函数的默认参数从左到右，如果一个参数设置了默认参数，那么这个参数之后的参数都必须设置默认参数  \n```C++\nint my_add(int x,int y=20,int z=30){\n    return x + y + z;\n}\nvoid test04(){\n    cout<<my_add(10)<<endl;//60\n    cout<<my_add(10,40)<<endl;//80\n    cout<<my_add(10,40,80)<<endl;//130\n}\n```\n运行结果：  \n![图片](./pic4.png)\n\n2. 函数如果是分文件的，默认参数应设置在函数的声明中，在函数的定义中设置默认参数，编译器不会报错，但没有效果。\n\n`func.c`\n```C++\nint my_add(int x=10,int y=20,int z=30){//在这里进行的默认参数的设置不会起效果 应该在声明中设置\n    return x + y + z;\n}\n```\n`main.c`\n```C++\nextern int my_add(int x,y=100,z=200);\nvoid test05(){\n    cout<<my_add(10)<<endl;//310\n    cout<<my_add(10,40)<<endl;//250\n    cout<<my_add(10,40,80)<<endl;//130\n}\nint main(){\n    test05();\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic5.png)\n\n\n------------------------\n\n# 三、函数的占位参数\nc++在声明函数时，可以设置占位参数。占位参数只有参数类型声明，而没有参数名声明，一般情况下，在函数体内部无法使用占位参数。但是调用函数的时候必须要给占位参数传值。占着茅肯不拉屎。  \n占位参数也可以设置默认值。\n\n```C++\nvoid func1(int a,int b,int ){\n    cout<<a<<\" \"<<b<<endl;\n}\nvoid func2(int a,int b,int =20){\n    cout<<a<<\" \"<<b<<endl;\n}\nvoid test06(){\n    //func1(10,20);//错误调用 缺少一个参数\n    func2(10,20);//占位参数有默认值，可以不传值\n    func1(10,20,30);\n}\n```\n运行结果：  \n![图片](./pic6.png)\n\n> 什么时候用，在后面操作符重载的后置++要用到这个\n\n\n--------------------------------\n\n\n# 四、函数重载（c++多态的特性）\n\n函数重载：同一个函数在不同场景下可以具有不用的含义。  \n函数重载的意义：方便函数名的使用\n\n## 函数重载基本语法\n\n实现函数重载的条件：同一作用域 参数个数不同 参数类型不同 参数顺序不同\n\n注意：  \n1、函数的返回值不能作为函数重载的依据  \n2、函数重载和默认参数一起使用，要注意二义性\n\n\n## 函数重载实现原理\n编译器为了实现函数重载，也是默认为我们做了一些幕后的工作，编译器用不同的参数类型来修饰不同的函数名，比如void func();编译器可能会将函数名修饰成funcv，当编译器碰到void func(int x),编译器可能会将函数名修饰成funcint，当编译器碰到void func(int x,char c),编译器可能会将函数名修饰为funcintchar，我这里使用“可能”这个字眼是因为编译器如何修饰重载的函数名称并没有一个统一的标准，所以不同的编译器可能会产生不同的内部名。  \n`void func(){}`  \n`void func(int x){}`  \n`void func(int x,char c){}`  \n\n以上三个函数在Linux下生成的编译之后的函数名为：  \n\n`_Z4funcv //v 代表void，无参数`  \n`_Z4funci //i 代表参数为int整型`  \n`_Z4funcic //ic 代表第一个参数为int类型 第二个参数为char类型`\n\n\n-----------------------------\n\n\n# 五、C++和C混合编程 C库的\n1、集成开发环境下\n`func.c`\n```C++\ninclude<stdio.h>\nint my_add(int x,int y){\n    return x+y;\n}\nint my_sub(int x,int y){\n    return x-y;\n}\n```\n`func.h`\n```C++\n#ifndef __FUNC_H__\n#define __FUNC_H__\n\n#if __cplusplus\nextern \"C\"{\n#endif\n    extern int my_add(int x,int y);\n    extern int my_sub(int x,int y);\n#if __cplusplus\n}\n#endif\n\n#endif\n```\n\n`main.cpp`\n```C++\n#include <stdio.h>\n#include \"func.h\"\nusing namespace std;\nint main(){\n    cout<<my_add(10,20)<<endl;\n    cout<<my_sub(10,20)<<endl;\n    return 0;\n}\n```\n\n2、Ubuntu下\nmain.cpp func.c func.h  \n混合编译步骤：  \ngcc -c func.c -o func.o  \ng++ main.cpp fun.o -o main","tags":["随记"],"categories":["C++"]},{"title":"C++笔记梁哥day3","url":"/2020/09/26/C++梁哥笔记day3/","content":"# 引用(reference)\n\n引用是C++对C的重要扩充。在c/c++中指针的作用基本都是一样的，但是C++增加了另外一种给函数传递地址的途径，这就是按引用传递(pass-by-reference)，它也存在于其他一些编程语言中，并不是是C++的发明。  \n\n<!-- more -->\n\n变量名实质上是一段连续内存空间的别名，是一个标号(门牌号)，程序中通过变量来申请并命名内存空间，通过变量的名字可以使用存储空间\n\n对一段连续的内存空间只能取一个别名吗？c++中新增了引用的概念，引用可以作为一个已定义变量的别名。基本语法: Type& ref=val;  \n\n注意事项：&在此不是取地址运算，而是起标识作用。类型标识符是指目标变量的类型，必须在声明引用变量时进行初始化。引用初始化之后不能改变。不能有 NULL 引用。必须确保引用是和一块合法的存储单元关联。可以建立对数组的引用。\n## 一、引用的初始\n**语法：**\n1. &和别名结合，表示引用\n2. 给某个变量取别名，就定义某个变量\n3. 从上往下替换\n4. 赋值\n```C++\nint num = 10;\n//现在要给num定义一个引用a\n//第一步 &和a结合\n&a\n//第二步 给num取别名，定义num\nint num;\n//第三步 从上往下替换\nint &a;\n//第四步 赋值\nint &a = num;\n```\n> a完全等价于num，操作a就是操作num。\n\n注意：引用必须初始化，一旦初始化就不能再次修改。\n```C++\nint num = 10;\nint &a = num;\n\nint data = 20;\na = data;//这个语句不是将data的别名设置成a，而是将data的值赋给了a(num)\n```\n## 二、引用作用于数组\n### 1、方法一：直接替换法\n```C++\nint arr[5] = {1,2,3,4,5};\n//现在要给arr定义一个引用myArr\n//第一步 &和myArr结合\n&myArr\n//第二步 给num取别名，定义num\nint arr[5];\n//第三步 从上往下替换\nint (&myArr)[5];//要加() []的优先级比&高\n//第四步 赋值\nint (&myArr)[5] = arr;\n\nvoid test01(){\n    int arr[5] = {1,2,3,4,5};\n\tint (&myArr)[5] = arr;\n\tfor(int i = 0; i < 5; i++){\n    \tcout<<\"myArr[\"<<i<<\"]=\"<<myArr[i]<<\" \";\n\t}\n    \tcout<<endl;\n}\n```\n运行结果：\n![图片](./pic1.png)  \n\n### 2、方法二：配合typedef\n先用`typedef`给类型取个别名，在使用类型的别名定义变量，接着再给变量定义引用\n```C++\nvoid test02(){\n    int arr[5] = {1,2,3,4,5};\n    typedef int TYPE_ARR[5];\n    TYPE_ARR newArr={10,20,30,40,50};\n\tTYPE_ARR &myArr = newArr;\n\tfor(int i = 0; i < 5; i++){\n    \tcout<<\"myArr[\"<<i<<\"]=\"<<myArr[i]<<\" \";\n\t}\n    \tcout<<endl;\n}\n```\n运行结果：\n![图片](./pic2.png)  \n\n\n## 三、引用作为函数的参数\n\n```C++\n//交换失败\nvoid swap1(int m,int n){\n    cout<<\"m=\"<<m<<\",n=\"<<n<<endl;\n    int temp=m;\n    m=n;\n    n=temp;\n    cout<<\"m=\"<<m<<\",n=\"<<n<<endl;\n}\n//交换成功 但是比较麻烦\nvoid swap2(int *m,int *n){\n    cout<<\"m=\"<<*m<<\",n=\"<<*n<<endl;\n    int temp=*m;\n    *m=*n;\n    *n=temp;\n    cout<<\"m=\"<<*m<<\",n=\"<<*n<<endl;\n}\n//交换成功 操作简便\nvoid swap3(int &m,int &n){\n    cout<<\"m=\"<<m<<\",n=\"<<n<<endl;\n    int temp=m;\n    m=n;\n    n=temp;\n    cout<<\"m=\"<<m<<\",n=\"<<n<<endl;\n}\nvoid test03(){\n    int a=10,b=20;\n    cout<<\"a=\"<<a<<\",b=\"<<b<<endl<<endl;\n    swap1(a,b);\n    cout<<\"swap1(a,b)  a=\"<<a<<\",b=\"<<b<<endl;\n    swap2(&a,&b);\n    cout<<\"swap2(&a,&b)  a=\"<<a<<\",b=\"<<b<<endl;\n    swap3(a,b);\n    cout<<\"swap3(a,b)  a=\"<<a<<\",b=\"<<b<<endl;\n}\n```\n运行结果：\n![图片](./pic3.png)  \n\n## 四、引用作为函数的返回值\n1. 不要返回局部变量的引用\n```C++\nint& my_data1(){\n    int num = 20;\n    return num;\n}\nvoid test04(){\n    int &ret = my_data1();\n    cout<<\"ret=\"<<ret<<endl;//非法访问内存\n}\n```\n运行结果：\n![图片](./pic4.png)  \n如果返回局部变量的引用是很危险的，当函数执行完后，局部变量已经被释放，这个时候你去操作它就是操作非法空间。\n\n2. 可以返回静态局部变量的的引用，它的生命周期比较长\n```C++\nint& my_data2(){\n    static int num = 20;\n    return num;\n}\nvoid test05(){\n    int &ret = my_data2();\n    cout<<\"ret=\"<<ret<<endl;\n    ret = 200;\n    cout<<\"ret=\"<<ret<<endl;\n}\n```\n运行结果：\n![图片](./pic5.png)  \n\n3. 当函数返回值作为`左值`时，那么函数的返回值的类型必须是`引用`\n```C++\nint& my_data3(){\n    static int num = 50;//static定义的变量只会初始化一次\n    cout<<\"num = \"<<num<<endl;\n    return num;\n}\nvoid test06(){\n    //函数的返回值 作为左值\n    my_data3() = 2000;//调用函数，同时将2000赋给了函数的返回值\n    my_data3();\n}\n```\n运行结果：\n![图片](./pic6.png)  \n\n\n## 五、引用的本质是常量指针(了解)\n引用的本质在C++内部实现是一个指针常量. \n```C++\nType& ref = val;//Type* const ref = &val;\n```\nC++编译器在编译过程中使用常指针作为引用内部实现，因此引用所占用的空间大小与指针相同，只是这个过程是编译器内部实现，用户不可见。\n\n```C++\nint data = 10;\nint &a = data;//a就是data的别名\n//编译器内部转换： int * const a = &data; const修饰的是a，意思是a一旦保存了data的地址后就不能改变\na = 100;//等价于data=100;\n//编译器内部转换：*a = 100;//*a == data;\n```\n\n\n## 六、指针的引用\n```C++\nvoid func1(char **p){\n    *p = (char *)malloc(sizeof(char)*32);\n    strcpy(*p,\"hello world!\");\n}\nvoid func2(char *(&p)){\n    p = (char *)malloc(sizeof(char)*32);\n    strcpy(p,\"hello!\");\n}\nvoid test07(){\n    char *str = NULL;\n    //需求：定义一个函数 申请一段空间 给str 并将\"hello world!\"存进去\n    //采用二级指针 \n    func1(&str);\n    cout<<\"str = \"<<str<<endl;\n    //采用引用 \n    func2(str);\n    cout<<\"str = \"<<str<<endl;\n}\n```\n运行结果：\n![图片](./pic7.png)  \n\n## 七、常引用\n需求：定义一个函数需求遍历一个结构体\n1. 直接传入结构体\n```C++\nstruct STU{\n    int num;\n    char name[32];\n};\nvoid myPrintSTU1(STU stu){\n\tcout<<\"sizeof(stu)=\"<<sizeof(stu)<<endl;\n    cout<<\"num = \"<<stu.num<<\",name = \"<<stu.name<<endl;\n}\nvoid test08(){\n\tSTU stu = {100,\"lucy\"};\n\tmyPrintSTU1(stu); \n}\n```\n运行结果：\n![图片](./pic8.png)  \n\n函数`myPrintSTU1`的缺点是形参占用空间太多\n\n2. 传入结构体的地址\n```C++\nstruct STU{\n    int num;\n    char name[32];\n};\nstruct STU{\n    int num;\n    char name[32];\n};\nvoid myPrintSTU2(STU *stu){\n\tcout<<\"sizeof(stu)=\"<<sizeof(stu)<<endl;\n    cout<<\"num = \"<<stu->num<<\",name = \"<<stu.name<<endl;\n}\nvoid test09(){\n\tSTU stu = {200,\"bob\"};\n\tmyPrintSTU2(&stu); \n}\n```\n运行结果：\n![图片](./pic9.png)  \n\n函数`myPrintSTU2`的解决了形参占用空间太多，在32位环境中只占用四字节，但是缺点是传入的是指针，这个函数只是用来遍历，读取操作，但是可以修改结构体stu里面的内容，这样很危险\n\n3. 2的优化\n将形参加了const修饰\n```C++\nvoid myPrintSTU3(STU const *stu){\n\tcout<<\"sizeof(stu)=\"<<sizeof(stu)<<endl;\n\t//stu->num=2000;不能修改 会报错 \n    cout<<\"num = \"<<stu->num<<\",name = \"<<stu->name<<endl;\n}\nvoid test10(){\n\tSTU stu = {200,\"bob\"};\n\tmyPrintSTU3(&stu); \n}\n```\n\n4. 采用引用的方法\n```C++\nvoid myPrintSTU4(STU &stu){\n    cout<<\"num = \"<<stu.num<<\",name = \"<<stu.name<<endl;\n}\nvoid test11(){\n\tSTU stu = {300,\"Lily\"};\n\tmyPrintSTU4(stu); \n}\n```\n运行结果：\n![图片](./pic10.png)  \n\n函数`myPrintSTU4`的解决了形参占用空间太多，其不占用空间，这个函数只是用来遍历，读取操作，但是可以修改结构体stu里面的内容，这样很危险，所以就有了`常引用`\n\n5. 4的优化，使用常引用\n\n```C++\nvoid myPrintSTU5(STU const  &stu){\n    stu.num=4000;//不能修改 会报错\n    cout<<\"num = \"<<stu.num<<\",name = \"<<stu.name<<endl;\n}\nvoid test12(){\n    STU stu = {300,\"Lily\"};\n    myPrintSTU5(stu);\n}\n```\n运行结果：\n![图片](./pic11.png)  \n\n### 常量的引用\n给常量取一个别名（定义一个引用）\n1. 会报错10的类型是const int，类型不匹配，系统怕你后面把常量10改了 num=20;\n```C++\nvoid test13(){\n\tint &num = 10;\n\tcout<<\"num = \"<<num<<endl;\n}\n```\n运行结果：\n![图片](./pic12.png)  \n\n2. \n```C++\nvoid test14(){\n\tconst int &num = 10;\n\tcout<<\"num = \"<<num<<endl;\n}\n```\n运行结果：\n![图片](./pic13.png)  \n","tags":["随记"],"categories":["C++"]},{"title":"C++梁哥笔记day2","url":"/2020/09/25/C++梁哥笔记day2/","content":"\n## 一、语法的增强\n1. 以下代码在C语言中好使,在C++中会报错\n```C\n#include<stdio.h>\nint main(){\n    int a = 10;//有赋值--->定义\n    int a;//同名且没有赋值--->声明\n    printf(\"a=%d\\n\",a);\n    return 0;\n}\n```\n\n<!-- more -->\n\n\n2. C语言中，虽然有警告但还是可以编译运行，在C++中则不行。\n```C\n//i没有写类型可以传任意类型\nint fun1(i){\n    printf(\"%d\\n\",i);\n    return 0;\n}\n//i没有写类型可以传任意类型\nint fun2(i){\n    printf(\"%s\\n\",i);\n    return 0;\n}\n//没有写参数，代表可以传任何类型的实参\nint fun3(){\n    printf(\"fun3\\n\");\n    return 0;\n}\n```\n3. 更严格的类型转换  \n在C++中不同类型变量一般是不能直接赋值的，需要进行相应的强制类型转换。C语言中编译器可以编译通过。\n```C\nenum COLOR{GREEN, RED, YELLOW};\nint main(){\n    COLOR mycolor = GREEN;\n    mycolor = 10;//C++中编译出错\n    return 0;\n}\n```\n\n## 二、对结构体的增强\n1. C语言中定义结构体变量需要加上struct关键字，C++中不需要。\n```C++\nstruct stu{\n    int num;\n    char name[32];\n};\nint main(){\n    //C语言中必须加struct，不然会报错\n    struct stu bob= {100，\"bob\"};\n    //C++语言中，可不加struct\n    stu lucy = {200，\"lucy\"};\n    return 0;\n}\n```\n\n2. C语言中的结构体只能定义成员变量，不能定义成员函数。C++既可以定义成员变量，也可以定义成员函数。\n\n```C++\nstruct stu{\n    int num;\n    char name[32];\n    void func(){\n        cout<<\"我是结构体中的func\"<<endl;\n    }\n};\nint main(){\n    stu lucy = {100,\"lucy\"};\n    cout<<lucy.num<<endl;\n    //调用结构体中的成员函数（成员方法）\n    lucy.func();\n    return 0;\n}\n```\n运行结果：\n![图片](./pic1.png)  \n\n## 三、bool类型\n标准C++的`bool`类型有两种内建的常量`true`（转换为整数1）和`false`（转换为整数0）表示状态。  \n这三个名字都是关键字。\n`bool`类型占1字节大小，给`bool`类型赋值时，非0值会自动转换为`true`（1），0会自动转换为`false`（0）  \n案例1:\n```C++\nvoid test1(){\n    bool flag = true;\n    cout<<\"sizeof(bool)=\"<<sizeof(bool)<<endl;\n    cout<<\"true:\"<<true<<endl;\n    cout<<\"false:\"<<false<<endl;\n}\n```\n运行结果：\n![图片](./pic2.png)  \n\n> C语言中也有bool类型，在C99标准之前是没有bool关键字的，C99增加了bool类型，包含头文件，stdbool.h就可以使用C++一样的bool类型。\n\n## 四、三目运算符的增强\n1. C语言中三目运算符表达式返回值为数据值，为右值，不能赋值。  \n案例2:\n```C\nvoid test2(){\n    int a=10,b=20;\n    printf(\"%d\\n\",a>b?a:b);\n    //a>b?a:b=100;//错误 不能作为左值 相当于20=100\n}\n```\n2. C++中三目运算符表达式返回值为变量本身(引用)，为左值，可以赋值。  \n案例3:\n```C++\nvoid test3(){\n    int a=10,b=20,c=0;\n    c=a>b?a:b;\n    //cout<<a>b?a:b;<<endl;这样写会报错\n    cout<<c<<endl;\n    a>b?a:b=100;//正确 整体返回的是变量b 相当于b=100\n    cout<<\"b=\"<<b<<endl;\n}\n```\n运行结果：\n![图片](./pic3.png)  \n\n## 五、const详解\n### 1、const概述\n`const`单词字面意思是常数、不变的。它是c/c++中的一个关键字，是一个限定符，它用来限定一个变量不允许改变，它将一个对象转换成一个常量\n### 2、C语言中的const\n常量的引进是在c++早期版本中，当时标准c规范正在制定。那时，尽管c委员会决定在c中引入const，但是，他们c中的const理解为“一个不能改变的普通变量”，也就是认为const修饰的应该是一个只读变量，既然是变量那么就会给const分配内存，并且c中const是一个全局只读变量，c语言中const修饰的只读变量是外部连接的，也就是说其他文件也可以使用。  \n`const int arrSize = 10;`  \n`int arr[arrSize];`  \n看似是一件很合理的代码，但是是错误的，因为arrSize占用某块内存，所以c编译器不知道它在编译时的值是多少。\n1. 在C语言中\n```C\nconst int a = 10; //不要把a看成一个常量\n//a的本质是变量，只是它是一个只读的变量\n/*       !!!!!!重要!!!!!!!\n*只是不能通过变量名直接改变空间的内容\n*但是可以通过其地址来修改其空间内容\n*前提是要地址对应的空间区域可读可写\n*例如，定义在全局的const 变量在文字常量区\n*其空间区域都不可修改，即使知道其地址也不能修改\n*/\n```\n案例4:\n```C\nvoid test4(){\n    const int num=10;\n    int *p=(int *)&num;\n    printf(\"num=%d\\n\",num);\n    *p=200;\n    printf(\"num=%d\\n\",num);\n}\n```\n运行结果：\n![图片](./pic4.png)  \n\n**总结：**  \n1. const修饰全局变量data，变量名只读，对应的内存空间在文字常量区（只读），不能通过data的地址，修改空间内容。\n2. const修饰局部变量num,变量名只读，对应的内存空间在栈区（可读可写），可以通过data地址，间接地修改空间内容。\n3. const修饰的变量是外部连接，其他文件也可以使用。\n\n\n## 3、C++中的const深入理解\n(1)  在C++中，出现在所有函数之外的const作用于整个文件（也就是说对其他文件不可见），默认为内部连接。  \n如果要在其他文件使用只读的全局变量 必须在定义的时候加extern将变量转换成外部连接  \n(2)  在C++中，一个const不必创建内存空间，而在c中，一个const总是需要一块内存空间。在c++中，是否为const常量分配内存空间依赖于如何使用。一般说来，如果一个const仅仅用来把一个名字用一个值代替（就像使用#define一样），那么该储存区空间不必创建。如果储存空间没有分配内存的话，在进行完数据类型检查后，为了代码更加有效，值也许会折叠到代码中。不过，取一个const地址，或者把它定义为extern，则会为该const创建空间。  \n案例5:\n```C++\nvoid test5(){\n    const int num = 10;\n    //num = 100;//错误 num只读\n    cout<<\"num=\"<<num<<endl;\n    int *p = (int *)&num;\n    *p = 2000;\n    cout<<\"*p=\"<<*p<<endl;\n    cout<<\"num=\"<<num<<endl;\n}\n```\n运行结果：\n![图片](./pic5.png)  \n想想明明就改成2000了，*p=2000，为什么num尽然还是10呢？\n### 1、对于基础数据类型，也就是const int a = 10；这种，编译器会把它放到符号表中，不分配内存，当对其取地址时才会分配内存。\n\n这样的话，上面的案例5的现象就很好解释了，当我们对其取地址时，系统给它分配了空间，这个空间的原始内容是10，然后我们将其改为2000，但是符号表中，num对应的值还是10，所以当我们输出num的值时，num的值是从符号表里面取的，所以输出的num仍然是10，但是系统为num分配的空间*p的值是2000。\n\n运行结果：\n![图片](./pic6.png)  \n\n\n### 2、对于基础数据类型，如果用一个变量初始化const变量，例如const int a = b;那么也是会给a分配内存，而且是直接开辟空间，不会把a放到符号表中。\n案例6：\n```C++\nvoid test6(){\n    int t=10;\n    const int num = t;\n    cout<<\"num=\"<<num<<endl;\n    int *p = (int *)&num;\n    *p = 2000;\n    cout<<\"*p=\"<<*p<<endl;\n    cout<<\"num=\"<<num<<endl;\n}\n```\n运行结果：\n![图片](./pic7.png)  \n\n\n### 3、对于自定数据类型，比如类对象，那么也会分配空间，且不会放到符号表中\n\n案例7：\n```C++\nstruct person{\n    char name[32];\n    int age;\n};\nvoid test7(){\n    const person lucy={\"lucy\",18};\n    person *p=(person *)&lucy;\n    cout<<\"name=\"<<lucy.name<<\",age=\"<<lucy.age<<endl;\n    strcpy(p->name,\"bob\");\n    p->age=20;\n    cout<<\"name=\"<<p->name<<\",age=\"<<p->age<<endl;\n    cout<<\"name=\"<<lucy.name<<\",age=\"<<lucy.age<<endl;\n}\n```\n运行结果：\n![图片](./pic8.png)  \n\n## 六、尽量以 const 替换#define\n\n在旧版本 C 中，如果想建立一个常量，必须使用预处理器\"#define MAX 1024;我们定义的宏: MAX 从未被编译器看到过，因为在预处理阶段，所有的 MAX 已经被替换为了 1024，于是 MAX 并没有将其加入到符号表中。当我们使用这个常量获得一个编译错误信息时，可能会带来一些困惑，因为这个信息可能会提到 1024,但是并没有提到 MAX.如果 MAX 被定义在一个不是你写的头文件中，你可能并不知道 1024 代表什么，也许解决这个问题要花费很长时间。解决办法就是用一个常量替换上面的宏。\n\nconst int max= 1024;\n\nconst 和 #define 区别总结:\n1. const 有类型，可进行编译器类型安全检查。#define 无类型，不可进行类型检查.\n2. const 有作用域，而#define 不重视作用域，默认定义处到文件结尾,如果定义在指定作用域下有效的常量，那么#define 就不能用。  \n\n案例8：宏没有类型，const有\n1. 宏常量没有类型，所以调用了 int 类型重载的函数。const 有类型，所以调用希望的 short 类型函数？\n```C++\n#define PARAM 128\nconst short param = 128;\nvoid func(short a){\n    cout << \"short!\"<< endl;\n}\nvoid func(int a){\n    cout <<\"int\"<< endl;\n}\nvoid test8(){\n    func(PARAM);\n    func(param);\n}\n```\n运行结果：\n![图片](./pic9.png)  \n\n案例9：宏作用域是当前整个文件，const作用域以定义情况决定\n2. 宏不重视作用域\n```C++\nvoid my_func(){\n    //作用范围 当前的{}内\n    const int num = 10;\n\n    //作用范围 从当前位置到文件结束\n    #define MY_NUM 10\n}\nvoid test9(){\n    //cout<<\"my_num=\"<<my_num<<endl;//报错，my_num未定义\n    cout<<\"MY_NUM=\"<<MY_NUM<<endl;//正确编译\n}\n```\n运行结果：\n![图片](./pic10.png)  \n\n问题：宏常量可以有命名空间吗？  \n没有。\n案例10：\n3. 宏不能作为命名空间内的成员\n```C++\nnamespace MySpace{\n    #define NUM 1024//属于文件 不属于MySpace\n}\nvoid test10(){\n    //cout<<MySpace::NUM<<endl;//错误\n    //int NUM = 100;//命名冲突\n    cout<< NUM << endl;\n}\n```\n\n\n**总结：**\n1. 在C++中，const定义的变量默认是内部连接，要把它变成外部连接要在定义的时候加extern，在其他文件使用的时候声明就行了。\n2. const int data = 10;//data先放入符号表  \n如果对data取地址，系统才会给data开辟空间\n3. const int a = b;//b是变量名 系统直接给a开辟空间，而不放入符号表\n4. const修饰自定义数据时，系统为自定义数据开辟空间，不放入符号表。\n5. 尽量以 const 替换#define\n\n","tags":["随记"],"categories":["C++"]},{"title":"C++梁哥笔记day1","url":"/2020/09/24/C++梁哥笔记day1/","content":"\n\n## C++对C的拓展\n\n### ::作用域运算符\n通常情况下，如果有两个同名变量，一个是全局变量，一个是局部变量，那么局部变量在其作用域内具有较高的优先权，它将屏蔽全局变量。\n\n<!-- more -->\n\n```C++\nint a = 10;\nvoid test1(){\n    //局部变量\n    int a = 20;\n    //打印出的是局部变量\n    cout<< \"a:\" << a << endl;\n}\n```\n运行结果：\n![图片](./pic1.png)    \n`::`作用域运算符可以解决上面局部变量与全局变量重名的问题\n\n```C++\nint a = 10;\nvoid test2(){\n    //局部变量\n    int a = 20;\n    //打印局部变量\n    cout<< \"a:\" << a << endl;\n    //打印全局变量\n    cout<< \"a:\" << ::a << endl;\n}\n```\n运行结果：\n![图片](./pic2.png)   \n\n### C++命名空间（namespace）\n#### 命名空间的定义和使用\n1. 创建一个命名空间\n```C++\n//定义一个名字为A的命名空间（里面可以是变量、函数）\nnamespace A{\n  \n}\nnamespace B{\n  \n}\n```\n> 注意：只能在全局范围内定义，不能再局部范围内定义\n2. 使用命名空间的内容\n```C++\nnamespace A{\n  int a = 10;\n}\nnamespace B{\n  int a = 20;\n}\nvoid test3(){\n    //报错  a未定义\n    //cout << \"a:\" << a << endl;\n    //使用A空间中的a\n    cout << \"a:\" << A::a << endl;\n    //使用B空间中的a\n    cout << \"a:\" << B::a << endl;\n\n}\n```\n运行结果：\n![图片](./pic3.png)   \n\n#### 命名空间的特点详解\n1. 命名空间只能在全局范围内定义  \n错误写法\n```C++\nvoid test4(){\n    namespace A{\n        int a = 10;\n    }\n    namespace B{\n        int a = 20;\n    }\n}\n```\n结果：\n![图片](./pic4.png)   \n\n2. 命名空间可以嵌套\n```C++\nnamespace A{\n    int a = 1000;\n    namespace B{\n        int a=2000;\n    }\n}\nvoid test5(){\n    cout<<\"A中的a:\"<<A::a<<endl;\n    cout<<\"B中的a:\"<<A::B::a<<endl;\n}\n```\n运行结果：\n![图片](./pic5.png)   \n\n3. 命名空间是开放的，可以随时把新的成员加入已有的命名空间中（常用）\n```C++\nnamespace A{\n    int a = 100;\n}\n//中间写了很多代码\nnamespace A{\n    int b = 200;\n}\nvoid test6(){\n    cout<<\"A中的a:\"<<A::a<<endl;\n    cout<<\"A中的b:\"<<A::b<<endl;\n}\n```\n运行结果：\n![图片](./pic6.png)   \n\n4. 命名空间可以存放变量和**函数**\n```C++\nnamespace A{\n    int a=10;//变量\n    void func(){//函数\n    // cout<<\"A中的a:\"<<A::a<<endl;\n    cout<<\"A中的a:\"<<a<<endl;\n    /*\n    这个时候的a可以不加作用域A::\n    函数和a都在命名空间内，\n    加这个有点好像一家人不是一家人一样的\n    */\n    }\n}\nvoid test7(){\n    A::func();\n}\n```\n运行结果：\n![图片](./pic7.png)   \n\n\n5. 命名空间中的函数，可以在命名空间外面定义  \n内部声明  \n外面定义\n```C++\nnamespace A{\n    int a=100;\n    void func();\n}\nvoid A::func(){//成员函数 在外部定义时，记得要加作用域\n    //cout << \"a:\" << A::a << endl;\n    //访问命名空间的数据可以不用加作用域\n    cout << \"a:\" << a << endl;\n}\nvoid test8(){\n    A::func();\n}\n```\n运行结果：\n![图片](./pic8.png)   \n\n\n#### 无名命名空间\n意味着命名空间中的标识符只能在本文件内访问，相当于给这个标识符加上了`static`，使得其可以作为内部连接  \n\n```C++\nnamespace{\n    int a = 100;\n    void func(){\n        cout << \"hello namespace\" << endl;\n    }\n}\ntest9(){\n    cout << \"a:\" << a << endl;\n    func();\n}\n```\n运行结果：\n![图片](./pic9.png)  \n\n#### 命名空间的别名\n```C++\nnamespace veryLongName{\n    int a = 100;\n    void func(){\n        cout << \"hello namespace\" << endl;\n    }\n}\nvoid test10(){\n    //取别名\n    namespace shortName = veryLongName;\n    cout<<\"veryLongNmae::a\"<<shortName::a<<endl;\n    veryLongName::func();\n    shortName::func();\n}\n```\n运行结果：\n![图片](./pic10.png)  \n\n\n#### using 声明\n```C++\nnamespace veryLongName{\n    int a = 200;\n    void func(){\n        cout << \"a：\" << a << endl;\n    }\n}\n\nvoid test11(){\n    //使用命名空间\n    using namespace veryLongName;\n\n    //出现的变量 先从veryLongName命名空间中找 找不到再从其他地方去找\n    cout<<\"a：\"<<a<<endl;\n    func();\n}\n```\n运行结果：\n![图片](./pic11.png)  \n\n\n* 优点：简化了代码\n* 缺点：容易冲突，当名字重名的可能会出现问题\n\n* using 指明使用具体的命名空间成员（了解）\n```C++\nnamespace veryLongName{\n    int a = 200;\n    void func(){\n        cout << \"a：\" << a << endl;\n    }\n}\nvoid test12(){\n    //使用指定命名空间\n    using veryLongName::a;\n\n    //指定了a 可以使用命名空间中的a\n    cout<<\"a：\"<<a<<endl;\n\n    //没有指定func() 会报错\n    //func();\n    veryLongName::func();\n}\n```\n运行结果：\n![图片](./pic12.png)  \n\n\n\n> 注意：不同命名空间中的同名成员使用的时候注意二义性。\n\n#### using声明碰到函数重载\n* 函数重载\n```C++\nvoid func(){\n    cout<<\"无参函数\"<<endl;\n}\nvoid func(int a){\n    cout<<\"一个参数\"<<endl;\n}\nvoid func(int a,int b){\n    cout<<\"两个参数\"<<endl;\n}\ntest13(){\n    func();//你不传参数 调用的是第一个函数\n    func(1);//传一个参数 调用的是第二个函数\n    func(1,1);//传两个参数 调用的是第三个函数\n}\n```\n运行结果：\n![图片](./pic13.png)  \n\n函数重载，c++中函数名+参数组合代表的是函数的入口地址，它在内部做了重新载入，类似func()变成func_void(),func(int a)变成func_int,func(int a,int b)变成func_int_int。在C语言中这样写是会报错的，C语言中函数名就是函数的入口地址。\n\n\n* 当函数重载放在命名空间里面时\n```C++\nnamespace A{\n    void func(){\n    cout<<\"无参函数\"<<endl;\n}\nvoid func(int a){\n    cout<<\"一个参数\"<<endl;\n}\nvoid func(int a,int b){\n    cout<<\"两个参数\"<<endl;\n}\n}\nvoid test14(){\n    //using指明使用A中的func 会对所有的func起作用\n    using A::func;\n    func();\n    func(1);\n    func(1,1);\n}\n```\n运行结果：\n![图片](./pic14.png)  \n\n\n#### std详解\n`using namespace std;`  \ncout cin end 都是std中的成员\n\n```C++\n#include<iostream>\nusing namespace std;\nint main(){\n    std::cout<<\"hello\"<<std::endl;\n    cout<<\"hello\"<<endl;\n    reutrn 0;\n}\n```\n运行结果：\n![图片](./pic15.png)  \n\n\n#### 总结：\n1、 命名空间的定义（不能在函数内定义命名空间）  \n2、使用命名空间的成员，最安全的方式是 `命名空间名::成员名`  \n3、`using namespace 命名空间名` 使用整个命名空间  （重要）  \n4、单独使用命名空间中的具体成员：`using 命名空间名::成员名`\n","tags":["随记"],"categories":["C++"]},{"title":"排序算法","url":"/2020/09/23/排序算法/","content":"\n\n## 排序算法\n\n### 一、直接插入排序\n\n<!-- more -->\n\n```C++\n//进行从小到大排序\nvoid insertSmallToLarge(int *arr,int m,int temp){\n\tint i = 0;\n\tfor(i=m-1;i>=0;i--){\n\t\tif(temp < *(arr+i)){\n\t\t\t*(arr+i+1) = *(arr+i);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\t*(arr+i+1)=temp;\n}\n//从大到小进行排序\nvoid insertLargeToSmall(int *arr,int m,int temp){\n\tint i = 0;\n\tfor(i=m-1;i>=0;i--){\n\t\tif(temp > *(arr+i)){\n\t\t\t*(arr+i+1) = *(arr+i);\n\t\t}else{\n\t\t\tbreak;\n\t\t}\n\t}\n\t*(arr+i+1)=temp;\n}\n//配合上面的两个函数使用\nvoid insertSort(int *arr,int n){\n\t\n\tfor(int i = 1; i < n; i++){\n\t\tinsertSmallToLarge(arr,i,*(arr+i)); \n\t\tinsertLargeToSmall(arr,i,*(arr+i));\n\t}\n\t\n} \n```\n\n直接插入法程序：\n```C++\n#include <iostream>\n#include<ctime>\n#include<cstdlib>\nusing namespace std;\nvoid insertSmallToLarge(int* arr, int m, int temp);\nvoid insertLargeToSmall(int* arr, int m, int temp);\nvoid insertSort(int* arr, int n);\nvoid output(int* arr, int n);\nvoid inputRandCount(int *arr, int n);\nvoid dynamicApplication(int*& arr, int &n);\nint main()\n{\n    int n = 0,*arr=NULL;\n    //动态申请内存\n    dynamicApplication(arr, n);\n    //输入随机数\n    inputRandCount(arr, n);\n    //输出原先的数组\n    cout << \"原先的数组为：\" << endl;\n    output(arr, n);\n    //进行插入排序\n    insertSort(arr, n);\n    //输出排序好的数组\n    cout << \"排序后的数组为：\"<<endl;\n    output(arr, n);\n    //释放内存\n    free(arr);\n}\n//将temp插入有序数组a[1..n-1]中，数组a仍然有序\nvoid Insert(int* a, int n, int temp)\n{\n    int i = 0;\n    for (i = n - 1; i >= 0; i--) //查找插入位置\n    {\n        if (temp < a[i])  //  后移\n            a[i + 1] = a[i];\n        else\n            break;\n    }\n   a[i + 1] = temp;  //  插入数据到正确位置\n}\n\n\n//进行从小到大排序\nvoid insertSmallToLarge(int* arr, int m, int temp) {\n    int i = 0;\n    for (i = m - 1; i >= 0; i--) {\n        if (temp < *(arr + i)) {\n            *(arr + i + 1) = *(arr + i);\n        }\n        else {\n            break;\n        }\n    }\n    *(arr + i + 1) = temp;\n}\n//从大到小进行排序\nvoid insertLargeToSmall(int* arr, int m, int temp) {\n    int i = 0;\n    for (i = m - 1; i >= 0; i--) {\n        if (temp > * (arr + i)) {\n            *(arr + i + 1) = *(arr + i);\n        }\n        else {\n            break;\n        }\n    }\n    *(arr + i + 1) = temp;\n}\n//配合上面的两个函数使用 对数组arr作直接插入排序\nvoid insertSort(int* arr, int n) {\n\n    for (int i = 1; i < n; i++) {\n        insertSmallToLarge(arr, i, *(arr + i));\n        //insertLargeToSmall(arr, i, *(arr + i));\n    }\n\n}\n//输出数组arr的元素\nvoid output(int* arr,int n) {\n    for (int i = 0; i < n; i++) {\n        cout << *(arr + i) << \" \";\n    }\n    cout << endl;\n}\n//生成随机数\nvoid inputRandCount(int *arr, int n) {\n\n    srand((unsigned)time(NULL));\n    for (int i = 0; i < n; i++)\n    {\n        *(arr + i) = rand() % 1000;\n    }\n}\n//动态申请内存空间\nvoid dynamicApplication(int*& arr, int &n) {\n    cout << \"请输入数组的元素个数n：\" << endl;\n    cin >> n;\n    //动态申请内存空间\n    arr = (int*)malloc(sizeof(int) * n);\n    //判断内存是否申请成功\n    if (NULL == arr) {\n        perror(\"malloc\");\n        exit(0);\n    }\n}\n```\n\n### 二、起泡排序\n```C++\n//比较数组相邻的两个元素进行交换 使最后一个元素值最大 \nvoid compToMax(int *arr,int n){\n\tfor(int i=0;i<n-1;i++){\n\t\tif(arr[i]>arr[i+1]){\n\t\t\tswap(arr[i],arr[i+1]);\n\t\t}\n\t}\n}\n//比较数组相邻的两个元素进行交换 使最后一个元素值最小 \nvoid compToMin(int *arr,int n){\n\tfor(int i = 0; i < n-1; i++){\n\t\tif(arr[i]<arr[i+1]){\n\t\t\tswap(arr[i],arr[i+1]);\n\t\t}\n\t} \n}\n//进行起泡排序\nvoid bubbleSort(int *arr,int length){\n\tfor(int i = length; i>1;i--){\n\t\tcompToMax(arr,i);\n\t} \n}\n//交换a b的值\nvoid swap(int &a,int &b){\n\tint temp=0;\n\ttemp = a;\n\ta = b;\n\tb = temp;\n}\n```\n\n起泡排序法程序：\n```C++\n#include <iostream>\n#include<ctime>\n#include<cstdlib>\nusing namespace std;\nvoid compToMax(int* arr, int n);\nvoid compToMin(int* arr, int n);\nvoid bubbleSort(int* arr, int length);\nvoid swap(int& a, int& b);\nvoid output(int* arr, int n);\nvoid inputRandCount(int *arr, int n);\nvoid dynamicApplication(int*& arr, int &n);\nint main(int argc,char *argv[])\n{\n    int n = 0,*arr=NULL;\n    //动态申请内存\n    dynamicApplication(arr, n);\n    //输入随机数\n    inputRandCount(arr, n);\n    //输出原先的数组\n    cout << \"原先的数组为：\" << endl;\n    output(arr, n);\n    //进行插入排序\n    bubbleSort(arr, n);\n    //输出排序好的数组\n    cout << \"排序后的数组为：\"<<endl;\n    output(arr, n);\n    //释放内存\n    free(arr);\n}\n\n//比较数组相邻的两个元素进行交换 使最后一个元素值最大 \nvoid compToMax(int* arr, int n) {\n    for (int i = 0; i < n - 1; i++) {\n        if (arr[i] > arr[i + 1]) {\n            swap(arr[i], arr[i + 1]);\n        }\n    }\n}\n//比较数组相邻的两个元素进行交换 使最后一个元素值最小 \nvoid compToMin(int* arr, int n) {\n    for (int i = 0; i < n - 1; i++) {\n        if (arr[i] < arr[i + 1]) {\n            swap(arr[i], arr[i + 1]);\n        }\n    }\n}\n//进行起泡排序\nvoid bubbleSort(int* arr, int length) {\n    for (int i = length; i > 1; i--) {\n        compToMax(arr, i);\n        //compToMin(arr, i);\n    }\n}\n//交换a b的值\nvoid swap(int& a, int& b) {\n    int temp = 0;\n    temp = a;\n    a = b;\n    b = temp;\n}\n//输出数组arr的元素\nvoid output(int* arr,int n) {\n    for (int i = 0; i < n; i++) {\n        cout << *(arr + i) << \" \";\n    }\n    cout << endl;\n}\n//生成随机数\nvoid inputRandCount(int *arr, int n) {\n\n    srand((unsigned)time(NULL));\n    for (int i = 0; i < n; i++)\n    {\n        *(arr + i) = rand() % 1000;\n    }\n}\n//动态申请内存空间\nvoid dynamicApplication(int*& arr, int &n) {\n    cout << \"请输入数组的元素个数n：\" << endl;\n    cin >> n;\n    //动态申请内存空间\n    arr = (int*)malloc(sizeof(int) * n);\n    //判断内存是否申请成功\n    if (NULL == arr) {\n        perror(\"malloc\");\n        exit(0);\n    }\n}\n```\n\n### 三、直接选择排序\n\n```C\n//找到比arr[m]更小的数 并返回其下标 \nint selectMinKey(int* arr, int m, int length) {\n    int min = m;\n    for (int i = m + 1; i < length; i++) {\n        if (arr[i] < arr[min]) {\n            min = i;\n        }\n    }\n    return min;\n}\n//找到比arr[m]更大的数 并返回其下标 \nint selectMaxKey(int* arr, int m, int length) {\n    int max = m;\n    for (int i = m + 1; i < length; i++) {\n        if (arr[i] > arr[max]) {\n            max = i;\n        }\n    }\n    return max;\n}\n//进行直接选择排序  从小到大排序 \nvoid selectSortToMin(int* arr, int length) {\n    int min = 0;\n    for (int i = 0; i < length; i++) {\n        min = selectMinKey(arr, i, length);\n        swap(arr[i], arr[min]);\n    }\n}\n//进行直接选择排序  从大到小排序 \nvoid selectSortToMax(int* arr, int length) {\n    int max = 0;\n    for (int i = 0; i < length; i++) {\n        max = selectMaxKey(arr, i, length);\n        swap(arr[i], arr[max]);\n    }\n}\n//交换a b的值\nvoid swap(int& a, int& b) {\n    int temp = 0;\n    temp = a;\n    a = b;\n    b = temp;\n}\n\n```\n\n直接选择排序程序\n```C++\n#include <iostream>\n#include<ctime>\n#include<cstdlib>\nusing namespace std;\nint selectMinKey(int* arr, int m, int length);\nvoid selectSortToMin(int* arr, int length);\nvoid selectSortToMax(int* arr, int length);\nvoid swap(int& a, int& b);\nvoid output(int* arr, int n);\nvoid inputRandCount(int *arr, int n);\nvoid dynamicApplication(int*& arr, int &n);\nint main(int argc,char *argv[])\n{\n    int n = 0,*arr=NULL;\n    //动态申请内存\n    dynamicApplication(arr, n);\n    //输入随机数\n    inputRandCount(arr, n);\n    //输出原先的数组\n    cout << \"原先的数组为：\" << endl;\n    output(arr, n);\n    //进行选择排序 从小到大\n    selectSortToMin(arr, n);\n    //输出排序好的数组\n    cout << \"排序后的数组为：\"<<endl;\n    output(arr, n);\n    //释放内存\n    free(arr);\n}\n//找到比arr[m]更小的数 并返回其下标 \nint selectMinKey(int* arr, int m, int length) {\n    int min = m;\n    for (int i = m + 1; i < length; i++) {\n        if (arr[i] < arr[min]) {\n            min = i;\n        }\n    }\n    return min;\n}\n//找到比arr[m]更大的数 并返回其下标 \nint selectMaxKey(int* arr, int m, int length) {\n    int max = m;\n    for (int i = m + 1; i < length; i++) {\n        if (arr[i] > arr[max]) {\n            max = i;\n        }\n    }\n    return max;\n}\n//进行直接选择排序  从小到大排序 \nvoid selectSortToMin(int* arr, int length) {\n    int min = 0;\n    for (int i = 0; i < length; i++) {\n        min = selectMinKey(arr, i, length);\n        swap(arr[i], arr[min]);\n    }\n}\n//进行直接选择排序  从大到小排序 \nvoid selectSortToMax(int* arr, int length) {\n    int max = 0;\n    for (int i = 0; i < length; i++) {\n        max = selectMaxKey(arr, i, length);\n        swap(arr[i], arr[max]);\n    }\n}\n//交换a b的值\nvoid swap(int& a, int& b) {\n    int temp = 0;\n    temp = a;\n    a = b;\n    b = temp;\n}\n//输出数组arr的元素\nvoid output(int* arr,int n) {\n    for (int i = 0; i < n; i++) {\n        cout << *(arr + i) << \" \";\n    }\n    cout << endl;\n}\n//生成随机数\nvoid inputRandCount(int *arr, int n) {\n\n    srand((unsigned)time(NULL));\n    for (int i = 0; i < n; i++)\n    {\n        *(arr + i) = rand() % 1000;\n    }\n}\n//动态申请内存空间\nvoid dynamicApplication(int*& arr, int &n) {\n    cout << \"请输入数组的元素个数n：\" << endl;\n    cin >> n;\n    //动态申请内存空间\n    arr = (int*)malloc(sizeof(int) * n);\n    //判断内存是否申请成功\n    if (NULL == arr) {\n        perror(\"malloc\");\n        exit(0);\n    }\n}\n```\n","tags":["算法"],"categories":["C语言"]},{"title":"C课堂笔记day6","url":"/2020/09/19/C课堂笔记day6/","content":"\n## 文字常量\n\n### bool型文字常量\n\n<!-- more -->\n\n* 单词`ture`和`false`是`bool型`的文字常量  \nbool类型是C++提供的 C语言中并没有这个类型，bool类型也是整型，false是0，ture一般是1\n\n```C++\n'ABCD'这样书写是否错误  是正确的 cpu一次执行吞吐量是4字节\n```\n> 当数据的大小大于1字节时，它在内存中是以字节倒叙存储（主机字节序）\n\n### 转义字符\n* 一部分不可打印的字符、单引号、双引号以及反斜杠要使用转义字符(转义序列以反斜杠开头)\n\n原因：单引号、双引号会跟最近的进行匹配\n\\'单引号  \n\\\"双引号  \n\\n换行  \n\\r回车键  \n\\\\反斜杠   当字符串为文件路径时  可偷懒，使用/符号即可  \n\n\n逻辑路径\n虚拟路径\n\n* 一般的转义序列采用如下格式\n\\000\n这里的ooo代表三个八进制数字组成的序列\n\n字符'0'与'\\0'的区别\n\n* 另外，字符文字前面可以加\"L\"例如L'a'\n这称为宽字节文字，类型为wchar_t。宽字符常量用来支持某些语言的字符集合，如汉语、日语  这些语言中的某些字符不能用单个字符来表示  \n实际上C语言是没有wchar_t，其实他是unsigned short,wchar_t时我们给他取的别名  \n```C\n使用 typedef unsigned short wchar_t 或 #define wchar_t unsigned short\n```\n说白了 宽字节实际上是增大了字符表的内容\n\n### 字符串文字常量\n\n* 字符串文字常量有另个或多个用双引号括起来的字符组成。不可打印的字符可以用相应的字符串序列来表示，而一串字符串文字可以拓展到多行 在一行最后加上一个反斜杠表示字符串在下一行继续\n\n目的：当代码一行过长的  为了防止内容被屏幕限制 是程序员一眼能看到所有的内容\n\n* 字符串文字的类型是常量字符数组。他由字符串文字本身以及编译器加上表示结束的空`'\\0'`字符构成\n> `'\\0'`是字符串的结尾标志 系统遇到`'\\0'`便结束输出字符串\n\n* 宽字节字符串 在字符串前面加上L，此时每个字符都占2字节\n\n> 字符串使用的时候 使用的是字符串首字符的地址 双引号`\"\"`实际上就是取字符串的地址\n\n* 他也有一个等价宽空字符作为结束标志\n\n> 两种字符串不能混用，单字节字符串和双字节字符串不能混用!!!\n\n\ncpu的吞吐量是四字节\ntypedef只能C++用？\nMSDN文档\n\n板书\n![图片](./lesson3-1.png)\n","tags":["随记"],"categories":["跟着丁哥学语言"]},{"title":"C课堂笔记day5","url":"/2020/09/11/C课堂笔记day5/","content":"\n## 变量\n\n* 假设有这样一个问题 计算2的10次方，我们首先想到的可能是：\n\n<!-- more -->\n\n```C++\n#include<iostream>\nint main(){\n    cout<<2*2*2*2*2*2*2*2*2*2;\n    cout<<endl;\n    return 0;\n}\n```\n我们称之为蛮力法。我们程序猿最怕的就是需求变更，我们这样写就给自己埋下了一个隐患，当需求不是要计算2的10次方的时候，就需要重新改动，需要消耗大量的时间。  \n虽然这种蛮力型的方案也能解决问题，但是他总让人感到不愉快，而且有些危机感。  \n复杂的技术方案一般在开始的阶段需要很多时间，这时常会感觉什么都没有做。而且处理过程是自动的，所以就更有可能出错。  \n事情不可避免会出错。但好处在于，这些错误过程中，不但事情很快就能完成，而且拓展了想象空间，有时候，这个过程也挺有趣的。  \n\n> 一个标准的程序员的思维超与常人。\n\n* 在本例中，用来取代这种蛮力法的方案包括两部分内容：使用有名字的对象来读写每部的计算：引入一个控制流的结构，一遍在某个条件为真时，可以重复执行一系列的语句。下面是一种“技术先进的”计算2的10次幂的程序：\n```C++\n#include<iostream>\nint main(){\n    //int类型对象\n    int value = 2;\n    int pow = 10;\n    cout<<value<<\"raised to the power of\"<<pow<<\":\\t\";\n    int res = 1;//保存结果\n    //循环控制语句：反复计算res\n    //直至cnt大于pow\n    for(int cnt=1;cnt<=pow;cnt++){\n        res = res * value;\n    }\n    cout<<res<<endl;\n    return 0;\n}\n```\n\n**重用**  \n重用是程序员每个人心里最喜欢的\n\n* 虽然这种层次的通用化能是程序更加灵活，但是这样的程序仍然是不可重用的。我们必须进一步通用化：把计算指数值的部分给抽离出来，定义成一个独立的函数，意识其他函数能够调用它。例如：\n```C++\n\n\n```\n\n* 我们也可以用如下的代码来生成2的幂的表：\n```C++\n#include<iostream>\nint main(){\n    int val =2;\n    int exp = 15;\n    cout<<\"The Powers of 2\\n\";\n    for(int cnt=0;cnt<exp;cnt++){\n        cout<<cnt<<\":\"<<pow(val,cnt)<<endl;\n    }\n    return 0;\n}\n```\n\n## 什么是变量？\n* 变量为我们提供了一个有名字的内存存储区，可以通过程序对其进行读写和处理。\n* C++中的每个符号变量都与一个特定的数据类型相关联，这个类型决定了相关内存的大小、布局、能否存储在改内存取的值得范围以及可以应用其上的操作集，我们也可以把变量说成对象(object)\n\n* 变量和文字常量都有存储区，并且有相关的的类型。区别在于变量是可寻址的。\n\n* 对于每一个变量都有两个值与其相关联：\n1. 它的数据值，存储在某个内存地址中。有时候这个值也被称为对象的右值。我们也可认为右值的意思是被读取的值。文字常量和变量都可别用作右值。\n2. 它的地址值，存储数据值的那块内存的地址。它有事被称为变量的左值。我们也可认为左值的意思是位置值。文字常量不能被用作左值，\n\n\n定义-----1----内存的分配----2----名字与分配的空间关联\n\n基址*10+偏移量\n\n### 板书\n![图片](./lesson5-1.png)  \n","tags":["随记"],"categories":["跟着丁哥学语言"]},{"title":"C课堂笔记day4","url":"/2020/09/10/C课堂笔记day4/","content":"## 符号常量\n\n* ```#include```  \n预处理指令  告诉编译器在编译时刻处理的指令，不是运行时刻处理的，跟运行时刻毫无关系\n\n<!-- more -->\n\n* 符号常量   \n可以把它称作一种批处理 在编译时刻改过来的\n![图片](./pic1.png)\n\n* 预处理指令```#define```  \n功能是很强大的\n\n* 我们把代码中的文字常量称为`\"魔\"数`比如1、2、3.14. 你写的代码别人，特别是测试员肯定是要看到的，就单单写一个文字常量，让人不容易看懂，这个文字常量的作用是什么，是干什么的。 这个就是我们要用符号常量的原因之一 \n双向链表大概三百行 要在二十分钟左右写出来\n\n* #define的使用  \n![图片](./pic2.png)\n> 注意：我们使用的名称一般都使用大写，为了与其他变量区分\n\n* #define的实际工作流程\n```C++\n#defien PI 3.14\ncout<<PI<<endl;\n```\n编译器也是一个程序，当编译时，他从代码开始往后读，当读到`#defien PI 3.14`时，编译器给PI做个记录，记录他的值为3.14,当再读到代码`cout<<PI<<endl;`时，将PI替换成它所对应的记录值3.14，这些操作都是在编译时刻时完成的。\n\n\n* define后面第一个是名称后面再出现的都是要替代的事物\n```C++\n#define PI 3.14 <<endl;\nint main(int argc,char* argv[]){\n    cout<<PI\n    //将会替换为cout<<3.14 <<endl;\n    return 0;\n}\n```\n\n## 关于vc6.0的一些使用方式\n\n* debug与release  \n1. debug产生的EXE文件比release大很多，里面包含了一些测试数据\n2. debug可以进行断点跟踪，而release是不支持的\n\n* workspase\n1. Classview\n显示所有的函数 寻找特定的函数\n2. Fileview\n显示文件 在新增文件时在这里\n\n* 代码区\n我们尽量让他显示50行左右\n> 一个函数 我们最好写50行左右，当超过时，再增加一个函数\n\n* 输出窗口\n1. build 编译输出\n\n* 报错时，记住，从第一个错误开始解决，因为可能第一个错误会导致后面的一系列报错\n\n* MSDN 把光标放在报错按F1  MSDN会告诉你错误产生的可能原因以及解决的方法\n\n\n* 调试的 `memory` 内存窗口  `watch`监视窗口\n\n板书\n![图片](./lesson4-1.png)","tags":["随记"],"categories":["跟着丁哥学语言"]},{"title":"C课堂笔记day3","url":"/2020/09/09/C课堂笔记day3/","content":"\n## 文字常量\n\n### bool型文字常量\n\n* 单词`ture`和`false`是`bool型`的文字常量  \nbool类型是C++提供的 C语言中并没有这个类型，bool类型也是整型，false是0，ture一般是1\n\n<!-- more -->\n\n```C++\n'ABCD'这样书写是否错误  是正确的 cpu一次执行吞吐量是4字节\n```\n> 当数据的大小大于1字节时，它在内存中是以字节倒叙存储（主机字节序）\n\n### 转义字符\n* 一部分不可打印的字符、单引号、双引号以及反斜杠要使用转义字符(转义序列以反斜杠开头)\n\n原因：单引号、双引号会跟最近的进行匹配\n\\'单引号  \n\\\"双引号  \n\\n换行  \n\\r回车键  \n\\\\反斜杠   当字符串为文件路径时  可偷懒，使用/符号即可  \n\n\n逻辑路径\n虚拟路径\n\n* 一般的转义序列采用如下格式\n\\000\n这里的ooo代表三个八进制数字组成的序列\n\n字符'0'与'\\0'的区别\n\n* 另外，字符文字前面可以加\"L\"例如L'a'\n这称为宽字节文字，类型为wchar_t。宽字符常量用来支持某些语言的字符集合，如汉语、日语  这些语言中的某些字符不能用单个字符来表示  \n实际上C语言是没有wchar_t，其实他是unsigned short,wchar_t时我们给他取的别名  \n```C\n使用 typedef unsigned short wchar_t 或 #define wchar_t unsigned short\n```\n说白了 宽字节实际上是增大了字符表的内容\n\n### 字符串文字常量\n\n* 字符串文字常量有另个或多个用双引号括起来的字符组成。不可打印的字符可以用相应的字符串序列来表示，而一串字符串文字可以拓展到多行 在一行最后加上一个反斜杠表示字符串在下一行继续\n\n目的：当代码一行过长的  为了防止内容被屏幕限制 是程序员一眼能看到所有的内容\n\n* 字符串文字的类型是常量字符数组。他由字符串文字本身以及编译器加上表示结束的空`'\\0'`字符构成\n> `'\\0'`是字符串的结尾标志 系统遇到`'\\0'`便结束输出字符串\n\n* 宽字节字符串 在字符串前面加上L，此时每个字符都占2字节\n\n> 字符串使用的时候 使用的是字符串首字符的地址 双引号`\"\"`实际上就是取字符串的地址\n\n* 他也有一个等价宽空字符作为结束标志\n\n> 两种字符串不能混用，单字节字符串和双字节字符串不能混用!!!\n\n\ncpu的吞吐量是四字节\ntypedef只能C++用？\nMSDN文档","tags":["随记"],"categories":["跟着丁哥学语言"]},{"title":"C课堂笔记day2","url":"/2020/09/08/C课堂笔记day2/","content":"\n## C++数据类型\n\n程序=数据+算法\n\nC语言中将数据称作为数据 在C++中，将数据称为对象\n\n<!-- more -->\n\n人是对象，显示器也是一个对象，那么显示器称为对象的名称还是对象的类型呢？显示器可以称为一个类型。  \n>类型是用来说明数据的，或者在C++中类型是用来说明对象的\n--------------\n\n1. 内置类型/预定义类型  \n2. 自定义类型\n\nC++中有bool类型，C语言中没有，bool类型属于 `内置类型/预定义类型`   \nC++中还有枚举类型，属于 `自定义类型`\n\n### 文字常量\nC++预定义了一组数值数据类型，可以用来便是整数、浮点数和单个字符。此外，还预定义了用来表示字符串的字符数组  \n\n\n事实上，在计算机中，只有整数和浮点数，字符也是整数，字符串是整数的一个数组  \n\n`sizeof()`不是函数，他是一个关键字或者一个运算符，他会返回该内容的字节大小\n\n**板书**  \n![图片](lesson2-1.png)\n\n案例1：  \n```C++\n// test1.cpp : Defines the entry point for the console application.\n//\n\n#include \"stdafx.h\"\n#include<iostream.h>\nint main(int argc, char* argv[])\n{\n\tcout<<\"char size:\"<<sizeof(char)<<endl;\n\tcout<<\"int size:\"<<sizeof(int)<<endl;\n\tcout<<\"long size:\"<<sizeof(long)<<endl;\n\tcout<<\"float size:\"<<sizeof(float)<<endl;\n\tcout<<\"double size:\"<<sizeof(double)<<endl;\n\t\n\tcout<<\"long double size:\"<<sizeof(long double)<<endl;\n\t//也是8字节，实际上在vc6.0中没有long double ，可以这样写但还是double\n\treturn 0;\n}\n\n```\n运行结果：  \n![图片](pic2.png)\n\n\n\n* 整值类型可以有符号，也可以无符号。在有符号类型中，最左边的位是符号位，余下的位代表数值。在无符号的类型中，所有位都表示数值。\n![图片](lesson2-2.png)\n\n\n### 整数文字常量\n* 整数文字常量可以被写成十进制、八进制或者十六进制的形式（这不会改变该整数值的位序数）\n* 在缺省的条件下，整型文字常量被当做成`int`有符号型。可以在文字常量末尾加入`L`或`l`将其变成long型，加入`u`将其转换成`unsigned`；也可以进行组合,如`128uL`  \n在使用`l`或`L`时，尽量使用大写`L`，不然会让我们误以为是数字`1`而不是字母`l`\n\n### 浮点型文字常量\n\n* 浮点型文字常量，可以被写成科学计数法形式或普通的十进制形式，s使用科学计数法，指数可做`e`或者`E`。浮点文字常量\n* 缺省条件下，默认是`double`型，可在末尾加`f`将其转换成`float`  `3.14f`\n\n> 常量也是可以寻址的，并不是不可以寻址的\n\n\n### bool型文字常量","tags":["随记"],"categories":["跟着丁哥学语言"]},{"title":"C课堂笔记day1","url":"/2020/09/07/C课堂笔记day1/","content":"\n\n\n## 大杂烩\n运行代码弹出的窗口叫做控制台 （命令行操作）msdos  \n纯C/C++程序执行是在命令行里面的\n\n<!-- more -->\n\n学习的部分(基础部分)  \n1. \n2. \n3. \n4. \n5. \n\n\nC语言相对于其他语言来说，什么都可以做只不过可能开发周期会慢一些，C语言可以接触到底层方面的内容  \nC/C++属于编译性语言，不需要虚拟机之类的\n\n\n## vc6.0的介绍\n\n### 一、创建项目的方式\n1. new-->file\n![图片](pic1.png)\n\n> 如果以这种方式创建两个文件的话，文件夹里的文件会混合在一起，不便于寻找  \n\n![图片](pic3.png)\n\n2. new-->projects-->Win32 consolo Application  \n![图片](pic2.png)\n![图片](pic4.png)\n![图片](pic5.png)\n\n> 这样创建文件，目录文件时井然有序的\n\n![图片](pic6.png)  \n\n\n## C++的优点\n1. cout相对于C语言中的printf，需要写的更少了\n\n![图片](pic7.png)\n\n\n## 内存问题\n1. 指针  \n16位计算机  最多使用2^20的字节 1M  （为什么是2^20）\n32位计算机  最多使用2^32的字节 4Gb  \n64位计算机  最多使用2^64的字节 8Tb  \n>1字节=8位二进制 2^8=256个数 即0~255  \n\n2. 函数\n3. 结构体\n4. 共用体\n5. 枚举\n\n\n## 课堂笔记\n![图片](lesson1-1.png)\n![图片](lesson1-2.png)\n","tags":["随记"],"categories":["跟着丁哥学语言"]},{"title":"连接服务器数据库","url":"/2020/06/21/连接服务器数据库/","content":"\n# 远程连接服务器上数据库\n\n> 之报错问题总结\n\n## 一、服务器上安全组打开数据库端口（默认端口为3306）\n<!-- more -->\n\n![图片](./pic1.png)\n\n\n\n## 二、授予权限\n报错  \n![图片](./pic2.png)\n\n1. 进入数据库  \n![图片](./pic3.png) \n\n2. 授权\n授权命令：  \n`grant all privileges on *.* to 'root'@'我电脑的ip地址' identified by '密码';`\n\n你也可以直接改成这样：  \n`grant all privileges on *.* to 'root'@'%' identified by '123456';`\n就可以给所有ip都设定root登陆了。\n![图片](./pic4.png) \n\n3. 刷新授权\n`flush privileges;`\n![图片](./pic5.png) \n\n4. 退出\n`exit`\n\n5. 重启mysql服务\n`service mysqld restart`\n![图片](./pic6.png) \n\n\n\n## 成功\n![图片](./success.png) \n","tags":["随记"],"categories":["随记"]},{"title":"C语言 day22","url":"/2020/05/28/C语言-day22/","content":"\n\n# 文件\n\n1. 文件的基本概念\n2. C语言对文件的处理\n3. 文件的基本练习\n\n<!-- more -->\n\n## 文件的基本概念\n\n- 磁盘文件：指一组相关数据的有序集合，通常储存在外部介质（如磁盘），使用时才调入内存。  \n- 设备文件：\n    + 键盘：标准输入文件\n    + 屏幕：标准输出文件\n    + 其他设备：打印机、触摸屏、摄像头、音箱等\n\n![图片](./pic1.png)  \n\n缓冲区的作用：  \n1、提高存取效率\n2、提高磁盘的使用寿命\n\n### 磁盘文件的分类\n1. 一个文件通常是磁盘上一段命名的存储区\n2. 计算机的存储在物理上是二进制的，所以物理上所有的磁盘文件本质上都是以字节  \n为单位进行顺序存储的\n3. 从用户或者操作系统的使用角度上（逻辑上）可以把文件分为：\n    - 文本文件：基于字符编码的文件\n    - 二进制文件：基于值编码的文件\n\n### 文本文件\n1. 基于字符编码，常见编码有ASCII、UNICODE等，一般可以使用文本编辑器直接打开\n\n例如：数5678以ASCII码的存储形式为`00110101 00110110 00110111 00111000`  \n歌词文件(lrc)：文本文件\n\n### 二进制文件\n1. 把内存中的数据按其在内存中的存储形式原样输出到磁盘上\n2. 一般需要自己判断或使用特定的软件分析数据格式\n例如：5678的储存形式为 二进制码：`00010110 00101110`  \n音频文件(mp3)：二进制文件  \n\n### 文本文件、二进制文件的对比（重要）\n1. 译码：  \n    - 文本文件编码基于字符定长，译码容易些\n    - 二进制文件编码是变长的，译码难一些，不同的二进制文件，需要不同的译码方式，或即要使用不同的软件打开\n\n2. 空间利用率：\n    - 二进制文件用一个比特来代表一个意思（位操作）\n    - 文本文件任何一个符号至少需要一个字节\n\n3. 可读性：\n    - 文本文件用通用的记事本就几乎可以浏览所有文本文件\n    - 二进制文件需要一个具体的文件解码器，不如读图软件、音乐播放器等。\n\n\n## 文件的打开与关闭\n\n- C语言中不能直接操作文件  \n只能采用库函数间接对文件进行操作\n\n- C语言操作文件的基本流程\n在使用文件前调用打开函数将文件打开\n\n- 打开文件会得到一个文件指针fp\n    1. 调用各种有关函数，利用fp对文件进行具体操作（读或写）\n    2. 在文件使用完后，及时电泳关闭函数来关闭文件\n    3. C语言中所有的文件操作都围绕文件指针完成\n\n- 任何文件使用之前必须打开，使用之后必须关闭\n\n## 文件指针\n\n- 文件指针的定义\n```C\nFILE * 指针变量名\n```\nFILE是系统在头文件`stdio.h`中使用`typedef`定义出来的存储有关文件信息的一种结构体类型\n\n![图片](./pic2.png)  \n\n- 注意：实际编程过程中，使用库函数操作文件，无需关心`FILE`结构体的细节\n\n- 三个特殊的文件指针（无需定义，直接可以使用）\n    1. `stdio`：标准输入设备 默认为当前终端（键盘）\n    2. `stdout`：标准输出设备 默认为当前终端（屏幕）\n    3. `stderr`：标准出错 默认为当前终端（屏幕）  \n    当我们程序出错或者使用perror函数时，信息打印在此终端\n\n\n## fopen打开文件\n- 头文件：`#include <stdio.h>`\n- 函数定义：`FILE *fopen(const char *path, const char *mode);`\n    1. 第一个参数：文件的路径\n    2. 第二个参数：打开方式 `r w a + b t`\n- 返回值：成功返回相应的指针，失败返回`NULL`\n\n- 第二个参数的集中形式（打开文件的方式）\n    1. `r`以只读的方式打开文件\n        + 文件不存在返回`NULL`\n        + 文件存在，返回文件指针，进行后续的读操作\n    2. `w`以只写的方式打开\n        + 文件不存在，以指定文件名创建此文件\n        + 文件存在，清空文件内容，进行写操作\n        + 文件打不开（权限为只读），返回`NULL`\n    3. `a`以追加的方式打开文件\n        + 文件不存在，以指定文件名创建此文件（同`w`）\n        + 文件存在，从文件的结尾处进行写操作\n    4. `+`同时以读写方式打开指定文件\n        + 注意与`rw`的区别\n    5. `b`和`t`\n        + `b`以二进制的方式打开文件\n        + `t`(可省略)以文本方式打开文件\n\n```C\nFILE *fp = NULL;\nfp = fopen(文件名，文件使用方式);\n```\n\n### 打开方式的组合形式\n![图片](./pic3.png)\n\n\n\n## fclose关闭文件\n- 头文件：`#include <stdio.h>`\n- 函数定义：`int fclose(FILE *fp);`\n- 返回值：\n    + 关闭成功：返回0\n    + 关闭失败：返回非0\n\n```C\nFILE *fp=NULL;\nfp=fopen(\"a.txt\",\"r\");\nfclose(fp);\n```\n\n## 文件的顺序读写\n- 字节读写函数：`fgetc`和`fputc`\n- 字符串读写函数：`fgets`和`fputs`\n- 数据块读写函数：`fread`和`fwrite`\n- 格式化读写函数：`fscanf`和`fprintf`\n\n## 字节的读写函数\n\n### 字节的读操作`fgetc`\n- 头文件：`#include <stdio.h>`\n- 函数定义：`int fgetc(FILE *stream);`\n- 返回值：\n    + 读取成功： 返回字符对应的ASCII码\n    + 到达文件末尾或发生读错误：返回 EOF。\n```C\nch=fgetc(fp);//读一个字节\n```\n1. 文本文件：读到文件末尾返回EOF（EOF是个宏-1）\n2. 二进制文件：要使用feof判断是否到达文件末尾\n\n### 字节的读操作`fgetc`\n- 头文件：`#include <stdio.h>`\n- 函数定义：`int fputc(int c, FILE *stream);`\n- 返回值：\n    + 输出成功：返回输出的字节\n    + 输出失败：返回EOF\n```C\nch=fgetc(fp);//读一个字节\n```\n\n### 案例1：\n```C\nvoid test1(void) {\n\tFILE* fp = NULL;\n\tchar buf[256] = \"\";\n\tint i = 0;\n\tfp = fopen(\"C:/Users/11977/Desktop/a.txt\", \"r\");\n\n\twhile (1)\n\t{\n\t\tbuf[i] = fgetc(fp);\n\t\tif (buf[i] == EOF) {\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tprintf(\"%s\\n\", buf);\n\tfclose(fp);\n\treturn;\n}\n```\n运行结果：\n![图片](./pic4.png)\n![图片](./pic5.png)\n\n### 案例2：\n```C\nvoid test2(void) {\n\tchar buf[256] = \"\";\n\tint i = 0;\n\tFILE* fp = NULL;\n\tfp = fopen(\"C:/Users/11977/Desktop/b.txt\", \"w\");\n\tprintf(\"请输入要写入的字符串：\\n\");\n\tfgets(buf, 256, stdin);\n\tbuf[strlen(buf) - 1] = '\\0';//去掉读取进去的换行符\n\twhile (1)\n\t{\n\t\tfputc(buf[i],fp);\n\t\tif (buf[i] == '\\0') {\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tfclose(fp);\n\treturn;\n}\n```\n运行结果：\n![图片](./pic6.png)  \n![图片](./pic7.png)  \n\n### 练习：从一个文件（文本文件）中读取所有信息，写入到另一个文件中\n参考：`r+ w+ fgetc fputc EOF`\n\n\n## 字符串的读写函数\n\n\n### 字符串的写操作`fputs`\n- 头文件：`#include <stdio.h>`\n- 函数定义：`int fputs(const char *s, FILE *stream);`\n- 返回值：\n    + 成功：返回一个非负值\n    + 失败：返回 EOF\n- 注意：字符串的'\\0'不会写入到文件中，且遇到'\\0'结束\n\n### 字符串的读操作\n- 头文件：`#include <stdio.h>`\n- 函数定义：`char *fgets(char *s, int size, FILE *stream);`\n- 返回值：\n    + 成功：返回相同的 str 参数\n    + 到达文件末尾或者没有读取到任何字符：返回NULL\n    + 发生错误：返回NULL\n- 注意：从`stream`文件中读取`size-1`个字符，在读取过程中遇到换行符或EOF，读取结束，并读取换行符，在最后加一个'\\0'。获取一行数据。\n\n### 案例3：\n```C\nvoid test3(void) {\n\tint i = 0;\n\tint res = 0;\n\tchar* buf[] = {\n\t\t\"给你一整首情诗\\n\",\n\t\t\"关于你温暖名字\\n\",\n\t\t\"在每个孑然的深夜为你诵读\\n\",\n\t\t\"字句真诚而坚固\\n\",\n\t\t\"星辰也为你祝福\\n\" };\n\tint n = sizeof(buf) / sizeof(buf[0]);\n\tFILE* fp = NULL;\n\tfp = fopen(\"C:/Users/11977/Desktop/c.txt\", \"w\");\n\tfor (i = 0; i < n; i++) {\n\t\tres = fputs(buf[i], fp);\n\t}\n\n\tfclose(fp);\n\treturn;\n}\n```\n运行结果：\n![图片](./pic8.png)  \n\n\n\n### 案例4：\n```C\nvoid test4(void) {\n\tchar* res=NULL;\n\tchar str[256] = \"\";\n\tFILE* fp = NULL;\n\tfp = fopen(\"C:/Users/11977/Desktop/c.txt\", \"r\");\n\twhile (1)\n\t{\n\t\tres = fgets(str, sizeof(str), fp);\n\t\tif (res == NULL) {\n\t\t\tbreak;\n\t\t}\n\t\tprintf(\"%s\", str);\n\t}\n\tfclose(fp);\n\treturn;\n}\n```\n运行结果：\n![图片](./pic9.png)  \n\n\n\n## 文件块的读写函数\n\n### 文件块的写操作`fwrite`\n- 头文件：`#include <stdio.h>`\n- 函数定义：`size_t fwrite(const void *ptr, size_t size, size_t nmemb,FILE *stream);`\n- 函数参数：\n\t1. 第一个参数：从哪里读取写入\n\t2. 第二个参数：一次读写的数据块大小\n\t3. 第三个参数：要读写的数据块数\n\t4. 第四个参数：要写入文件的指针\n- 返回值：\n    +  实际读写的数据块数（不是总数据大小，重要）\n- 注意：fwrite是将内存中的数据原样写入到文件中，记事本打开会出现乱码；但是数据本身是没问题的，不影响读取\n\n\n\n### 文件块的读操作`fread`\n- 头文件：`#include <stdio.h>`\n- 函数定义：`size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);`\n- 函数参数：\n\t1. 第一个参数：读到哪里去\n\t2. 第二个参数：一次读写的数据块大小\n\t3. 第三个参数：要读写的数据块数\n\t4. 第四个参数：要写入文件的指针\n- 返回值：\n    +  实际读写的数据块数（不是总数据大小，重要）\n\n\n### 案例5：\n```C\nvoid test5(void) {\n\tSTU grade[] = {\n\t\t{100,\"xiaochen\",98},\n\t\t{101,\"xiaohua\",87},\n\t\t{102,\"xiaoming\",60}\n\t};\n\tint n = sizeof(grade) / sizeof(grade[0]);\n\n\tFILE* fp = NULL;\n\tfp = fopen(\"C:/Users/11977/Desktop/d.txt\", \"w\");\n\tfwrite(grade, sizeof(STU), n, fp);\n\tfclose(fp);\n\treturn;\n}\n```\n运行结果：\n![图片](./pic10.png)  \n\n\n### 案例6：\n```C\nvoid test6(void) {\n\tSTU grade[4];\n\tint n = sizeof(grade) / sizeof(grade[0]);\n\tmemset(grade, 0, sizeof(grade));\n\tint\ti = 0;\n\n\tFILE* fp = NULL;\n\tfp = fopen(\"C:/Users/11977/Desktop/d.txt\", \"r\");\n\t/*for (i = 0; i < 3; i++) {\n\t\tfread(&grade[i], sizeof(STU), n, fp);\n\t}*/\n\tfread(&grade[i], sizeof(STU), 3, fp);\n\n\tfor (i = 0; i < 3; i++) {\n\t\tprintf(\"num=%d name=%s score=%f\\n\", grade[i].num, grade[i].name, grade[i].score);\n\t}\n\tfclose(fp);\n\treturn;\n}\n```\n运行结果：\n![图片](./pic11.png)  \n\n\n## 文件的格式化读写\n\n### 格式化写操作`fprintf`\n- 头文件：`#include <stdio.h>`\n- 函数定义：`int fprintf(FILE *stream, const char *format, ...);`\n- 函数参数：\n\t1. 第一个参数：要写入文件的指针\n- 返回值：\n    + 成功：返回写入的字符总数\n\t+ 失败：返回一个负数。\n\n\n### 格式化读操作`fscanf`\n- 头文件：`#include <stdio.h>`\n- 函数定义：`int fscanf(FILE *stream, const char *format, ...);`\n- 函数参数：\n\t1. 第一个参数：要读取的文件的指针\n- 返回值：\n    + 成功：返回成功匹配和赋值的个数\n\t+ 到达文件末尾或发生读错误：返回EOF。\n\n\n### 案例7：\n```C\nvoid test7(void) {\n\tSTU grade[] = {\n\t\t{100,\"xiaochen\",98},\n\t\t{101,\"xiaohua\",87},\n\t\t{102,\"xiaoming\",60}\n\t};\n\tint n = sizeof(grade) / sizeof(grade[0]);\n\tint i = 0;\n\tFILE* fp = NULL;\n\tfp = fopen(\"C:/Users/11977/Desktop/e.txt\",\"w\");\n\tif (fp == NULL) {\n\t\tperror(\"fopen\");\n\t\treturn;\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tfprintf(fp, \"num=%d name=%s score=%f\\n\", grade[i].num, grade[i].name, grade[i].score);\n\t}\n\n\tfclose(fp);\n\treturn;\n}\n```\n运行结果：\n![图片](./pic12.png)\n\n### 案例8：\n```C\nvoid test8(void) {\n\tSTU grade[3];\n\tmemset(grade, 0, sizeof(grade));\n\tint i = 0;\n\tFILE* fp = NULL;\n\tfp = fopen(\"C:/Users/11977/Desktop/e.txt\", \"r\");\n\tif (fp == NULL) {\n\t\tperror(\"fopen\");\n\t\treturn;\n\t}\n\tfor (i = 0; i < 3; i++) {\n\t\tfscanf(fp, \"num=%d name=%s score=%f\\n\", &grade[i].num, grade[i].name, \\\n\t\t\t&grade[i].score);\n\t}\n\tfor (i = 0; i < 3; i++) {\n\t\tprintf(\"num=%d name=%s score=%f\\n\", grade[i].num, grade[i].name, grade[i].score);\n\t}\n\tfclose(fp);\n\treturn;\n}\n```\n运行结果：\n![图片](./pic13.png)\n\n\n---------------\n\n\n## 文件的随机读写\n`rewind、ftell、fseek函数`\n\n### 引入\n```C\nvoid test9(void) {\n\tchar buf[16] = \"\";\n\tFILE* fp = NULL;\n\tfp = fopen(\"C:/Users/11977/Desktop/f.txt\", \"w+\");\n\tif (fp == NULL) {\n\t\tperror(\"fopen\");\n\t\treturn;\n\t}\n\tfputs(\"hello file!\", fp);\n\n\tfgets(buf, 16, fp);\n\tprintf(\"%s\\n\", buf);\n\tfclose(fp);\n\treturn;\n}\n```\n运行结果：\n![图片](./pic14.png)  \n\n#### 为什么会出现这种现象？\n\n当写入hello file!完成后，流指针到达文件末尾!的位置；当再次读取的时候从!开始读取，由于系统不知道你要写入多少内容，他会给你分配足够的空间，所以后面是屯屯屯，而当读取屯屯屯后流指针停在了屯屯屯的末尾，即分配的足够空间的末尾，此时再关闭文件，屯屯屯也不会消失了。如果没有进行读取操作在写入hello file!后立即关闭文件，系统会自动删除流指针后面的屯屯屯。   \n\n解决办法：文件写完后需要关闭文件，然后重新打开文件。让文件流指针指向文件开始的位置。（顺序读取只能这样解决）  \n\n\n## rewind\n\n- 头文件：`#include <stdio.h>`\n- 函数定义：`void rewind(FILE *stream);`\n- 返回值：`void`\n- 功能：将文件流指针返回到文件首位置\n\n## ftell\n\n- 头文件：`#include <stdio.h>`\n- 函数定义：`long ftell(FILE *stream);`\n- 返回值：返回流指针距离文件首的字节数\n- 功能：测量当前流指针的位置\n\n\n## fseek\n\n- 头文件：`#include <stdio.h>`\n- 函数定义：`int fseek(FILE *stream, long offset, int whence);`\n- 函数参数：\n\t+ offset：偏移量（正数向右，负数向左）\n\t+ whence：开始偏移的位置\n\t\t* SEEK_SET 文件的开头（宏 0）\n\t\t* SEEK_CUR 文件指针的当前位置（宏 1）\n\t\t* SEEK_END 文件的末尾（宏 2）\n- 返回值：\n\t+ 成功：函数返回零\n\t+ 失败：返回非零值\n- 功能：流指针的移动\n\n### 案例9：\n根据文件大小动态申请空间，一次性读取文件所有内容\n```C\nvoid test10(void) {\n\tFILE* fp = NULL;\n\tfp = fopen(\"C:/Users/11977/Desktop/g.txt\", \"r\");\n\tif (fp == NULL) {\n\t\tperror(\"fopen\");\n\t\treturn;\n\t}\n\t//1、测量文件大小\n\t//a、跳到文件末尾\n\tfseek(fp, 0, SEEK_END);\n\t//b、获取当前位置距文件首的字节数\n\tint size = ftell(fp);\n\t//c、将流指针跳回文件首\n\trewind(fp);\n\n\t//2、申请堆区空间\n\tchar* buf = (char*)calloc(1,size+1);//加1目的是存放 \\0\n\n\t//3、将文件内容读取到内存\n\tfread(buf,size,1,fp);\n\n\t//打印读取出的内容\n\tprintf(\"%s\\n\", buf);\t\n\n\tfclose(fp);\n\treturn;\n}\n```\n运行结果：\n![图片](./pic15.png)  \n\n\n## feof函数\n- 头文件：`#include<stdio.h>`\n- 函数定义：`int feof(FILE *stream);`\n- 返回值：当设置了与流关联的文件结束标识符时，该函数返回一个非零值，否则返回零。即，\n\t+ 文件结束:返回非0\n\t+ 文件未结束：返回0\n- 功能：判断文件是否到达末尾\n\n- 注意：\n\t1. EOF宏 只能用于文本文件\n\t2. feof函数：文本文件、二进制文件都可以使用\n## 案例10：\n```C\nvoid test11(void) {\n\tchar ch = '\\0';\n\tFILE* fp = NULL;\n\tfp = fopen(\"C:/Users/11977/Desktop/g.txt\", \"r\");\n\tif (fp == NULL) {\n\t\tperror(\"fopen\");\n\t\treturn;\n\t}\n\n\twhile (feof(fp) == 0)\n\t{\n\t\tch = fgetc(fp);\n\t\tprintf(\"%c\", ch);\n\t}\n\n\tfclose(fp);\n\treturn;\n}\n```\n运行结果：\n![图片](./pic16.png)  \n\n\n## ferror函数\n- 头文件：`#include<stdio.h>`\n- 函数定义：`int ferror(FILE *stream)`\n- 返回值：如果设置了与流关联的错误标识符，该函数返回一个非零值，否则返回一个零值。即，\n\t+ 遇到错误:返回非0\n\t+ 无错误：返回0\n\n\n\n\n","tags":["随记"],"categories":["C语言"]},{"title":"C语言 day21","url":"/2020/05/27/C语言-day21/","content":"\n\n# 链表\n\n\n## 链表的查询\n\n**`main.c`**\n\n<!-- more -->\n\n\n\n```C\n... ...\nelse if (strcmp(cmd, \"search\") == 0) {\n\t\t\t//printf(\"-------search--------\\n\");\n\t\t\tSTU *res=NULL;\n\t\t\tchar name[64]=\"\";\n\t\t\t//memset(&res, 0, sizeof(STU));\n\t\t\tprintf(\"请输入要查询的姓名：\\n\");\n\t\t\tscanf(\"%s\", name);\n\t\t\tres = search_link(head,name);\n\t\t\tif (res == NULL)\n\t\t\t{\n\t\t\t\tprintf(\"没有查到%s的有关信息\\n\",name);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"%s的信息：\\n\",name);\n\t\t\t\tprintf(\"%d %s %f\\n\", res->num, res->name, res->score);\n\t\t\t}\n\t\t}\n... ...\n```\n\n<br/>\n\n**`link.c`**\n```C\n//查询节点\nSTU* search_link(STU* head, char* name) {\n\tSTU* pb = head;\n\t//判断链表是否存在\n\tif (pb == NULL) {\n\t\tprintf(\"链表不存在\\n\");\n\t\treturn head;\n\t}\n\telse\n\t{\n\t\t//寻找对应节点\n\t\twhile (strcmp(pb->name, name) != 0 && pb->next != NULL) {//pb->next != NULL防止越界 出现段错误\n\t\t\tpb = pb->next;\n\t\t}\n\n\t\t//判断是否找到\n\t\tif (strcmp(pb->name, name) == 0)\n\t\t{\n\t\t\treturn pb;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn NULL;\n\t\t}\n\t}\n\t\n\t//return pb;\n}\n```\n\n\n\n\n----------------------\n\n<br/>\n\n## 链表节点的删除\n\n\n**`main.c`**\n\n```C\n... ...\nelse if (strcmp(cmd, \"delete\") == 0) {\n\t\t\t//printf(\"-------delete--------\\n\");\n\t\t\tchar name[64] = \"\";\n\t\t\tprintf(\"请输入要删除的姓名：\\n\");\n\t\t\tscanf(\"%s\", name);\n\t\t\thead = delete_link(head, name);//要更新链表头 所以要返回值 因为如果删除的是头节点链表头就更新了\n\t\t}\n\n... ...\n```\n\n<br/>\n\n**`link.c`**\n\n```C\nSTU* delete_link(STU *head, char *name) {\n\tSTU* pb = head,*pf=head;//pf跟在pb后面 用于后面删除中部节点\n\t//判断链表是否存在\n\tif (pb == NULL) \n\t{\n\t\tprintf(\"链表不存在\\n\");\n\t\treturn head;\n\t}\n\telse//链表存在\n\t{\n\t\t//寻找要删除节点\n\t\twhile (strcmp(pb->name, name) != 0 && pb->next != NULL) //pb->next != NULL防止越界 出现段错误\n\t\t{\n\t\t\tpf = pb;\n\t\t\tpb = pb->next;\n\t\t}\n\t\t//判断删除节点是否存在\n\t\tif (strcmp(pb->name, name) == 0)//存在\n\t\t{\n\t\t\t//判断节点的位置\n\t\t\tif (pb == head)//头部\n\t\t\t{\n\t\t\t\thead = pb->next;\n\t\t\t\tfree(pb);\n\t\t\t\treturn head;\n\t\t\t}\n\t\t\telse if (pb->next!=NULL && pb!=head)//中部\n\t\t\t{\n\t\t\t\tpf->next = pb->next;\n\t\t\t\tfree(pb);\n\t\t\t}\n\t\t\telse if (pb->next==NULL)//尾部\n\t\t\t{\n\t\t\t\tpf->next = NULL;\n\t\t\t\tfree(pb);\n\t\t\t}\n\t\t}\n\t\telse//不存在\n\t\t{\n\t\t\tprintf(\"%s节点不存在\\n\",name);\n\t\t}\n\t}\n\treturn head;\n}\n```\n\n-------------\n\n<br/>\n\n## 释放链表\n\n\n**`main.c`**\n\n```C\n··· ···\nelse if (strcmp(cmd, \"free\") == 0) {\n\t\t\t//printf(\"-------free--------\\n\");\n\t\t\tchar sure[8] = \"\";\n\t\t\tprintf(\"确定要释放链表?(Y/N)\");\n\t\t\tscanf(\"%s\", sure);\n\t\t\tif(strcmp(sure,\"Y\")==0)\n\t\t\t{\n\t\t\t\thead = free_link(head);//别忘了更新链表头 链表释放完成后，链表头指向的还是原来的地址，所以要更新\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n··· ···\n```\n\n<br/>\n\n**`link.c`**\n\n```C\n//释放链表\nSTU* free_link(STU* head) {\n\tSTU* pb = head,*head_tmp=head;\n\t//判断链表是否存在\n\tif (pb == NULL) //不存在\n\t{\n\t\tprintf(\"链表不存在\\n\");\n\t\treturn;\n\t}\n\telse//存在\n\t{\n\t\twhile (pb!=NULL)\n\t\t{\n\t\t\thead_tmp = pb->next;\n\t\t\tfree(pb);\n\t\t\tpb = head_tmp;\n\t\t}\n\t\tprintf(\"链表释放完成！\\n\");\n\t\treturn NULL;\n\t}\n\treturn NULL;\n}\n```\n\n\n---------------\n\n<br/>\n\n## 链表的逆序\n\n**`main.c`**\n\n```C\n··· ···\nelse if (strcmp(cmd, \"reserve\") == 0)\n\t\t{\n\t\t\t//printf(\"-------reserve----------\");\n\t\t\thead = reserve_link(head);\n\t\t}\n··· ···\n```\n\n<br/>\n\n**`link.c`**\n```C\n//链表逆序\nSTU* reserve_link(STU* head) {\n\t//1、判断链表是否存在\n\tif (head == NULL)\n\t{\n\t\tprintf(\"链表不存在！\\n\");\n\t\treturn head;\n\t}\n\telse\n\t{\n\t\tSTU* pb = head, * pr = head;\n\t\tpb = pb->next;\n\t\thead->next = NULL;\n\n\t\twhile (pb != NULL)\n\t\t{\n\t\t\tpr = pb->next;//记录pb->next\n\t\t\tpb->next = head;\n\t\t\thead = pb;\n\t\t\tpb = pr;\n\n\t\t}\n\t\treturn head;\n\t}\n}\n```\n\n\n---------------\n\n\n## 链表的整理\n\n按学号进行排序  \n**`main.c`**\n\n```C\n··· ···\nelse if (strcmp(cmd, \"sort\") == 0)\n\t\t{\n\t\t\t//printf(\"-------sort----------\");\n\t\t\thead = sort_link(head);\n\t\t}\n··· ···\n```\n\n<br/>\n\n**`link.c`**\n```C\n//链表的整理\nSTU* sort_link(STU* head) {\n\n\t//还没写呢~\n\treturn head;\n}\n```\n\n> 学生信息系统完整代码(未写完) [下载](./sms.zip)\n","tags":["随记"],"categories":["C语言"]},{"title":"C语言 day20","url":"/2020/05/22/C语言-day20/","content":"\n# 链表\n\n1. 链表的基本概念\n2. 单向链表的操作\n3. 其他链表的概念及应用\n\n<!-- more -->\n\n## 链表的基本概念\n- 定义：链表是一种物理存储上非连续，数据元素的逻辑顺序通过链表中的指针链接次序，实现一种线性的存储结构。\n\n- 特点：链表是由咦嘻嘻额的节点（链表中每一个元素称为节点）组成，节点在运行时`动态生成(malloc/calloc)`,每个节点包括两个部分：\n    + 一个是存储数据的`数据域`\n    + 另一个是存储下一个节点地址的`指针域`\n\n- 链表的构成：\n\n![图片](./pic1.png)  \n\n![图片](./pic3.png)  \n\n> 拓展：数组分为静态数组和动态数组\n\n\n<br/>\n\n--------------\n\n<br/>\n\n\n## 链表节点的定义（结构体实现）\n\n```C\n//定义节点\ntypedef struct stu{\n    //数据域（自定义）\n    int num;\n    char name[32];\n    float score;\n\n    //指针域\n    struct stu *next;\n}STU;\n```\n\n<br/>\n\n-------------\n\n<br/>\n\n\n## 静态链表（玩玩）\n\n```C\n#include <stdio.h>\ntypedef struct stu{\n    int num;\n    char name[32];\n    float score;\n    struct stu *next;\n}STU; \nint main(int argc,char *argv[])\n{\n\tSTU data1={100,\"lucy\",60};\n\tSTU data2={101,\"bob\",87};\n\tSTU data3={102,\"mack\",65};\n\tSTU data4={103,\"jane\",93};\n\t\n\t//链表头\n\tSTU *head=NULL;\n\thead=&data1;\n\tdata1.next=&data2;\n\tdata2.next=&data3;\n\tdata3.next=&data4;\n\tdata4.next=NULL;\n\t\n\t//遍历链表 链表头head永远不要动，定义个变量来存它 \n\tSTU *pb=head;\n\twhile(pb != NULL){\n\t\tprintf(\"num=%d name=%s score=%f\\n\",pb->num,pb->name,pb->score);\n\t\tpb=pb->next;//重要，将pb移动到下一个节点 \n\t} \n\t\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic4.png)  \n\n<br/>\n\n-------------\n\n<br/>\n\n\n\n## 动态链表（分文件、分函数实现）\n案例：学生信息系统  \n`main.c link.c link.h`\n\n### 1、布局整个程序框架\n```C\n#define _CRT_SECURE_NO_WARNINGS\n#include<stdio.h>\n#include<string.h>\nvoid stu_help(void);\n\nint main(int argc, char* argv[]) {\n\n\t//打印帮助信息\n\tstu_help();\n\t//获取输入指令\n\twhile (1) {\n\t\tchar cmd[32] = \"\";\n\t\tprintf(\"请输入操作指令:\\n\");\n\t\tscanf(\"%s\", cmd);\n\t\tif (strcmp(cmd, \"help\") == 0)\n\t\t{\n\t\t\tstu_help();\n\t\t}\n\t\telse if(strcmp(cmd, \"insert\") == 0){\n\t\t\tprintf(\"-------inset--------\\n\");\n\t\t}\n\t\telse if (strcmp(cmd, \"print\") == 0) {\n\t\t\tprintf(\"-------print--------\\n\");\n\t\t}\n\t\telse if (strcmp(cmd, \"delete\") == 0) {\n\t\t\tprintf(\"-------delete--------\\n\");\n\t\t}\n\t\telse if (strcmp(cmd, \"free\") == 0) {\n\t\t\tprintf(\"-------free--------\\n\");\n\t\t}\n\t\telse if (strcmp(cmd, \"quit\") == 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid stu_help(void) {\n\tprintf(\"###################################\\n\");\n\tprintf(\"#help:打印帮助信息                #\\n\");\n\tprintf(\"#insert:插入链表节点              #\\n\");\n\tprintf(\"#print:遍历链表节点信息           #\\n\");\n\tprintf(\"#search:查询链表节点              #\\n\");\n\tprintf(\"#delete:删除链表节点              #\\n\");\n\tprintf(\"#free:释放链表                    #\\n\");\n\tprintf(\"#quit:退出                        #\\n\");\n\tprintf(\"###################################\\n\");\n\treturn;\n}\n```\n\n\n### 2、insert功能实现 \n\n#### 1、链表插入之头部之前插入\n**`link.h`**\n\n```C\n//#pragma once\n//防止头文件重复包含\n#ifndef __LINK_H__\n#define __LINK_H__\n\n//链表节点类型定义\ntypedef struct stu {\n\t//数据域\n\tint num;\n\tchar name[32];\n\tfloat score;\n\n\t//指针域\n\tstruct stu* next;\n}STU;\nextern STU* insert_link(STU* head, STU tmp);\nextern void pritn_link(STU* head);\n\n#endif // !__LINK_H__\n\n```\n\n<br/>\n\n**`link.c`**\n```C\n#include\"link.h\"\n#include<stdio.h>//NULL\n#include<stdlib.h>//calloc\n\nSTU* insert_link(STU* head, STU tmp) {\n\t//1、从堆区申请一个待插入的节点空间\n\tSTU* pi = (STU*)calloc(1, sizeof(STU));\n\tif (pi == NULL) {\n\t\tperror(\"calloc\");\n\t\treturn head;//不要返回NULL\n\t}\n\n\t//2、将tmp的值赋给*pi\n\t*pi = tmp;\n\tpi->next = NULL;\n\n\t//3、将pi插入到链表中(链表存在/链表不存在)\n\tif (head == NULL) {//链表不存在\n\t\thead = pi;\n\t}\n\telse {//链表存在\n\t\t//1、让pi的指针域指向旧的头\n\t\tpi->next = head;\n\n\t\t//2、将head指向新的头节点\n\t\thead = pi;\n\t}\n\n\treturn head;\n\n}\n\nvoid pritn_link(STU *head){\n\tif (head == NULL) {\n\t\tprintf(\"链表不存在\\n\");\n\t\treturn;\n\t}\n\telse\n\t{\n\t\t//在对链表的操作 不要轻易的让链表头动\n\t\tSTU* pb = head;\n\t\twhile (pb != NULL) {\n\t\t\tprintf(\"num=%d name=%s score=%f\\n\", pb->num, pb->name, pb->score);\n\t\t\tpb = pb->next;//重要\n\t\t}\n\n\t}\n\treturn;\n}\n```\n\n运行结果：\n![图片](./pic5.png)  \n\n\n#### 2、链表插入之尾部插入\n\n**`link.c`**\n\n```C\n//链表的尾部插入\nSTU* insert_link(STU* head, STU tmp) {\n\t//1、从堆区申请一个待插入的节点空间\n\tSTU* pi = (STU*)calloc(1, sizeof(STU));\n\tif (pi == NULL) {\n\t\tperror(\"calloc\");\n\t\treturn head;//不要返回NULL\n\t}\n\n\t//2、将tmp的值赋给*pi\n\t*pi = tmp;\n\tpi->next = NULL;\n\n\t//3、将pi插入到链表的尾部(链表存在/链表不存在)\n\tif (head == NULL) {//链表不存在\n\t\thead = pi;\n\t}\n\telse {//链表存在\n\t\t//a、寻找尾节点\n\t\tSTU* pb = head;\n\t\twhile (pb->next != NULL) {\n\t\t\tpb = pb->next;\n\t\t}\n\t\t//b、尾节点pb链接上pi\n\t\tpb->next = pi;\n\t\treturn head;\n\t}\n\n\treturn head;\n\n}\n```\n\n#### 4、链表的有序插入\n\n以num的顺序从小到大插入\n\n```C\n//链表的有序插入\nSTU* insert_link(STU* head, STU tmp) {\n\t//1、从堆区申请一个待插入的节点空间\n\tSTU* pi = (STU*)calloc(1, sizeof(STU));\n\tif (pi == NULL) {\n\t\tperror(\"calloc\");\n\t\treturn head;//不要返回NULL\n\t}\n\n\t//2、将tmp的值赋给*pi\n\t*pi = tmp;\n\tpi->next = NULL;\n\n\t//3、将pi插入到链表的尾部(链表存在/链表不存在)\n\tif (head == NULL) {//链表不存在\n\t\thead = pi;\n\t}\n\telse {//链表存在\n\t\t//a、寻找插入点\n\t\tSTU* pb = head, * pf = head;\n\t\twhile (pi->num > pb->num && pb->next!=NULL) {//pb->next!=NULL 防止越界，造成段错误\n\t\t\tpf = pb;\n\t\t\tpb = pb->next;\n\t\t}\n\t\t//b、判断插入点\n\t\tif (pi->num <= pb->num) {//中部 或 头部\n\t\t\tif (pb == head) {//头部\n\t\t\t\tpi->next = head;\n\t\t\t\thead = pi;\n\t\t\t\treturn head;\n\t\t\t}\n\t\t\telse//中部\n\t\t\t{\n\t\t\t\tpi->next = pb;\n\t\t\t\tpf->next = pi;\n\t\t\t\treturn head;\n\t\t\t}\n\t\t}\n\t\telse if (pi->num > pb->num && pb->next == NULL)//尾部\n\t\t//else//尾部\n\t\t{\n\t\t\tpb->next = pi;\n\t\t\treturn head;\n\t\t}\n\t}\n\treturn head;\n}\n```\n\n","tags":["随记"],"categories":["C语言"]},{"title":"C语言 day19","url":"/2020/05/22/C语言-day19/","content":"\n# 共用体 枚举\n\n## 共用体（联合体）\n\n### 共用体与结构体的区别\n\n1、结构体关键字：struct  \n每个成员拥有独立的空间\n\n2、共用体关键字：union  \n所有成员共享同一份空间\n\n<!-- more -->\n\n### 共用体的空间大小\n公用体的空间大小由最大的成员决定\n\n```C\nunion data1{\n    char a;\n    int b;\n    short c;\n};\nprintf(\"%d\\n\",sizeof(union data1));\n```\n运行结果： \n![图片](./pic1.png)  \n\n分析：`union data1` 成员中最大的为 `int b` 占4字节\n\n### 案例1：\n```C\n#include<stdio.h>\nunion data1{\n    char a;\n    int b;\n    short c;\n};\nint main(int argc,char *argv[]){\n\tunion data1 z;\n\tz.a=10;\n\tz.b=20;\n\tz.c=30; \n\tprintf(\"%d\\n\",z.a+z.b+z.c);\n\t\n    return 0;\n}\n```\n运行结果： \n![图片](./pic2.png)  \n\n分析：因为空间是公用的，前面空间被赋的值被后面赋的值覆盖了，然而三个变量指向的是同一个空间，而且取出来的都是30，所以结果为90\n\n\n### 案例2：\n问：由案例1得出，共用体是最后一次赋值才有效，这个结论是对是错？（不严谨，错的）\n\n> 共用体虽然公用同一份空间，但是从空间读取的字节数是由成员自身类型决定的（重要）\n\n![图片](./pic3.png)  \n\n问：下面代码的输出结果？\n```C\n#include<stdio.h>\nunion data1{\n    char a;\n    short b;\n    int c;\n};\nint main(int argc,char *argv[]){\n\tunion data1 z;\n\tz.c=0x01020304;\n\tz.b=0x0102;\n\tz.a=0x01; \n\tprintf(\"%#x\\n\",z.a+z.b+z.c);\n\t\n    return 0;\n}\n```\n运行结果： \n![图片](./pic4.png)  \n\n分析：  \n注意，倒着存倒着取\n![图片](./pic5.png)  \n\n\n<br/>\n\n--------------------\n\n<br/>\n\n\n## 枚举 \n- 将变量的值一一列举出来，变量的值仅限于列举出来的值的范围内\n\n- 枚举的定义：\n```C\nenum 枚举名{\n    枚举值表\n};\n```\n在枚举值表中应列出所有可用值，也称为`枚举元素`  \n枚举变量仅能取枚举值表中所列的元素\n\n### 引入\n试想一下，如果不用枚举，一个星期7天我们要用#define来为每个整数定义一个宏（别名）\n```C\n#define MON  1\n#define TUE  2\n#define WED  3\n#define THU  4\n#define FRI  5\n#define SAT  6\n#define SUN  7\n```\n如果用枚举：\n```C\nenum DAY\n{\n    MON=1, TUE, WED, THU, FRI, SAT, SUN\n};\n```\n这样代码就简洁多了，**实际上枚举就是一个个的宏**\n\n注意：第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。\n\n\n\n### 枚举变量的定义和使用\n\n1、先定义枚举类型，在定义枚举变量\n```C\nenum DAY\n{\n      MON=1, TUE, WED, THU, FRI, SAT, SUN\n};\nenum DAY day;\n```\n\n2、定义枚举类型的同时定义枚举变量  \n```C\nenum DAY\n{\n      MON=1, TUE, WED, THU, FRI, SAT, SUN\n} day;\n```\n\n3、省略枚举名称，直接定义枚举变量  \n```C\nenum\n{\n    MON=1, TUE, WED, THU, FRI, SAT, SUN\n} day;\n```\n\n\n\n### 可以在定义枚举改变枚举元素的值\n\n```C\nenum season {spring, summer=3, autumn=8, winter};\nprintf(\"%d %d %d %d\\n\",spring,summer,autumn,winter);\n```\n运行结果：  \n![图片](./pic6.png)  \n\n\n\n\n### 案例：\n```C\n#include <stdio.h>\nenum DAY\n{\n    MON=1, TUE, WED, THU, FRI, SAT, SUN\n};\n \nint main()\n{\n    enum DAY day;\n    day = WED;\n    printf(\"%d\",day);\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic7.png)  \n\n\n\n\n### 案例：枚举在 switch 中的使用：\n```C\n#include <stdio.h>\nint main(int argc,char *argv[])\n{\n    enum color { red=1, green, blue };\n    enum  color favorite_color;\n \n    printf(\"请输入你喜欢的颜色: (1. red, 2. green, 3. blue): \");\n    scanf(\"%d\", &favorite_color);\n \n    switch (favorite_color)\n    {\n    case red:\n        printf(\"你喜欢的颜色是红色\");\n        break;\n    case green:\n        printf(\"你喜欢的颜色是绿色\");\n        break;\n    case blue:\n        printf(\"你喜欢的颜色是蓝色\");\n        break;\n    default:\n        printf(\"你没有选择你喜欢的颜色\");\n    }\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic8.png)  \n","tags":["随记"],"categories":["C语言"]},{"title":"C语言 day18","url":"/2020/05/21/C语言-day18/","content":"\n\n# 结构体\n\n## 位段\n\n1. 信息在计算的存取长度一般以字节为单位;\n2. 有事储存一个信息不必用一个字节或多个字节\n    - 例如：真或假：用0或1，只需一位即可.\n\n\n<!-- more -->\n\n\n### 怎样向一个字节的一个或几个二进制位赋值和改变他的值呢\n1. 利用前面学过的为运算符：`<< >> & | ~ ^`\n2. 结构体定义位段，利用位段可以减少存储空间并简化位的操作\n\n### C语言允许一个结构体中以位为单位来指定其成员所占内存长度，以位为单位的成员为“位段”或称“位域”。\n注意：位段一般用的是`unsigned int`或`unsigned char`\n\n\n### 案例1：\n- 位域的存储\n\n1. 当相邻成员的类型相同时，如果它们的位宽之和小于类型的 sizeof 大小，那么后面的成员紧邻前一个成员存储，直到不能容纳为止；如果它们的位宽之和大于类型的 sizeof 大小，那么后面的成员将从新的存储单元开始，其偏移量为类型大小的整数倍。\n\n```C\n#include<stdio.h>\nstruct data1{\n    unsigned char a:2;\n    unsigned char b:2;\n};\nstruct data2{\n    unsigned char a:2;\n    unsigned char b:7;\n};\nstruct data3{\n    unsigned int a:12;\n    unsigned int b:12;\n};\nstruct data4{\n    unsigned int a:12;\n    unsigned int b:21;\n};\nint main(int argc,char *argv[]){\n    printf(\"%d\\n\",sizeof(struct data1));\n    printf(\"%d\\n\",sizeof(struct data2));\n    printf(\"%d\\n\",sizeof(struct data3));\n    printf(\"%d\\n\",sizeof(struct data4));\n    return 0;\n}\n````\n运行结果：  \n![图片](./pic1.png)  \n\n分析: data1中成员类型相同，共4位小于char的类型位数8位即1字节，所以打印1字节，data2，共9位，超了，会另起一行，所以打印2字节；data3成员类型相同，且共24位没有超过32位即4字节，所以打印4字节，而data4成员共33位超了，故打印8字节\n\n2. 当相邻成员的类型不同时，不同的编译器有不同的实现方案，GCC 会压缩存储，而 VC/VS 不会。\n\n```C\n#include<stdio.h>\nstruct data1{\n    unsigned char a:2;\n    unsigned int b:2;\n};\nstruct data2{\n    unsigned char a;\n    unsigned int b;\n};\nint main(int argc,char *argv[]){\n    printf(\"%d\\n\",sizeof(struct data1));\n    printf(\"%d\\n\",sizeof(struct data2));\n    return 0;\n}\n```\n\n分析：  \n在 GCC 下的运行结果为 1，三个成员挨着存储；在 VC/VS 下的运行结果为 8（为什么不是5？见上篇文章结构体内存对齐），三个成员按照各自的类型存储（与不指定位宽时的存储方式相同）。\n\n\n3. 如果成员之间穿插着非位域成员，那么不会进行压缩。\n\n```C\nstruct data1{\n    unsigned m: 12;\n    unsigned ch;\n    unsigned p: 4;\n};\n```\n在各个编译器下 sizeof 的结果都是 12。\n\n\n\n\n### 案例2：\n- 位段不能取地址：系统给内存中一个字节分配一个地址，位没有一个字节，没有地址\n```C\n#include<stdio.h>\nstruct data1{\n    unsigned char a:2;\n    unsigned int b:2;\n};\nint main(int argc,char *argv[]){\n\tstruct data1 z;\n    printf(\"%d\\n\",&z.a);\n    return 0;\n}\n```\n结果：  \n![图片](./pic2.png)  \n**编译器会报错，不能对位的变量取地址**\n\n### 案例3：\n- 位段的赋值不要超过位段的大小，\n```C\n#include<stdio.h>\nstruct data1{\n    unsigned char a:2;\n    unsigned char b:2;\n    unsigned char c:2;    \n};\nint main(int argc,char *argv[]){\n\tstruct data1 z;\n\tz.a=3;//11\n\tz.b=4;//100\n\tz.c=5;//101\n\t\n    printf(\"%#x\\n\",z.a);\n    printf(\"%#x\\n\",z.b);\n    printf(\"%#x\\n\",z.c);\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic3.png)  \n\n分析：如果超过位段的大小，则会取后面的值，前面的被截去了，显然这个没有意义的\n\n\n\n### 案例4：\n- 无意义的位段 :2占有两位\n```C\n#include<stdio.h>\nstruct data1{\n    unsigned char a:2;\n    unsigned char :5;\n    unsigned char c:2;    \n};\nstruct data2{\n    unsigned char a:2;\n    unsigned char :4;\n    unsigned char c:2;    \n};\nint main(int argc,char *argv[]){\n\tprintf(\"%d\\n\",sizeof(struct data1));//2\n\tstruct data2 z;\n\tmemset(&z,0,sizeof(z));\n\t//1100 0010  0xc2\n\tz.a=2;//10\n\tz.c=3;//11\n\tunsigned char *p=&z;\n\tprintf(\"%#x\\n\",*p);\n\t \n    return 0;\n}\n```\n\n运行结果：  \n![图片](./pic4.png)  \n\n\n### 案例5：\n- 另起一个位段 :0 使下一个位段从下一个存储单元开始存放\n```C\n#include<stdio.h>\nstruct data1{\n    unsigned char a:2;\n    unsigned char :0; \n};\nstruct data2{\n    unsigned char a:2;\n    unsigned char :0;\n    unsigned char c:2;    \n};\nstruct data3{\n    unsigned char a:2;\n    //unsigned char :0;\n    unsigned char c:2;    \n};\nint main(int argc,char *argv[]){\n\tprintf(\"%d\\n\",sizeof(struct data1));\n\tprintf(\"%d\\n\",sizeof(struct data2)); \n\tprintf(\"%d\\n\",sizeof(struct data3)); \n    return 0;\n}\n```\n\n运行结果：  \n![图片](./pic5.png)  \n\n注意：不会立马生效。是从下一个位段开始，在下一个存储单元存放，所以`struct data1`的字节数仍是`1`","tags":["随记"],"categories":["C语言"]},{"title":"C语言 day17","url":"/2020/05/20/C语言-day17/","content":"\n\n# 结构体-结构体的内存分配\n\n## 引入\n\n```C\nstruct data{\n    char c;\n    int i;\n};\nstruct data stu;\nprintf(\"%d\\n\",sizeof(stu));\n```\n\n\n<!-- more -->\n\n\n- 问：上面代码的输出结果为什么？5？\n\n运行结果：\n![图片](./pic1.png)\n\n分析：`char`一个字节，`int`四个字节，为什么不是5字节呢？32位处理器一次只能处理32位，也就是4个字节的数据，64位处理器一次就能处理64位，即8个字节的数据。看图--->\n![图片](./pic3.png)\n由图可得，上面代码输出的是4字节。\n\n\n> 结构体大小 >= 成员总大小\n\n\n\n\n\n--------------------\n\n\n\n\n\n## 结构体内存对齐\n\n### 对齐规则（重要）\n\n- 步骤：\n    1. 确定分配单位：每行应该分配的字节数，由结构体中最大的基本类型长度决定\n    2. 确定成员的起始位置的偏移量：成员的自身基本类型的整数倍x（0到n），如果空间已经被使用了，则x+1继续偏移，直到遇到没有被使用的空间\n    3. 收尾工作：确定结构体总大小，总大小为分配单位的整数倍，即开辟的行数乘以分配单位\n\n- 例子：\n\n\n1、  \n```C\nstruct data{\n    int a;\n    char b;\n    short c;\n    char d;\n};\n```\n内存分布：  \n![图片](./pic5.png)  \n\n2、  \n```C\nstruct data{\n    char a; \n    short b;\n    short c;\n    int d;\n    char e;\n};\n```\n内存分布：  \n![图片](./pic6.png)  \n3、  \n```C\nstruct data{\n    char a; \n    short b;\n    char c;\n    short d;\n};\n```\n内存分布：  \n![图片](./pic7.png)  \n\n\n\n-----------\n\n\n\n\n## 结构体嵌套结构体 \n\n```C\nstruct data1{\n    int x;\n    int y;\n};\nstruct data2{\n    int a;\n    int b;\n    struct data1 c;\n};\n```\n\n- 结构体变量`c`，作为了`struct data2`的成员，叫做结构体嵌套结构体\n\n### 案例1：\n```C\n#include<stdio.h>\nstruct data1{\n    int x;\n    int y;\n};\nstruct data2{\n    int a;\n    int b;\n    struct data1 c;\n};\nint main(int argc,char *argv[]){\n\n    //嵌套结构体初始化\n    //struct data2 stu={10,11,12,13};//这样也可以，不推荐\n    struct data2 stu={10,11,{12,13}};//仍然需要按照顺序\n\n    //嵌套结构体的赋值\n    stu.c.x=100;\n\n    //嵌套结构体的访问\n    printf(\"%d %d %d %d\\n\",stu.a,stu.b,stu.c.x,stu.c.y);\n    return 0;\n}\n```\n\n运行结果：  \n![图片](./pic4.png)  \n\n> 注意:`stu.c`是没意义的,因为对于计算机来说，他要操作的是数据，那你说`stu.c`是个什么，取出来是什么？啥都不是，但是会打印出c中的第一个元素空间的内容。不要这样干就行了。\n\n\n\n\n----------------\n\n\n## 结构体嵌套结构体的内存对齐\n\n> 先将嵌套的结构体进行上面的内存对齐，再将嵌套的结构体看成一个变量进行下面的步骤，其实跟上面的一样\n- 步骤：\n    1. 确定分配单位：每行应该分配的字节数，所有结构体中最大的基本类型长度。\n    2. 确定成员的起始位置的偏移量：成员的自身基本类型的整数倍x（0到n），如果空间已经被使用了，则x+1继续偏移，直到遇到没有被使用的空间\n    3. 收尾工作：确定结构体总大小，总大小为分配单位的整数倍，即开辟的行数乘以分配单位\n\n\n```C\nstruct A{\n    short e;\n    char f;\n};\nstruct B{\n    int a;\n    short b;\n    struct A c;\n    short d;\n};\n```\n内存分布：  \n![图片](./pic8.png)  \n\n\n```C\nstruct A{\n    short d;\n    char e;\n    int f;\n};\nstruct B{\n    short a;\n    struct A b;\n    short c;\n};\n```\n内存分布：  \n![图片](./pic9.png)  \n\n\n\n\n-------------------\n\n\n\n\n## 指定对齐规则（强制类型对齐）\n\n- 使用`#pragma pack`改变默认对齐原则\n- 格式：`#pragma pack(value)`  \n- 注意：\n    1. `value`只能是1、2、4、8等即2ⁿ;\n    2. 指定对齐值与数据类型对齐值相比取较小值。\n\n- 步骤：\n    1. 确定分配单位：每行应该分配的字节数，分配单位为`min(value,默认对齐字节)`。\n    2. 确定成员的起始位置的偏移量：成员的自身基本类型的整数倍x（0到n），如果空间已经被使用了，则x+1继续偏移，直到遇到没有被使用的空间\n    3. 收尾工作：确定结构体总大小，总大小为分配单位的整数倍，即开辟的行数乘以分配单位\n\n### 案例：\n```C\n#pragma pack(2)\nstruct data{\n    char a;\n    int b;\n    short c;\n};\n```\n分析：不加之前结构体总大小为12字节；加了`#pragma pack(2)`之后结构体的总大小为8字节\n\n\n\n> 结构体的成员顺序，会影响结构体的总大小；如果想节约空间，则可以把字节数差不多的类型放在一起，但是这样访问效率会下降。","tags":["随记"],"categories":["C语言"]},{"title":"intel WiFi驱动","url":"/2020/05/18/intel-WiFi驱动/","content":"\n# Intel WIiFI驱动\n\n## 手动连接版\nWi-Fi驱动2.7.1  \n[本地下载](./Wi-Fi驱动2.7.1.zip)   \n[蓝奏云下载](https://pan.lanzou.com/icrwacd)\n\n\n<!-- more -->\n\n#### 使用步骤：\n1. 将压缩包解压后随便放在哪个位置(只要保证下面图片中的两个文件在同一目录下就ok)![图片](./pic1.png)\n2. 点`run.command`运行文件，第一次需要输入Mac的登录密码\n3. 安装提示新增WiFi就行了，输入`a`回车新增WiFi，可添加多个WiFi\n4. 输入`d`回车删除添加在列表中的WiFi\n5. 注意：添加后重启系统生效。每次重启后需要手动运行`run.command`文件，输入序号连接需要连接的WiFi\n\n\n\n## 自动连接版\nWi-Fi驱动3.7.1-老昂脚本开机自动链接网络  \n[本地下载](Wi-Fi驱动3.7.1-老昂脚本开机自动链接网络.zip)  \n[蓝奏云下载](https://pan.lanzou.com/icrwaja)\n#### 使用步骤：\n1. 将压缩包解压后随便放在哪个位置\n2. 下载安装 `Hackintool` [本地下载](./Hackintool.zip) [蓝奏云下载](https://pan.lanzou.com/id7sqgf)，打开软件点击如图位置1NVRAM，再点击位置2的+号添加两个键值对，如图蓝框，`WiFi-SSID`的值为WiFi名称，`WiFi-PW`的值为WiFi密码（绿框中的WiFi名称、密码是加密过了，按照正常的输就行了，会自动加密成这样的）\n![图片](./pic2.png)\n3. 如图，点击刚才解压缩好的压缩包，运行`install.command`文件\n![图片](./pic3.png)\n4. 按照要求输入Mac密码，重启生效\n\n\n\n\n----------------\n\n\n## 问题汇总：\n1. 小米Pro：运行后，网络中无WiFi图标，也没有连上网\n    - 解决方案：打开clover，移除下图所示文件![图片](./pic4.png)\n","categories":["黑苹果"]},{"title":"C语言 day16","url":"/2020/05/18/C语言-day16/","content":"\n\n\n\n# 结构体\n\n\n## typedef关键字\n> 给已有类型取个别名  \n\n**使用步骤：**\n1. 先用已有类型定义一个变量\n2. 用别名替换变量名\n3. 在整个表达式前添加  `typedef`\n\n<!-- more -->\n\n### 案例1：给int取个别名\n```C\n#if 0\nint arr[5];//第一步\nint ARR_TYPE[5];//第二步\ntypedef int ARR_TYPE[5];//第三步\n\n//结果：\ntypedef int ARR_TYPE[5];\n#endif\n#include<stdio.h>\nint main(int argc,char *argv[]){\n\ttypedef int ARR_TYPE[5];\n    printf(\"sizeof(ARR_TYPE)=%d\\n\",sizeof(ARR_TYPE));//20 ARR_TYPE就是一个有5个int类型的数据的类型名\n\t\n\tARR_TYPE arr={12,13,14,15,16};\n\tint n=sizeof(arr)/sizeof(arr[0]);\n\tint i=0;\n\tfor(i=0;i<n;i++){\n\t\tprintf(\"%d \",arr[i]);\n\t} \n\tprintf(\"\\n\");\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic1.png)  \n\n### 案例3：给指针取个别名\n```C\n#if 0\nint *p;//第一步\nint *P_TYPE;//第二步\ntypedef int *P_TYPE;//第三步\n\n//结果：\ntypedef int *P_TYPE;\n#endif\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    typedef int *P_TYPE;\n    int num=10;\n    P_TYPE p=NULL;\n    p=&num;\n\tprintf(\"num=%d\\n\",*p);\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic2.png)  \n\n\n### 案例4：给函数指针取个别名\n```C\n#include<stdio.h>\nint my_add(int a,int b){\n    return a+b;\n}\nint main(int argc,char *argv[]){\n    int (*p)(int,int)=my_add;\n#if 0\nint (*p)(int,int);//第一步\nint (*FUN_P)(int,int);//第二步\ntypedef int (*FUN_P)(int,int);//第三步\n\n//结果：\nint (*FUN_P)(int,int);\n#endif\n    typedef int (*FUN_P)(int,int);\n    FUN_P p1=my_add;\n\tprintf(\"%3d\\n\",p1(3,4));\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic3.png)  \n\n\n\n-----------------------\n\n\n\n## 给结构体类型取个别名\n\n### 案例5：\n```C\n#include<stdio.h>\nstruct stu{\n\tint num;\n\tchar name[128];\n\tint age; \n};\n#if 0\n//方式1：\ntypedef struct stu STU;\n//方式2： \ntypedef struct stu{\n\tint num;\n\tchar name[128];\n\tint age; \n}STU;//此时stu可以去掉 不去掉也可以\n#endif \ntypedef struct stu STU;\nint main(int argc,char *argv[]){\n\tSTU lucy;\n\tlucy.age=123;\n\tprintf(\"%5d\\n\",lucy.age);\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic4.png)  \n\n\n\n--------------------------\n\n\n\n## 结构体指针\n\n### 案例6：\n```C\n#include<stdio.h>\ntypedef struct stu{\n\tint num;\n\tchar name[128];\n\tint age; \n}STU;\nint main(int argc,char *argv[]){\n\tSTU lucy={100,\"lucy\",18};\n\tSTU *p=&lucy;\n\t\n\t//printf(\"%s\\n\",((char *)p+4));//lucy \n\tprintf(\"num=%d name=%s age=%d\\n\",lucy.num,lucy.name,lucy.age);\n\t//*p=*&lucy=lucy;//即*p等价于lucy \n\tprintf(\"num=%d name=%s age=%d\\n\",(*p).num,(*p).name,(*p).age);//. 的优先级最高 *p要加() \n\tprintf(\"num=%d name=%s age=%d\\n\",p->num,p->name,p->age);\n    return 0;\n}\n\n```\n运行结果：  \n![图片](./pic5.png)  \n\n\n### 案例7：从堆区给结构体申请空间\n\n```C\n#include<stdio.h>\n#include<stdlib.h>\ntypedef struct stu{\n\tint num;\n\tchar name[128];\n\tint age; \n}STU;\nint main(int argc,char *argv[]){\n\tSTU *p=NULL;\n\t//申请空间\n\tp=(STU *)calloc(1,sizeof(STU));\n\t//判断是否申请成功 \n\tif(NULL == p){\n\t\tperror(\"calloc\");\n\t\treturn 0;\n\t} \n\t\n\t//获取键盘输入\n\tprintf(\"请输入一个学生信息：\\n\");\n\tscanf(\"%d%s%d\",&p->num,p->name,&(*p).age);\n\t\n\tprintf(\"num=%d name=%s age=%d\\n\",p->num,p->name,p->age);\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic6.png)  \n\n\n\n\n-----------------------\n\n\n\n## 结构体指针作为函数的参数\n> 一般指针作为函数参数的目的就函数需要修改指针所指向空间的内容\n\n### 案例8：\n```C\n#include<stdio.h>\n#include<string.h>\ntypedef struct stu{\n\tint num;\n\tchar name[128];\n\tint age; \n}STU;\nvoid my_scanf(STU *p){\n\tprintf(\"请输入一个学生信息：\\n\");\n\tscanf(\"%d%s%d\",&p->num,p->name,&p->age);\n\treturn;\n}\nvoid my_printf(STU n){\n//\tprintf(\"num=%d name=%s age=%d\\n\",p->num,p->name,p->age);\n\tprintf(\"num=%d name=%s age=%d\\n\",n.num,n.name,n.age);\t\n\treturn;\n}\nint main(int argc,char *argv[]){\n\tSTU lucy;\n\tmemset(&lucy,0,sizeof(lucy));\n\tSTU *p=&lucy;\n\t//获取键盘输入\n\tmy_scanf(p);\n\t//打印所有值 \n\tmy_printf(lucy);\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic7.png)  \n\n### 案例9：\n> 但是对于结构体无论是否函数需要修改结构体变量的值，我们一般参数都传入指针\n\n> 原因：在32位系统下，指针永远只占4字节，在函数调用时，函数会为形参的指针开辟4字节，但是如果形参不是指针而是一个结构体变量，如果传进来的结构体变量实参非常大，比如200字节，这样就会占用比较大的内存\n\n```C\n#include<stdio.h>\n#include<string.h>\ntypedef struct stu{\n\tint num;\n\tchar name[128];\n\tint age; \n}STU;\nvoid my_scanf(STU *p){\n\tprintf(\"请输入一个学生信息：\\n\");\n\tscanf(\"%d%s%d\",&p->num,p->name,&p->age);\n\treturn;\n}\nvoid my_printf(const STU *p){\n\tprintf(\"num=%d name=%s age=%d\\n\",p->num,p->name,p->age);\t\n\treturn;\n}\nint main(int argc,char *argv[]){\n\tSTU lucy;\n\tmemset(&lucy,0,sizeof(lucy));\n\tSTU *p=&lucy;\n\t//获取键盘输入\n\tmy_scanf(p);\n\t//打印所有值 \n\tmy_printf(p);\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic7.png)  \n\n\n## 从堆区申请一个结构体数组（分函数实现）\n\n### 案例10：\n\n```C\n#include<stdio.h>\n#include<stdlib.h>\ntypedef struct stu{\n\tint num;\n\tchar name[128];\n\tint age; \n}STU;\nSTU *my_apply(int n){\n\treturn (STU *)calloc(n,sizeof(STU));\n}\nvoid my_scanf(int n,STU *p){\n\tint i=0;\n\tfor(i=0;i<n;i++){\n\t\tprintf(\"请输入第%d个学生信息(共%d个):\",i+1,n);\n\t\tscanf(\"%d %s %d\",&(p+i)->num,(p+i)->name,&(p+i)->age); \n\t} \n\treturn;\n}\nvoid my_print(int n,STU *p){\n\tint i=0;\n\tfor(i=0;i<n;i++){\n\t\tprintf(\"第%d个学生信息为：num=%d name=%s age=%d\\n\",i+1,(p+i)->num,(p+i)->name,(p+i)->age);\n\t}\n\tif(p!=NULL){\n\t\tfree(p);\n\t\tp=NULL;\n\t}\n\treturn;\n} \nint main(int argc,char *argv[]){\n\tSTU *arr=NULL;\n\tint n=0;\n\t//申请空间\n\tprintf(\"请输入学生的人数：\\n\");\n\tscanf(\"%d\",&n);\n\tarr=my_apply(n);\n\t\tif(NULL == arr){\n\t\tperror(\"calloc\");\n\t\treturn 0;\n\t}\n\t//获取键盘输入 \n\tmy_scanf(n,arr);\n\t//打印学生成绩\n\tmy_print(n,arr);\n    return 0;\n}\n```\n\n运行结果：  \n![图片](./pic8.png)  \n\n\n### 案例10的一个错误：\n找了两个小时，人都自闭了\n![图片](./pic9.png)  \n\n* 问：上图中函数存在什么问题？\n\n\n* 形参为`STU *p`,但是我们是要赋值给`STU *arr`,我们传参时传的是arr，我们应该传arr的地址才行，也就是形参是二级指针才行`STU **p`\n\n所以`my_apply`要改成这样才行\n![图片](./pic10.png)  \n这时传入的就不是arr了是&arr\n\n> 因此，给指针变量赋值时，一般用的返回值，不然要传入二级指针比较麻烦\n\n**修改好的完整代码：**\n```C\n#define _CRT_SECURE_NO_WARNINGS\n#include<stdio.h>\n#include<stdlib.h>\ntypedef struct stu {\n\tint num;\n\tchar name[128];\n\tint age;\n}STU;\nvoid my_apply(int n, STU **p) {\n\t*p = (STU*)calloc(n, sizeof(STU));\n\tif (NULL == *p) {\n\t\tperror(\"calloc\");\n\t\treturn;\n\t}\n\treturn;\n}\nvoid my_scanf(int n, STU *p) {\n\tint i = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tprintf(\"请输入第%d个学生信息(共%d个):\", i + 1, n);\n\t\tscanf(\"%d %s %d\", &(p + i)->num, (p + i)->name, &(p + i)->age);\n\t}\n\treturn;\n}\nvoid my_print(int n, const STU* p) {\n\tint i = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tprintf(\"第%d个学生信息为：num=%d name=%s age=%d\\n\", i + 1, (p + i)->num, (p + i)->name, (p + i)->age);\n\t}\n\treturn;\n}\nint main(int argc, char* argv[]) {\n\tSTU *arr = NULL;\n\tint n = 0;\n\t//申请空间\n\tprintf(\"请输入学生的人数：\\n\");\n\tscanf(\"%d\", &n);\n\tmy_apply(n, &arr);\n\t//获取键盘输入 \n\tmy_scanf(n, arr);\n\t//打印学生成绩\n\tmy_print(n, arr);\n\treturn 0;\n}\n\n```\n\n","tags":["随记"],"categories":["C语言"]},{"title":"C语言 day15","url":"/2020/05/16/C语言-day15/","content":"\n\n\n# 结构体\n\n1. 结构体数据类型\n2. 结构体变量\n3. 结构体数组\n4. 结构体指针\n5. 结构体内存分配\n6. 结构体位段\n\n\n<!-- more -->\n\n\n## 结构体的定义形式\n\n- 三种方式：  \n![图片](./pic1.png)  \n\n```C\n//struct是结构体体关键字 stu是结构体类型名\n//使用结构体定义变量 必须使用struct stu不能只用一个stu\n//定义结构体类型时，不要给成员赋值（重要）  因为在定义结构体类型的时候，系统并没有给其分配空间，所以不能给成员赋值，只有在用结构体定义变量的时候系统才会给结构体分配空间\nstruct stu{\n    int num;\n    char name[32];\n    int age;\n};//分号别忘了\n\n//结构体中的成员拥有独立的空间\n\n```\n\n\n### 案例1：\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n\tstruct stu{\n\t    int num;//4\n\t    char name[32];//32\n\t    int age;//4\n\t};\n\tprintf(\"%d\\n\",sizeof(struct stu));//将struct stu看成一个int 或者 char 等等等等\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic2.png)  \n\n\n\n\n### 案例2：\n```C\nchar s1[128]=\"hello world!\";\nchar s2[128]=\"\";\ns2=s1;//报错\n//字符数组名是常量不能直接赋值\n```\n\n```C\n#include<stdio.h>\n#include<string.h>\nstruct stu{\n\t    int num;\n\t    char name[32];\n\t    int age;\n\t};\nint main(int argc,char *argv[]){\n\tstruct stu lucy;//lucy是局部变量 lucy的成员内容不确定 \n\tprintf(\"%d\\n\",sizeof(struct stu));\n\tprintf(\"%d\\n\",sizeof(lucy));\n\t//通过结构体变量访问结构体中的成员，一定要遵循成员自身的类型 \n\tprintf(\"%d\\n\",lucy.num);\n\tprintf(\"%s\\n\",lucy.name);\n\tprintf(\"%d\\n\",lucy.age);\n\n\tprintf(\"--------------------\\n\");\n\t//赋值\n\tlucy.num=1234;\n\t//lucy.name=\"小辰\";//报错\n\tstrcpy(lucy.name,\"小辰\");\n\tlucy.age=18;\n\n\tprintf(\"%d\\n\",lucy.num);\n\tprintf(\"%s\\n\",lucy.name);\n\tprintf(\"%d\\n\",lucy.age);\n\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic3.png)  \n\n\n-----------------------\n\n\n\n## 结构体变量的初始化\n- 初始化的顺序 必须和成员的顺序一致\n\n### 案例3：\n```C\n#include<stdio.h>\n#include<string.h>\nstruct stu{\n\t    int num;\n\t    char name[32];\n\t    int age;\n\t};\nint main(int argc,char *argv[]){\n\tstruct stu lucy={1234,\"小辰\",18};\n    printf(\"%d\\n\",lucy.num);\n\tprintf(\"%s\\n\",lucy.name);\n\tprintf(\"%d\\n\",lucy.age);\n    return 0;\n}\n```\n\n运行结果：  \n![图片](./pic4.png)  \n\n\n\n### 案例4：通过memset清空结构体变量\n```C\n#include<stdio.h>\n#include<string.h>\nstruct stu{\n\t    int num;\n\t    char name[32];\n\t    int age;\n\t};\nint main(int argc,char *argv[]){\n\tstruct stu lucy={1234,\"小辰\",18};\n    printf(\"%d\\n\",lucy.num);\n\tprintf(\"%s\\n\",lucy.name);\n\tprintf(\"%d\\n\",lucy.age);\n    memset(&lucy,0,sizeof(lucy));\n    printf(\"%d\\n\",lucy.num);\n\tprintf(\"%s\\n\",lucy.name);\n\tprintf(\"%d\\n\",lucy.age);\n    return 0;\n}\n```\n\n运行结果：  \n![图片](./pic5.png) \n\n\n--------------\n\n\n## 结构体变量获取键盘输入\n\n### 案例5：\n```C\n#include<stdio.h>\n#include<string.h>\nstruct stu{\n\t    int num;\n\t    char name[32];\n\t    int age;\n\t};\nint main(int argc,char *argv[]){\n\tstruct stu lucy={0};\n    memset(&lucy,0,sizeof(lucy));\n\n\tscanf(\"%d %s %d\",&lucy.num,lucy.name,&lucy.age);\n\tprintf(\"%d\\n\",lucy.num);\n\tprintf(\"%s\\n\",lucy.name);\n\tprintf(\"%d\\n\",lucy.age);\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic6.png)  \n\n\n## 结构体变量之间的赋值\n\n### 案例6：\n```C\n#include<stdio.h>\n#include<string.h>\nstruct stu{\n\t    int num;\n\t    char name[32];\n\t    int age;\n\t};\nint main(int argc,char *argv[]){\n\tstruct stu lucy={1234,\"小辰\",18};\n\tstruct stu bob;\n#if 0\n    //方式1：逐个成员赋值\n    bob.num=lucy.num;\n    //bob.name=lucy.name;\n    strcpy(bob.name,lucy.name);\n    bob.age=lucy.age;\n    \n    printf(\"%d %s %d\\n\",bob.num,bob.name,bob.age);\n#endif\n\n#if 0\n    //方式2：相同类型的结构体变量可以直接赋值\n\tbob=lucy;\n\tprintf(\"%d %s %d\\n\",bob.num,bob.name,bob.age);\n#endif\n    //方法3：方法2的底层实现\n\tmemcpy(&bob,&lucy,sizeof(struct stu));\n\tprintf(\"%d %s %d\\n\",bob.num,bob.name,bob.age);\n\t\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic7.png)  \n\n\n\n--------------------\n\n\n\n## 结构体数组\n\n* 本质是数组，只不过是用来存放结构体的数组，每个元素就是一个结构体变量\n\n### 案例7：\n```C\n#include<stdio.h>\n#include<string.h>\nstruct stu{\n\t    int num;\n\t    char name[32];\n\t    int age;\n\t};\nint main(int argc,char *argv[]){\n\tstruct stu arr[3]={\n\t\t{\n\t\t\t100,\n\t\t\t\"小辰\",\n\t\t\t18\n\t\t},\n\t\t{\n\t\t\t101,\n\t\t\t\"小花\",\n\t\t\t19\n\t\t},\n\t\t{\n\t\t\t102,\n\t\t\t\"小明\",\n\t\t\t20 \n\t\t}\n\t};\n\tint n=sizeof(arr)/sizeof(arr[0]);\n\tint i=0;\n\t\n\tfor(i=0;i<n;i++){\n\t\tprintf(\"num=%d name=%s age=%d\\n\",arr[i].num,arr[i].name,arr[i].age);\n\t}\n\t\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic8.png)  \n\n\n### 案例8：结构体获取键盘输入\n```C\n#include<stdio.h>\n#include<string.h>\nstruct stu{\n\t    int num;\n\t    char name[32];\n\t    int age;\n\t};\nint main(int argc,char *argv[]){\n\tstruct stu arr[3];\n\tmemset(arr,0,sizeof(arr));\n\tint n=sizeof(arr)/sizeof(arr[0]);\n\tint i=0;\n\tprintf(\"请输入%d个学生的信息：\\n\",n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %s %d\",&arr[i].num,arr[i].name,&arr[i].age);\n\t}\n\t\n\tfor(i=0;i<n;i++){\n\t\tprintf(\"num=%d name=%s age=%d\\n\",arr[i].num,arr[i].name,arr[i].age);\n\t}\n\t\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic9.png)   ","tags":["随记"],"categories":["C语言"]},{"title":"C语言 day14","url":"/2020/05/16/C语言-day14/","content":"\n\n# const 关键字\n\n\n## 1.const 修饰变量为只读\n\n### 案例 1：\n\n```C\n//const 修饰num为只读变量 num只能取值 不能借助num进行写操作\nconst int num=10;\nprintf(\"num=%d\\n\",num);\n\nnum=100;//报错 [Error] assignment of read-only variable 'num'\n\n```\n\n<!-- more -->\n\n\n### 案例 2：\n\n- 可以通过 num 的地址间接地修改 num 的值，但是地址要强制类型转换.少干，知道可以这样做就行了\n\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n\tconst int num=10;\n\tprintf(\"num=%d\\n\",num);\n\n\t//num=100;//报错\n\n\t//*&num=100;// 报错 &num 为const int *\n\t*(int *)(&num)=100;\n\tprintf(\"num=%d\\n\",num);\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic1.png)  \n\n\n## const int *p\n\n-  `const` 在`*`左边 表示`const`修饰的是`*`而不是`p`\n\n- 效果：用户不能借助`*p`更改空间的内容，但是p可以指向其他空间（`*p`只读 `p`可读可写）\n\n\n### 案例3：\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    int num1=10;\n    int num2=20;\n    const int *p = &num1;\n\n    printf(\"*p=%d\\n\",*p); \n    p=&num2;\n    //*p=100;报错 \n    num2=100; //不能借助*p取修改空间内容 但是变量本身是可以修改的\n    printf(\"*p=%d\\n\",*p);\n    \n    return 0;\n}\n```\n运行结果：  \n![图片](./pic2.png)  \n\n#### > char *strcpy(char *dest,const char *src)\n> `const char *src`的意思就是告诉用户，这个函数不会通过`*src`取修改变量的值\n\n\n\n## int * const p\n\n-  `const` 在`*`的右边修饰p，而不是`*`\n- 效果：用户可以借助`*p`更改空间的内容，但是p不能指向其他空间（`*p`可读可写 `p`只读）\n\n\n### 案例4\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    int num1=10;\n    int num2=20;\n    int * const p = &num1;\n    *p=100; \n    printf(\"*p=%d\\n\",*p); \n    //p=&num2;//报错\n   \n    return 0;\n}\n```\n运行结果：  \n![图片](./pic3.png)  \n\n\n## const int * const p\n\n- 效果：用户不能借助`*p`更改空间的内容，`p`也不能指向其他空间（`*p`只读 `p`只读）\n\n\n\n","tags":["随记"],"categories":["C语言"]},{"title":"C语言 day13","url":"/2020/05/15/C语言-day13/","content":"\n\n\n# 字符串处理\n\n\n## atoi atol atof\n\n### atoi函数\n- 头文件：`#include<stdlib.h>`\n- 函数原型：`int atoi(const char *str)`\n- 函数功能： 把参数 str 所指向的字符串转换为一个int整数\n- 参数：str -- 要转换为整数的字符串。\n- 函数返回值：该函数返回转换后的长整数，如果没有执行有效的转换，则返回零。\n\n<!-- more -->\n\n### atol函数\n- 头文件：`#include<stdlib.h>`\n- 函数原型：`int long atol(const char *str)`\n- 函数功能： 把参数 str 所指向的字符串转换为long int\n- 参数：str -- 要转换为长整数的字符串。\n- 函数返回值：该函数返回转换后的长整数，如果没有执行有效的转换，则返回零。\n\n#### 案例1：\n```C\n#include<stdio.h>\n#include<stdlib.h>\nint main(int argc,char *argv[]){\n\n    printf(\"%d\\n\",atoi(\"123\"));\n    printf(\"%d\\n\",atoi(\"123abc\"));\n    printf(\"%d\\n\",atoi(\"hello\"));//转换失败 返回0\n\tprintf(\"-------------------\\n\");\n    printf(\"%d\\n\",atol(\"123\"));\n    printf(\"%d\\n\",atol(\"123abc\"));\n    printf(\"%d\\n\",atol(\"hello\"));//转换失败 返回0\n\tprintf(\"-------------------\\n\");\n    printf(\"%f\\n\",atof(\"123.32\"));\n    printf(\"%f\\n\",atof(\"123\"));\n    printf(\"%f\\n\",atof(\"123abc\"));\n    printf(\"%f\\n\",atof(\"hello\"));//转换失败 返回0\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic1.png)  \n\n#### 案例2：自己实现一个atoi\n```C\n#include<stdio.h>\n#include<stdlib.h>\nint my_atoi(char *str){\n    int sum=0;\n    while(*str!='\\0'){\n        if(!(*str>='0'&&*str<='9')){\n            return 0;\n        }\n        sum=sum*10+(*str-'0');\n        str++;\n    }\n    return sum;\n}\nint main(int argc,char *argv[]){\n\n    printf(\"%d\\n\",atoi(\"123\"));\n    printf(\"%d\\n\",atoi(\"123abc\"));\n    printf(\"%d\\n\",atoi(\"hello\"));//转换失败 返回0\n    \n    return 0;\n}\n```\n运行结果：  \n![图片](./pic2.png)  \n\n\n\n------------------------\n\n\n\n\n## strtoc函数\n- 头文件：`#include<string.h>`\n- 函数原型：`char *strtok(char *str, const char *delim)`\n- 函数参数：\n    + str -- 要被切割的字符串。\n    + delim -- 分割字符串中包含的所有字符。\n- 返回值：该函数返回被分解的第一个子字符串，如果没有可检索的字符串，则返回一个空指针`NULL`。\n- 注意：不能切割字符串常量，因为他不能被修改\n> 当`strrok()`在参数str的字符串中发现delim中包含的分割字符串时，则会将该字符串更改为`'\\0'`，当连续出现多个时只讲第一个替换为`'\\0'`;\n\n> 在第一次调用时：strtok()必需要给参数str；在第二次到第n次调用时：将str的参数设置为`NULL`,每次调用成功则返回被分割出的片段的指针。\n\n#### 案例3：\n```C\n#include<stdio.h>\n#include<string.h>\nint main(int argc,char *argv[]){\n   char str[]=\"china:beijing:shanghai:wuhan\";\n   char *arr[32]={NULL};\n   int i=0;\n   \n   //第1次切割\n   arr[i]=strtok(str,\":\");\n   \n   //第2~n次切割\n   while(arr[i] != NULL){\n   \t\ti++;\n   \t\tarr[i]=strtok(NULL,\":\");\n   } \n   \n   int j=0;\n   /*for(j=0;j<i;j++){\n   \tprintf(\"%s\\n\",arr[j]);\n   }*/\n   //遍历切割后的内容 \n   while(arr[j]!=NULL){\n   \tprintf(\"%s\\n\",arr[j]);\n   \tj++;\n   }\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic3.png)  \n\n##### 案例3优化1：\n```C\n#include<stdio.h>\n#include<string.h>\nint main(int argc,char *argv[]){\n   char str[]=\"china:beijing:shanghai:wuhan\";\n   char *arr[32]={str,NULL};\n   int i=0;\n   \n   //切割 将两次切割代码合在了一起 \n   while(1){\n   \t\tarr[i]=strtok(arr[i],\":\");\n   \t\tif(arr[i] == NULL){\n   \t\t\tbreak;\n\t\t}\n   \t\ti++;\n   } \n   \n   int j=0;\n   //遍历切割后的内容 \n   while(arr[j]!=NULL){\n   \tprintf(\"%s\\n\",arr[j]);\n   \tj++;\n   }\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic3.png)  \n\n##### 案例3优化2：\n```C\n#include<stdio.h>\n#include<string.h>\nint main(int argc,char *argv[]){\n   char str[]=\"china:beijing:shanghai:wuhan\";\n   char *arr[32]={str,NULL};\n   int i=0;\n   \n   //切割 将两次切割代码合在了一起 \n   /*while(arr[i]=strtok(arr[i],\":\")){\n   \t\ti++;\n   }*/ \n   while(arr[i++]=strtok(arr[i],\":\")); //devC++无法使用这行代码\n   \n   int j=0;\n   //遍历切割后的内容 \n   while(arr[j]!=NULL){\n   \tprintf(\"%s\\n\",arr[j]);\n   \tj++;\n   }\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic3.png)  \n\n### 注意：\n1. 如果要以多个分割符 再delim里面加就行了\n\n#### 案例4：\n```C\n#include<stdio.h>\n#include<string.h>\nint main(int argc,char *argv[]){\n   char str[]=\"china::@@##beijing::::shanghai#@:@#@::wuhan\";\n   char *arr[32]={str,NULL};\n   int i=0;\n   //切割 将两次切割代码合在了一起 \n   /*while(arr[i]=strtok(arr[i],\":@#\")){\n   \t\ti++;\n   }*/ \n   while(arr[i++]=strtok(arr[i],\"::@#\")); //devC++无法使用这行代码\n   \n   int j=0;\n   //遍历切割后的内容 \n   while(arr[j]!=NULL){\n   \tprintf(\"%s\\n\",arr[j]);\n   \tj++;\n   }\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic3.png)  \n\n\n\n-----------------------------\n\n\n\n## sprintf组包\n\n1. printf向终端输出\n2. sprintf向字符串输出\n3. fprintf向文件输出\n\n![图片](./pic4.png)  \n\n- 头文件：`#include<stdio.h>`\n- 函数原型：`int sprintf(char *str, const char *format, ...)`\n- 返回值：如果成功，则返回写入的字符总数，不包括字符串追加在字符串末尾的空字符。如果失败，则返回一个负数。\n\n> 用法、参数、格式化输出等与printf基本相同，只是不是输出在终端而是在，字符串中而已\n\n### 案例4：\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    char str[128]=\"\";\n\tint year=2020;\n\tint mon=5;\n\tint day=15;\n\tsprintf(str,\"%d年%d月%d日\",year,mon,day);\n\tprintf(\"%s\\n\",str); \n    return 0;\n}\n```\n运行结果：  \n![图片](./pic5.png)  \n\n\n\n\n### 案例5：\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    char str[128]=\"\";\n\tchar name[]=\"小花\";\n\tint age=18;\n\tchar sex[]=\"女\"; \n\tchar addr[]=\"湖北省武汉市\";\n\tsprintf(str,\"名字：%s \\n性别：%s \\n年龄：%d \\n地址：%s\",name,sex,age,addr);\n\tprintf(\"%s\\n\",str); \n    return 0;\n}\n```\n运行结果：  \n![图片](./pic6.png)\n\n\n\n\n### 特殊的用法：利用sprintf将数字转换成字符串\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    int num=12345;\n    char str[128]=\"\";\n    sprintf(str,\"%d\",num);\n\tprintf(\"%s\\n\",str); \n    return 0;\n}\n```\n运行结果：  \n![图片](./pic7.png)  \n\n\n\n----------------\n\n\n\n## sscanf解包\n\n1. printf从终端中获取输入\n2. sprintf从字符串中获取输入\n3. fprintf从文件中获取输入\n\n![图片](./pic8.png)  \n\n- 头文件：`#include<stdio.h>`\n- 函数原型：`int sscanf(const char *str, const char *format, ...))`\n- 返回值：如果成功，该函数返回成功匹配和赋值的个数。如果到达文件末尾或发生读错误，则返回 EOF。\n\n> 用法、参数、格式化输出等与scanf基本相同，只是不是输出在终端而是在，字符串中而已\n\n### 案例6：\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    char str[]=\"2020年5月15日\";\n\tint year=0;\n\tint mon=0;\n\tint day=0;\n\t\n\tsscanf(str,\"%d年%d月%d日\",&year,&mon,&day);\n\t\n\tprintf(\"year=%d mon=%d day=%d\",year,mon,day);\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic9.png)  \n\n> 注意%s获取输入时 遇到空格、回车、'\\0' 停止获取，与scanf类似\n\n### 案例7：\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    char str[]=\"2020年5月15日\";\n\tchar year[128]=\"\";\n\tchar mon[128]=\"\";\n\tchar day[128]=\"\";\n\t\n\tsscanf(str,\"%s年%s月%s日\",year,mon,day);\n\t\n\tprintf(\"year=%s mon=%s day=%s\",year,mon,day);\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic10.png)  \n\n分析：  \n第一个%s将全部字符都获取到了，后面的两个%s就没有字符获取了\n\n\n### sscanf高级用法：\n#### 1. 使用%*s、%*d...跳过提取内容\n\n#### 案例8：请取出5678，且不要取1234\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    int num=0;\n\t//sscanf(\"1234 5678\",\"%*d%d\",&num);\n\tsscanf(\"1234 5678\",\"%*d %d\",&num);\n\t//sscanf(\"1234 5678\",\"%*s %d\",&num);\n\tprintf(\"num=%d\",num);\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic11.png)  \n\n\n#### 2. 使用%[n]s、%[n]d...跳过指定宽度n的字符串或数据（[]的意思是说n是变化的不是真的要写[]）\n\n#### 案例9：请取出4567，且不要取123abc\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    int num=0;\n\t\n\t//sscanf(\"123ab4567\",\"%*5s%d\",&num);\n\tsscanf(\"123ab4567\",\"%*3d%*2s%d\",&num);\n\tprintf(\"num=%d\",num);\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic12.png)  \n\n\n#### 2. 集合操作\n\n1. 使用 `%[a-z]` 提取a-z的字符串\n    - 注意：只要遇到 `%[]` 都是按字符串提取\n    - 当遇到不符合其格式的就会停止提取\n\n\n#### 案例9：\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n\tchar str1[]=\"abcDeFg\";\n\tchar str2[128]=\"\";\n\t\n\tsscanf(str1,\"%[a-z]\",str2);\n\tprintf(\"%s\\n\",str2); //当遇到不符合其格式的就会停止提取 所以不是输出abceg\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic13.png)  \n\n\n\n\n\n2. 使用 `%[bCe]` 匹配b、C、e\n\n\n#### 案例10：\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n\tchar str1[]=\"bbCCebCabCe\";\n\tchar str2[128]=\"\";\n\t\n\tsscanf(str1,\"%[bCe]\",str2);//当遇到'a'是不是b、C、e停止获取\n\tprintf(\"%s\\n\",str2); \n    return 0;\n}\n```\n运行结果：  \n![图片](./pic14.png)  \n\n\n\n\n\n3. 使用`%[^abc]`，只要不是a、b、c都获取\n\n#### 案例11：\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n\tchar str1[]=\"hello world! Caeu\";\n\tchar str2[128]=\"\";\n\t\n\tsscanf(str1,\"%[^aCu]\",str2);\n\tprintf(\"##%s##\\n\",str2); //当遇到a、C、u时停止获取\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic15.png)  \n\n\n\n\n### > 拓展案例：歌词解析\n\n![图片](./20200318212116717.png)  \n\n\n\n* 题目：请提取出msg中的时、分和歌词\n\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n\tchar msg[]=\"[00:26.44]说不上为什么我变得很主动\";\n    int min=0,sec=0;\n    char lrc[128]=\"\";\n\n    sscanf(msg,\"[%d:%d%*3s]%s\",&min,&sec,lrc);\n    printf(\"min=%d sec=%d lrc=%s\\n\",min,sec,lrc);\n    return 0;\n}\n```\n\n运行结果：  \n![图片](./pic16.png)  \n\n","tags":["随记"],"categories":["C语言"]},{"title":"C语言 day12","url":"/2020/05/14/C语言-day12/","content":"\n\n\n# 字符串处理\n\n1. 测字符串长度函数\n2. 字符串拷贝函数\n3. 格式化字符串操作函数\n4. `const` 关键字\n\n\n<!-- more -->\n\n\n> 对字符串的处理，在嵌入式编程、应用编程、网络编程中会有大量的使用\n\n> 字符串的拷贝、连接、比较、切割、变换...\n\n> 要求熟练使用常见字符串处理函数，并且会自己编写典型的字符串操作函数\n\n\n\n## 字符串操作函数\n\n```C\n头文件：#include<string.h>\n1、strlen //长度测量函数\n2、strcpy/strncpy //字符串拷贝\n3、strcat/strncat //字符串拼接\n4、strcmp/strncmp //字符串比较\n```\n\n> 注意：只要是 str 开头的函数，都是遇到 `'\\0'` 结束\n\n----------------\n\n## strlen 函数\n\n- 函数原型：`unsigned int strlen(const char *str);`\n- 函数功能：测量字符串的长度，不包含`'\\0'`\n- 函数参数：存放字符串的内存空间的`首地址`\n- 注意：遇到`'\\0'`结束测量\n\n### 案例 1：请说出下面代码的运行结果\n\n```C\n#include<stdio.h>\n#include<string.h>\nint main(int argc,char *argv[]){\n    char str1[128]=\"hello\";\n    char str2[]=\"hello\";\n    char str3[]=\"hel\\0lo\";\n    char str4[]=\"hel\\123\\\\lo\";//八进制转义 \\hhh h:0~7\n    char str5[]=\"hel\\x2flo\";//十六进制转义 \\xdd d:0~9~a~f\n    char str6[]=\"\\0he\\0llo\";\n\n    printf(\"%d\\n\",sizeof(str1));\n    printf(\"%d\\n\",strlen(str1));\n\n    printf(\"%d\\n\",sizeof(str2));\n    printf(\"%d\\n\",strlen(str2));\n\n    printf(\"%d\\n\",sizeof(str3));\n    printf(\"%d\\n\",strlen(str3));\n\n    printf(\"%d\\n\",sizeof(str4));\n    printf(\"%d\\n\",strlen(str4));\n    printf(\"%s\\n\",str4);\n\n    printf(\"%d\\n\",sizeof(str5));\n    printf(\"%d\\n\",strlen(str5));\n    printf(\"%s\\n\",str5);\n\n    printf(\"%d\\n\",sizeof(str6));\n    printf(\"%d\\n\",strlen(str6));//不要认为测量的长度为0，字符串就真的没有内容了\n    return 0;\n}\n```\n\n运行结果：  \n![图片](./pic1.png)\n\n分析：  \n第 9、10 行，因为定义的数组元素个数为 128，为 char 类型，所以占的字节数为 128，但是 str1 中的字符串为`hello`只有 5 个字符，所以打印的分别是 128、5；  \n第 12、13 行，因为数组的长度没有定义，数组的长度有初始化的元素个数决定，然而字符串`hello`实际上最后面系统会自动添加一个`'\\0'`,所以共有 6 个元素，而字符串的长度为 5，因此打印分别为 6、5；  \n第 15、16 行，数组长度没有定义，有初始化元素个数决定，而`\"hel\\0lo\"`系统在末尾会添加一个`'\\0'`，所以数组总元素个数为 7，而`hel`后面有个`\\0`,strlen 函数遇到`\\0`就会结束，所以测量出的长度为 3；  \n第 18,19 行，`'\\123'`代表一个字符，`'\\\\'`为一个`'\\'`\n\n#### 作业：自定义一个 my_strlen 函数测量字符串的长度\n\n```C\nint my_strlen(const char *s);\n```\n\n\n\n----------------\n\n\n\n\n## 字符串拷贝函数 strcpy/strncpy\n\n### strcpy 函数\n\n- 函数原型：`char *strcpy(char *dest,const char *src);`\n- 函数功能：把 src 所指向的字符串复制到 dest 所指向的空间中\n- 返回值：返回 dest 字符串的首地址\n- 注意：遇到`\\0`会结束拷贝，但是`\\0`也会被拷贝过去\n\n#### 案例 2：\n\n```C\n#include<stdio.h>\n#include<string.h>\nint main(int argc,char *argv[]){\n    char src1[] = \"hello world\";\n    char dest1[128]=\"\";//要保证dest足够大\n    char src2[] = \"hello\\0 wo\\0rld\";\n    char dest2[128]=\"\";\n    char src3[] = \"\\0hello world\";\n    char dest3[128]=\"\";\n\n    strcpy(dest1,src1);\n    strcpy(dest2,src2);\n    strcpy(dest3,src3);\n\n    printf(\"%s\\n\",dest1);\n    printf(\"%s\\n\",dest2);\n    printf(\"##%s##\\n\",dest3);\n    return 0;\n}\n```\n\n运行结果：  \n![图片](./pic2.png)\n\n#### 案例 3：自己实现一个 strcpy\n\n```C\n#include<stdio.h>\n#include<string.h>\nchar *my_strcpy(char *dest,const char *src){\n\n    while(*src!='\\0'){\n        *dest=*src;\n        src++;\n        dest++;\n    }\n    *dest='\\0';\n\n    //优化\n    //while(*dest++=*src++);\n}\nint main(int argc,char *argv[]){\n    char src1[] = \"hello world\";\n    char dest1[128]=\"\";\n    char src3[] = \"\\0hello world\";\n    char dest3[128]=\"\";\n\n    my_strcpy(dest1,src1);\n    my_strcpy(dest3,src3);\n\n    printf(\"%s\\n\",dest1);\n    printf(\"##%s##\\n\",dest3);\n    return 0;\n}\n```\n\n运行结果：  \n![图片](./pic3.png)  \n\n### strncpy 函数\n\n- 函数原型：`char *strncpy(char *dest,const char *src,int num);`\n- 函数功能：把 src 所指向的字符串的前 num 个复制到 dest 所指向的空间中\n- 返回值：返回 dest 字符串的首地址\n- 注意：`\\0`不会被拷贝过去,但是遇到`\\0`结束\n> 复制多少由num的值决定。如果src的前n个字符不含NULL字符，则结果不会以NULL字符结束。如果`n<src`的长度，只是将src的前n个字符复制到dest的前n个字符，不自动添加'\\0'，也就是结果dest不包括'\\0'，需要再手动添加一个'\\0'。如果src的长度小于n个字节，则以NULL填充dest直到复制完n个字节。\n\n#### 案例4：\n```C\n#include<stdio.h>\n#include<string.h>\nint main(int argc,char *argv[]){\n    char src[]=\"hello world\";\n    char dest[128]=\"\";\n\n    strncpy(dest,src,3);\n    printf(\"%s\",dest);\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic4.png)  \n\n\n\n---------------------\n\n\n\n\n## strcat 函数 字符串拼接\n\n- 函数原型：`char *strncat(char *dest,const char *src);`\n- 函数功能：把 src 所指向的字符串拼接到到 dest 所指向的字符串的末尾（第一个`\\0`后面）\n\n\n### 案例5：\n```C\n#include<stdio.h>\n#include<string.h>\nint main(int argc,char *argv[]){\n    char s1[128]=\"hello\";\n    char s2[128]=\"world\";\n    \n    char a1[128]=\"hel\\0lo\";\n    char a2[128]=\"world\";\n    \n    char c1[128]=\"hello\";\n    char c2[128]=\"wor\\0ld\";\n\n    strcat(s1,s2);\n    strcat(a1,a2);\n    strcat(c1,c2);\n    printf(\"%s\\n\",s1);\n    printf(\"%s\\n\",s2);\n    \n    printf(\"%s\\n\",a1);//并不是拼接成这样hel\\0loworld然后只输出hel而是拼接成helworld \n    printf(\"%s\\n\",a2);\n    \n    printf(\"%s\\n\",c1);\n    printf(\"%s\\n\",c2);\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic5.png)  \n\n\n\n\n#### 作业：自定义my_strcat函数\n\n\n\n------------------\n\n\n\n## strcmp/strncmp 字符串比较函数\n\n\n### strcmp 函数 （整个字符串比较）\n- 函数原型：`int strcmp(const char *s1,const char *s2);`\n- 函数功能：将s1、s2指向的字符串，逐个字符比较（ASCII码）\n- 返回值：\n    * `>0` 表示`s1>s2`;\n    * `<0` 表示`s1<s2`;\n    * `=0` 表示`s1=s2`;\n- 两个字符串自左向右逐个字符相比（按ASCII值大小相比较），直到出现不同的字符或遇'\\0'为止\n#### 案例6：\n```C\n#include<stdio.h>\n#include<string.h>\nint main(int argc,char *argv[]){\n    char s1[128]=\"aaahello\";\n    char s2[128]=\"aaaworld\";\n    int res=0;\n    \n\tres=strcmp(s1,s2);\n\t\n\tif(res>0){\n\t\tprintf(\"s1>s2\");\n\t}else if(res<0){\n\t\tprintf(\"s1<s2\");\n\t}else if(res == 0){\n\t\tprintf(\"s1==s2\");\n\t}\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic6.png)  \n\n#### 问题：如果两个字符串的长度不相等会发生什么？\n\n### strncmp 函数 （局部字符串比较）\n- 函数原型：`int strcmp(const char *s1,const char *s2,unsigned int num);`\n- 函数功能：将s1、s2指向的字符串的前num个，逐个字符比较（ASCII码）\n- 返回值：\n    * `>0` 表示`s1>s2`;\n    * `<0` 表示`s1<s2`;\n    * `=0` 表示`s1=s2`;\n\n#### 案例7：\n```C\n#include<stdio.h>\n#include<string.h>\nint main(int argc,char *argv[]){\n    char s1[128]=\"aaahello\";\n    char s2[128]=\"aaaworld\";\n    int res=0;\n    \n\t// res=strncmp(s1,s2,4);//小于0\n\tres=strncmp(s1,s2,3);//==0\n\t\n\tif(res>0){\n\t\tprintf(\"s1>s2\");\n\t}else if(res<0){\n\t\tprintf(\"s1<s2\");\n\t}else if(res == 0){\n\t\tprintf(\"s1==s2\");\n\t}\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic7.png)  \n\n\n\n----------------------\n\n\n\n## strchr 函数\n\n- 函数原型：`char *strchr(const char *str, int c);`\n- 功能：在参数str所指向的字符串中搜索第一次出现字符c（一个无符号字符）的位置（地址）。\n- 返回值：该函数返回在字符串 str 中第一次出现字符 c 的位置(地址)，如果未找到该字符则返回 NULL。\n\n#### 案例8：将str中所有的o替换成*\n```C\n#include<stdio.h>\n#include<string.h>\nint main(int argc, char* argv[]) {\n    char str[] = \"www.yuencode.cn\";\n    char *res = NULL;\n\n    while (1) {\n        res = strchr(str, 'o');\n        if (res == NULL) {\n            break;\n        }\n        *res = '*';\n    }\n    // printf(\"%p\\n\",res);//返回值为位置（地址）\n    printf(\"%s\\n\", str);\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic8.png)  \n\n\n\n-----------------------\n\n\n\n## strstr函数\n\n- 函数原型：`char *strstr(const char *haystack, const char *needle)`\n- 函数参数：\n    + haystack -- 要被检索的 C 字符串。\n    + needle -- 在 haystack 字符串内要搜索的小字符串。\n- 返回值：该函数返回在 haystack 中第一次出现 needle 字符串的位置，如果未找到则返回 NULL。\n\n#### 案例9：将str中所有的cnm替换成*\n```C\n#include<stdio.h>\n#include<string.h>\nint main(int argc, char* argv[]) {\n    char str[] = \"www.yucnmencode.ccnmn\";\n    char *res = NULL;\n\tint i=0;\n    while (1) {\n        res = strstr(str, \"cnm\");\n        if (res == NULL) {\n            break;\n        }\n        //for(i=0;i<strlen(\"cnm\");i++){\n        //  *(res+i) = '*';\n        //} \n\t\tmemset(res,'*',strlen(\"cnm\"));\n    }\n    printf(\"%s\\n\", str);\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic8.png)  \n\n\n\n---------------------\n\n\n\n## memset函数\n\n- 函数原型：`void *memset(void *str, int c, size_t n)`\n- 参数：\n    + str -- 指向要填充的内存块。\n    + c -- 要被设置的值。该值以 int 形式传递，但是函数在填充内存块时是使用该值的无符号字符形式。\n    + n -- 要被设置为该值的字节数。\n- 返回值：该值返回一个指向存储区 str 的指针。\n\n\n\n\n----------------------\n\n\n","tags":["随记"],"categories":["C语言"]},{"title":"C语言 day11","url":"/2020/05/13/C语言-day11/","content":"\n\n\n# 动态内存申请\n\n1. 动态内存申请的相关概念\n2. 静态分配和动态分配\n3. 动态内存申请相关函数\n4. 内存泄漏\n\n\n<!-- more -->\n\n\n## 动态内存申请的相关概念\n\n1. 在数组一章中，介绍过数组的长度是预先定义好的，在整个程序中固定不变\n2. 但是在实际的编程中，往往会发生这种情况，即所需的内存空间取决于实际输入的数据，而无法预先确定\n3. 为了解决上诉问题，C语言提供了一些内存管理函数，这些内存管理函数可以按需要动态的分配内存空间，也可以把不在使用的空间回收再次利用\n\n----------------------\n\n## 静态分配和动态分配\n\n### 静态分配\n\n1. 在程序编译或运行过程中，按事先规定大小分配内存空间的分配方式\n2. 必须事先知道所需空间的大小\n3. 分配在栈区或全局变量区,一般以数组形式\n4. 按计划分配\n\n### 动态分配\n\n1. 在程序运行过程中，根据需要大小自由分配所需空间\n2. 按需分配\n3. 分配在堆区，一般使用特定的函数进行分配\n\n\n-----------------------\n\n\n## 动态内存申请相关函数\n\n### 1、分配内存空间的函数 `malloc`\n\n* 头文件：`#include<stdlib.h>`\n* 函数原型：void *malloc(unsigned int num_bytes); ------> (返回值void *)\n* 调用形式：(类型说明符*) malloc (size); ------> (类型说明符*)进行强制类型转换\n\n* 功能说明：\n    1. 在内存的动态储存区（堆区）中分配一块长度为size字节的连续区域用来存放类型说明符指定的类型\n    2. 函数原型返回`void*`指针，使用时必须做相应的强制类型转换\n    3. 分配的内存空间内容不确定，一般使用`menset`初始化\n\n* 返回值：\n    + 分配空间的起始地址（分配成功）\n    + NULL（分配失败）\n\n* 注意：\n    1. 在调用malloc之后，一定要判断一下，是否申请内存成功\n    2. 如果多次malloc申请内存，每次申请的内存之间不一定是连续的，但是每个内存内部肯定是连续的\n\n### 2、free函数（释放内存函数）\n\n* 头文件：`#include<stdlib.h>`\n* 函数定义：`void free(void *ptr);`\n* 函数说明：`free`函数释放`ptr`指向的内存\n* 注意：ptr指向的内存必须是`malloc calloc relloc`动态申请的内存，只能释放堆区空间\n\n\n#### 案例1：申请一个int变量的空间\n```C\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nint main(int argc,char *argv[]){\n\n    //定义一个变量去接申请好的空间的首地址\n    int *addr=NULL;\n\n    //申请一个int变量空间\n    addr = (int *)malloc(sizeof(int));//sizeof(int)兼容作用，不同平台int字节数可能不同\n\n    //判断是否申请成功\n    if(NULL == addr){\n        printf(\"malloc err\\n\");\n        return 0;\n    }\n\n    printf(\"%d\\n\",*addr);//值不确定，要进行清0\n\n    //清空\n    memset(addr,0,sizeof(int));//#include<string.h> 不加这个，可能会报隐形声明的警告\n\n    printf(\"%d\\n\",*addr);//值为0\n\n    //写\n    *addr=1000;\n\n    //读\n    printf(\"%d\\n\",*addr);//1000\n\n    //释放堆区空间\n    free(addr);\n    return 0;\n}\n\n```\n运行结果：  \n![图片](./pic1.png)  \n\n#### 案例2：从堆区申请一个int数组，数组大小由用户决定\n\n```C\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nint main(int argc,char *argv[]){\n    //获取数组元素个数\n    int n=0;\n    printf(\"请输入数组元素个数：\\n\");\n    scanf(\"%d\",&n);\n\n    //申请内存空间\n    int *arr=(int *)malloc(n*sizeof(int));\n    if(NULL == arr){\n        perror(\"malloc\");\n        return 0;\n    }\n\n    //清0\n    memset(arr,0,n*sizeof(int));\n\n    //键盘获取元素\n    int i=0;\n    printf(\"请输入%d个int型数据：\\n\",n);\n    for(i=0;i<n;i++){\n        scanf(\"%d\",arr+i);\n    }\n\n    //输出获取的元素\n    for(i=0;i<n;i++){\n        // printf(\"%d \",*(arr+i));\n        printf(\"%d \",arr[i]);\n    }\n    printf(\"\\n\");\n\n    //释放堆区空间\n    free(arr);\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic2.png)  \n\n\n\n### 3、calloc函数\n* 头文件：`#include<stdlib.h>`\n* 函数原型：`void * calloc(size_t nmenb,size_t size);`\n* 功能说明：在内存的堆中，申请`nmemb`块。每块大小为`size`个字节的连续区域\n* 函数参数：`size_t`实际是无符号整型，它是在头文件中，用`typedef`定义出来的\n* 返回值：\n    + 成功：返回申请的内存的首地址\n    + 失败 返回`NULL`\n* 例如：char *p = (char *)calloc(3,100)\n* 特点：calloc函数申请的内存中的内容为0，自动清零；而malloc申请的内存中的内容随机的，不确定的\n\n#### 案例3：案例2改造\n\n```C\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nint main(int argc,char *argv[]){\n    //获取数组元素个数\n    int n=0;\n    printf(\"请输入数组元素个数：\\n\");\n    scanf(\"%d\",&n);\n\n    //申请内存空间\n    int *arr=(int *)calloc(n,sizeof(int));\n    if(NULL == arr){\n        perror(\"malloc\");\n        return 0;\n    }\n\n    \n\n    //键盘获取元素\n    int i=0;\n    printf(\"请输入%d个int型数据：\\n\",n);\n    for(i=0;i<n;i++){\n        scanf(\"%d\",arr+i);\n    }\n\n    //输出获取的元素\n    for(i=0;i<n;i++){\n        // printf(\"%d \",*(arr+i));\n        printf(\"%d \",arr[i]);\n    }\n    printf(\"\\n\");\n\n    //释放堆区空间\n    free(arr);\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic3.png)  \n\n\n\n\n### 4、realloc函数\n> 动态追加或减少空间\n\n* 头文件：`#include<stdlib.h>`\n* 函数原型：`void * realloc(void *s,unsigned int newsize);`\n* 功能说明：在原先s指向的内存基础上重新申请内存，新的内存大小为new_sizeof个字节（包含原先的内存大小！！），如果原先内存后面有足够大的空间，就追加，返回的内存地址还是跟原先的一样的；如果后面的内存不够用，则realloc函数会在堆区找一个new_size个字节的内存申请，将原先内存中的内容拷贝过来，然后释放原先的内存，最后返回新的内存地址\n* 函数参数：`size_t`实际是无符号整型，它是在头文件中，用`typedef`定义出来的\n* 返回值：新申请的内存的首地址\n\n\n#### 案例4：改造案例3\n```C\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nint main(int argc,char *argv[]){\n    //获取数组元素个数\n    int n=0;\n    printf(\"请输入数组元素个数：\\n\");\n    scanf(\"%d\",&n);\n\n    //申请内存空间\n    int *arr=(int *)calloc(n,sizeof(int));\n    if(NULL == arr){\n        perror(\"malloc\");\n        return 0;\n    }\n\n    \n\n    //键盘获取元素\n    int i=0;\n    printf(\"请输入%d个int型数据：\\n\",n);\n    for(i=0;i<n;i++){\n        scanf(\"%d\",arr+i);\n    }\n\n    //输出获取的元素\n    for(i=0;i<n;i++){\n        // printf(\"%d \",*(arr+i));\n        printf(\"%d \",arr[i]);\n    }\n    printf(\"\\n\");\n\n    // 追加元素\n    int new_size=0;\n    printf(\"请输入追加元素的个数：\\n\");\n    scanf(\"%d\",&new_size);\n\n    arr=realloc(arr,(n+new_size)*sizeof(int));\n    /*\n    一定要接一下返回值，因为\n    如果后面的内存不够用，则realloc函数会在堆区找一个new_size个字节的内存申请，将原先内存中的内容拷贝过来，然后释放原先的内存，最后返回新的内存地址\n    */\n\n    //获取新追加的元素\n    printf(\"请输入追加的%d个元素：\\n\",new_size);\n    for(i=n;i<new_size+n;i++){\n        scanf(\"%d\",arr+i);\n    }\n\n    //输出所有的元素\n    for(i=0;i<n+new_size;i++){\n        // printf(\"%d \",*(arr+i));\n        printf(\"%d \",arr[i]);\n    }\n    printf(\"\\n\");\n\n\n    //释放堆区空间\n    free(arr);\n    return 0;\n}\n```\n运行结果：  \n1. 增加元素  \n\n![图片](./pic4.png)  \n\n2. 减少元素  \n\n![图片](./pic4-1.png)  \n\n\n\n\n--------------\n\n\n\n## 堆区空间使用的注意事项\n1. 指向堆区空间的指向变量，不要随意的更改指向，会造成堆区空间无法释放，造成内存泄漏\n\n2. 不要操作已经释放了的空间，内容是不确定的\n\n3. 不要对堆区空间重复释放.运行时,程序会直接终止\n\n### 防止多次释放的方法（坚持使用这种方式）\n```C\nint *p = (int *)calloc(1,sizeof(int));\n\n// free(p);\n// free(p);\nif(p != NULL){\n    free(p);\n    p=NULL;\n}\nif(p != NULL){\n    free(p);\n    p=NULL;\n}\n```\n\n\n\n---------------\n\n\n## 内存泄漏\n\n内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。","tags":["随记"],"categories":["C语言"]},{"title":"C语言 day10","url":"/2020/05/12/C语言-day10/","content":"\n\n# 数组\n\n## 二维数组的分析(了解)\n\n### 案例 1：\n\n```C\n    int arr[3][4];\n    /*\n    二维数组名：代表的是二维数组的首行地址，+1跳过一行\n    对行地址取 `*` 将变成当前行的第0列的列地址`arr[0]=*(arr+0)=*arr`  `arr[1]=*(arr+1)`\n    */\n\n    //例如取出第二行第三列的元素\n    printf(\"%d\",*(*(arr+1)+2));\n    // *(*(arr+1)+2)=*(arr[1]+2)=arr[1][2]这就是计算机的方式\n```\n\n<!-- more -->\n\n> 二维数组名：代表的是二维数组的首行地址，+1 跳过一行\n> 对行地址取 `*` 将变成当前行的第 0 列的列地址`arr[0]=*(arr+0)=*arr` `arr[1]=*(arr+1)`\n\n### 案例 2：说出下面分别代表的是啥？\n\n```C\n    int arr[3][4];\n\n    *arr+2;//第0行第2列的列地址\n    arr[1];//*(arr+1)第1行第0列的列地址\n    &arr[0]+2;//&*(arr+0)+2=arr+2;第2列的行地址\n    **arr;//第0行第0列的元素*(*(arr+0)+0)=arr[0][0]\n```\n\n---\n\n## 数组指针与二维数组的关系\n\n### 案例 1：定义一个指针变量，保存二维数组的行地址\n\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    int arr[3][4];\n\n    //数组指针\n    int (*p)[4];//注意：不加()p会先与[]结合这样就不是数组指针了，就变成了指针数组了\n    p=arr;//p跟arr完全等价，p+1=arr+1跳过一行\n    return 0;\n}\n```\n\n### 案例 2：\n\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    int arr[3][4]={{1,2,3,4},{5,6,7,8},{9,10,11,12}};\n    int (*p)[4]=arr;\n    int i=0,j=0;\n    printf(\"%d\\n\",sizeof(p));//4 抓住本质，本质就是一个指针变量\n\n    for(i=0;i<3;i++){\n        for(j=0;j<4;j++){\n            // printf(\"%d \",*(*(p+i)+j));\n            printf(\"%d \",p[i][j]);//p完全等价于arr\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n```\n\n运行结果：  \n![图片](./pic2.png)\n\n---\n\n## 任何维度数组，在物理存储上都是一维的\n\n> 我们可以通过一维来访问多维数组,因为内存条是一维的，地址是连续的\n\n### 案例 1：\n\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    int arr[3][4]={{1,2,3,4},{5,6,7,8},{9,10,11,12}};\n    //int *p=*arr;\n    int *p=&arr[0][0];\n    int i=0;\n\n    for(i=0;i<3*4;i++){\n        printf(\"%d \",*(p+i));\n    }\n    printf(\"\\n\");\n    for(i=0;i<3*4;i++){\n        printf(\"%d \",p[i]);\n    }\n\n    return 0;\n}\n```\n\n运行结果：  \n![图片](./pic3.png)\n\n---\n\n## 多级指针\n\n1 级指针 保存 0 级指针变量的地址(普通变量)  \n2 级指针 保存 1 级指针变量的地址  \n3 级指针 保存 2 级指针变量的地址  \n····  \nn 级指针 保存 n-1 级指针变量的地址\n\n![图片](./pic4.png)\n\n---\n\n## 指针作为函数的参数\n\n1. 如果想要在函数内部，修改函数外部变量的值，就需要将函数外部变量的地址，传递给函数(以指针变量作为函数的参数) `【重要重要重要！！！】`\n\n2. 一维数组，作为函数的形参会被优化成指针变量\n\n### 引入：\n\n#### 案例 1：\n\n```C\n#include<stdio.h>\nvoid my_swap(int a,int b){\n    printf(\"a=%d\\n\",a);\n    printf(\"b=%d\\n\",b);\n    int temp=0;\n    temp=a;\n    a=b;\n    b=temp;\n    printf(\"a=%d\\n\",a);\n    printf(\"b=%d\\n\",b);\n    return;\n}\nint main(int argc,char *argv[]){\n    int data1=4,data2=5;\n    my_swap(data1,data2);\n\n    printf(\"data1=%d\\n\",data1);\n    printf(\"data2=%d\\n\",data2);\n    return 0;\n}\n```\n\n运行结果：  \n![图片](./pic5.png)\n\n分析：  \n`data1,data2`之间的值并未被交换，然而`a,b`的值交换成功了；因为当函数调用的时候，系统给形参分配内存空间，通过传参将实参传给了局部变量形参，在函数里面操作的只是形参`a,b`；并不是`data1，data2`\n\n解决方法：要解决上面的问题，就要给函数传入`data1,data2`变量的地址\n\n#### 解决方案：\n\n```C\n#include<stdio.h>\nvoid my_swap(int *a,int *b){\n    printf(\"a=%d\\n\",*a);\n    printf(\"b=%d\\n\",*b);\n    int temp=0;\n    temp=*a;\n    *a=*b;\n    *b=temp;\n    printf(\"a=%d\\n\",*a);\n    printf(\"b=%d\\n\",*b);\n    return;\n}\nint main(int argc,char *argv[]){\n    int data1=4,data2=5;\n    my_swap(&data1,&data2);\n\n    printf(\"data1=%d\\n\",data1);\n    printf(\"data2=%d\\n\",data2);\n    return 0;\n}\n```\n\n运行结果：  \n![图片](./pic6.png)\n\n分析：交换成功！\n\n### 案例 2：在函数内部更改 p 的指向\n\n```C\n#include<stdio.h>\nvoid my_set(int **tem_p){\n    //注意形参是二级指针，用一级指针也没问题，但是类型不匹配会有警告，最好不要这样干\n    static int num=100;\n    *tem_p=&num;\n}\n\nint main(int argc,char *argv[]){\n\n    int *p=NULL;\n\n    my_set(&p);\n    printf(\"%d\\n\",*p);\n    return 0;\n}\n\n```\n\n## 一维数组名作为函数的参数\n\n### 1. 如果函数内部想要操作（读、写）外部数组的元素，请将外部数组的数组名传递给函数\n\n### 案例 1：为什么同样的数组总大小不一样？\n\n```C\n#include<stdio.h>\nvoid my_input_array(int arr[5],int n){\n    printf(\"B:%d\\n\",sizeof(arr));\n}\nint main(int argc,char *argv[]){\n\n    int arr[5]={0};\n    printf(\"A:%d\\n\",sizeof(arr));\n    return 0;\n}\n```\n\n运行结果：  \n![图片](./pic7.png)\n\n分析：因为系统会自动把`void my_input_array(int arr[5],int n){`优化为`void my_input_array(int *arr,int n){`,所以`B:4`输出的是指针的字节数 4.\n\n> 一维数组，作为函数的形参会被优化成指针变量\n\n### 案例 2：\n\n```C\n#include<stdio.h>\nvoid my_input_array(int arr[5],int n){\n    int i=0;\n    printf(\"请输入5个int类型数据：\\n\");\n    for(i=0;i<n;i++){\n        // scanf(\"%d\",&*(arr+i));\n        // scanf(\"%d\",&arr[i]);\n        scanf(\"%d\",arr+i);\n    }\n}\nvoid my_printf_array(int arr[5],int n){\n    int i=0;\n    for(i=0;i<n;i++){\n        printf(\"%d \",arr[i]);\n        printf(\"%d\\n\",*(arr+i));\n\t}\n}\nint main(int argc,char *argv[]){\n\n    int arr[5]={0};\n    int n=sizeof(arr)/sizeof(arr[0]);\n\n    //获取键盘输入\n    my_input_array(arr,n);\n    //遍历数组元素\n    my_printf_array(arr,n);\n\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic8.png)  \n\n\n\n\n\n---------------------------\n\n\n\n\n## 二维数组名作为函数的参数\n\n1. 如果想要在函数内部，修改函数外部变量的值，就需要将函数外部变量的地址，传递给函数(以指针变量作为函数的参数) `【重要重要重要！！！】`\n2. 二维数组名，作为函数的形参，会被优化成数组指针  \n```C\n\nint arr1[5]--->int *p1\nint arr2[3][4]--->int (*p2)[4]\nint arr3[3][4][5]--->int (*p3)[4][5]\nint arr4[3][4][5][6]--->int (*p4)[4][5][6]\n·········..........·········\n\n```\n### 案例1：\n```C\n#include<stdio.h>\nvoid my_printf_two_array(int arr[3][4],int row,int col){\n    printf(\"B:%d\\n\",sizeof(arr));\n}\nint main(int argc,char *argv[]){\n\n    int arr[3][4]={{1,2,3,4},{5,6,7,8},{9,10,11,12}};\n    int row=sizeof(arr)/sizeof(arr[0]);//行数\n    int col=sizeof(arr[0])/sizeof(arr[0][0]);//列数\n\n    printf(\"A:%d\\n\",sizeof(arr));\n    my_printf_two_array(arr,row,col);\n\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic9.png)  \n\n分析：当二维数组作为函数的参数时，会被优化成数组指针  即，  \n`void my_printf_two_array(int arr[3][4],int row,int col){`  \n变成  \n`void my_printf_two_array(int (*arr)[4],int row,int col){`\n\n\n### 案例2：\n```C\n#include<stdio.h>\nvoid my_printf_two_array(int (*arr)[4],int row,int col){\n    int i=0,j=0;\n    for(i=0;i<row;i++){\n        for(j=0;j<col;j++){\n            // printf(\"%d \",*(*(arr+i)+j));\n            printf(\"%d \",arr[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\nint main(int argc,char *argv[]){\n\n    int arr[3][4]={{1,2,3,4},{5,6,7,8},{9,10,11,12}};\n    int row=sizeof(arr)/sizeof(arr[0]);//行数\n    int col=sizeof(arr[0])/sizeof(arr[0][0]);//列数\n\n    my_printf_two_array(arr,row,col);\n\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic10.png)  \n\n\n\n\n------------------------\n\n\n\n## 指针作为函数的返回值\n\n### 案例2：\n```C\n#include<stdio.h>\nint* get_addr(void){\n    // int num=1000;\n    static int num=1000;\n\n    return &num;\n}\nint main(int argc,char *argv[]){\n    int *p=NULL;\n    p=get_addr();\n    printf(\"%d\\n\",*p);\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic11.png)  \n\n\n------------\n\n\n## 函数名，代表的是函数的入口地址\n\n### 案例1：\n```C\n#include<stdio.h>\nint my_add(int a,int b){\n    return a+b;\n}\nint main(int argc,char *argv[]){\n    printf(\"%p\\n\",my_add);\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic12.png)  \n\n\n### 案例2：定义一个指针变量，保存函数的入口地址\n```C\n#include<stdio.h>\nint my_add(int a,int b){\n    return a+b;\n}\nint main(int argc,char *argv[]){\n    //按照定义指针变量的三部曲走，再复杂的也可以\n    // int (*p)(int a,int b);\n    int (*p)(int,int)=NULL;\n    p=my_add;\n\n    printf(\"my_add=%p\\n\",my_add);\n    printf(\"p=%p\\n\",p);\n\n    //函数的调用：函数入口地址 + ()\n    printf(\"%d\\n\",my_add(10,20));\n    printf(\"%d\\n\",p(30,40));\n\n    //对函数指针变量取*无意义\n    printf(\"%d\\n\",(*p)(30,40));\n    (*******printf)(\"hello\\n\");\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic13.png)  \n\n\n\n--------------------\n\n\n\n\n## 指针函数的应用-函数指针作为函数的形参\n\n### 案例1：\n```C\n#include<stdio.h>\nint my_add(int a,int b){\n    return a+b;\n}\nint my_sub(int a,int b){\n    return a-b;\n}\nint my_mul(int a,int b){\n    return a*b;\n}\n\n    //定义一个函数实现上面三个函数的功能\nint my_calc(int a,int b,int (*fun_pointer)(int,int)){\n    return fun_pointer(a,b);\n}\nint main(int argc,char *argv[]){\n    printf(\"%d\\n\",my_calc(10,20,my_add));\n    printf(\"%d\\n\",my_calc(10,20,my_sub));\n    printf(\"%d\\n\",my_calc(10,20,my_mul));\n\n    return 0;\n}\n\n```\n运行结果：  \n![图片](./pic14.png)\n\n--------------------\n","tags":["随记"],"categories":["C语言"]},{"title":"C语言 day9","url":"/2020/05/12/C语言-day9/","content":"\n\n# 指针\n\n## 指针`数组`\n\n> 存放指针变量的数组\n\n### 案例1：  \n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    int a = 10,b = 20, c = 30;\n    int *arr[3] = {&a, &b, &c};\n    char *arr2[3];\n\n    printf(\"%d\\n\",*arr[1]);//20\n    printf(\"%d\\n\",sizeof(arr));//12\n    printf(\"%d\\n\",sizeof(arr2));//12\n    return 0;\n}\n```\n\n<!-- more -->\n\n分析：  \n第8、9行代码结果都为`12`的原因是，在32位的平台下，只要是指针都是4字节的，所以 `3 * 4 = 12`\n\n### 案例2：  \n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    char *arr[3] = {\"hello\",\"world\",\"hahaha\"};\n\n    printf(\"%d\\n\",sizeof(arr));//12\n    printf(\"%s\\n\",arr[0]);\n    printf(\"%s\\n\",arr[1]);\n    printf(\"%s\\n\",arr[2]);\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic1.png)  \n\n分析：  \n`\"\"` 双引号取得是字符串的地址，所以`char *arr[3]`中的三个元素存的分别是`\"hello\"`、`\"world\"`、`\"hahaha\"`的起始地址，而打印字符串的时候的`%s`需要的也是字符串的首地址，然而`char *arr[3]`保存的就是字符串的地址.不然字符串`\"hello\"`、`\"world\"`、`\"hahaha\"`都超过了四字节，那`char *arr[3]`怎么可能存的下去。\n\n\n#### 拓展：打印出`\"world\"`中的`'r'`\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    char *arr[3] = {\"hello\",\"world\",\"abcdefg\"};\n\n    printf(\"%c\\n\",*(arr[1]+2));\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic2.png)  \n\n分析：  \n要打印字符`'r'`，输出格式就是`%c`，他需要的就不是地址，我们需要对地址取 `*` ;  首先我们要找到字符`'r'`的地址，我们知道`arr[1]`储存的是字符串`\"world\"`的首地址,也就是字符`'w'`的地址，我们要得到字符`'r'`只需在字符`'w'`的地址上加2即可，因为`arr[1]`指向的类型是`char`跨度宽度均为`1字节`\n\n#### 问：输出多少？\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    short *arr[3] = {\"hello\",\"world\",\"abcdefg\"};\n\n    printf(\"%c\\n\",*(arr[2]+1));\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic3.png)  \n\n分析：  \n`arr[2]`指向类型为`short`宽度和跨度都为`2字节`  \n\n\n\n## 数组`指针`\n\n> 数组指针是一个指针变量，如果分不清可以试试将指针替换为地址，即数组的地址，顾名思义他就是一个存放一个数组的地址的指针变量  \n\n### 案例1：  \n![图片](./pic4.png)  \n\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    int arr[5] = {10,20,30,40,50};\n    int (*p)[5];//数组指针：本质是一个指针变量，只是这个变量保存的是数组的首地址\n\tp = &arr;\n\n    printf(\"sizeof(p)=%d\\n\",sizeof(p));//4\n    printf(\"p=%u\\n\",p);\n    printf(\"p+1=%u\\n\",p+1); \n    return 0;\n}\n```\n\n运行结果：  \n![图片](./pic5.png)  \n\n分析：  \n第7行代码，因为数值指针的本质就是一个指针变量，然而在32位平台下，指针变量的大小都是4字节；  \n第8、9行代码，因为p指向的类型就是擦掉`p和*`可得p的指向类型为int[5] 跨度为`4*5=20字节`,所以`p+1`加了`20`\n\n#### 拓展：取出 `arr[5] = {10,20,30,40,50};` 中的 `30`\n\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    int arr[5] = {10,20,30,40,50};\n    int (*p)[5];//数组指针：本质是一个指针变量，只是这个变量保存的是数组的首地址\n\tp = &arr;\n\n    printf(\"%d\\n\",*(*p+2));\n    printf(\"%d\\n\",p[0][2]);//*(*(p+0)+2)=*(p[0]+2)=p[0][2]\n    //一维数组可以看成只有一行的二维数组\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic6.png)  \n\n对数组指针取 * 得到数组元素的地址  \n对数组首地址取 * 得到数组首元素的地址  \n`*p=*&arr = arr`\n\n## 总结：\n1. 指针`数组`：本质是数组，只是数组的每个元素是指针\n2. 数组`指针`：本质是指针变量，只是保存的是数组的首地址（不是数组首元素的地址）","tags":["随记"],"categories":["C语言"]},{"title":"C语言 day8","url":"/2020/05/11/C语言-day8/","content":"\n\n\n# 指针\n\n\n## 数组元素的指针\n\n### 案例1：通过数组元素指针遍历数组的元素  \n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    int arr[5] = {10,20,30,40,50};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int i = 0;\n    int *p = &arr[0];\n\n    for(i = 0; i < n; i++){\n        //printf(\"arr[i]=%d \\n\",arr[i]);\n        printf(\"arr[i]=%d \",*(p+i));\n        //p+i代表的是第i个元素的地址\n        //*(p+i)代表的是第i个元素的值\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n```\n\n<!-- more -->\n\n\n运行结果：  \n![图片](./pic1.png)  \n\n### 案例2：通过数组元素指针获取键盘输入  \n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    int arr[5] = {10,20,30,40,50};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int i = 0;\n    int *p = &arr[0];\n\n    for(i = 0; i < n; i++){\n        //scanf(\"%d\",&arr[i]);\n        scanf(\"%d\",p+i);\n    }\n\n    for(i = 0; i < n; i++){\n        printf(\"arr[i]=%d \",*(p+i));\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic1.png)  \n\n### 案例3：问，输出的是多少？\n\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    int arr[5] = {10,20,30,40,50};\n    int *p = &arr[2];\n    p++;\n    printf(\"%d\",*(p+1)); \n\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic2.png)  \n\n\n\n\n--------------------------\n\n\n\n\n## 数组的 `[]` 和 `*()` 的关系\n\n\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    //数组名arr作为地址代表的是 首元素地址（第0个元素的地址）\n    //数组名arr作为类型 代表的是数组的总大小  sizeof(arr)\n    int arr[5] = {10,20,30,40,50};\n    int *p = NULL;\n\n    p = &arr[0];//arr == &arr[0]\n\n    printf(\"%d\\n\",arr[1]);//20\n    printf(\"%d\\n\",*(arr + 1));//20\n\n    printf(\"-----------------------------\"); \n\n    printf(\"%d\\n\",*(1 + arr));//20\n    printf(\"%d\\n\",1[arr]);//20  也可以哦！\n    // 在使用中  []的本质就是*()的缩写   在早期C语言中是没有[]的，所以的[]用的都是*()\n    //缩写的规则就是，+左边的值放在[]的左边，+右边的值放在[]的里面，\n\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic3.png)  \n\n\n### 为啥 arr代表的是 数组第0个元素的地址\n由上面的结论可得：  \n\n```C\n&arr[0] = & *(arr+0) = arr+0 = arr;\n//& * 在一起可以抵消\n\n\n```\n### 总结：\n1. [] 是*() 的缩写\n2. 数组名arr代表的是数组 首元素的地址(第0个元素的地址)\n\n\n\n------------------------------------\n\n\n\n\n## `arr` 和 `&arr` 的区别(了解)\n\n#### arr:数组的首元素地址\n#### &arr:数组的首地址（数组名取地址没啥意义的，这个只是一个表达式的结合）\n案例：  \n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    int arr[5] = {10,20,30,40,50};\n    \n    printf(\"arr=%u\\n\",arr); \n    printf(\"arr+1=%u\\n\",arr+1); \n    printf(\"------------------------\\n\"); \n    printf(\"&arr=%u\\n\",&arr); \n    printf(\"&arr+1=%u\\n\",&arr+1); \n\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic4.png)  \n\n\n### 分析：  \narr+1增加了4字节，跳过1个元素  \n&arr+1增加了20字节，跳过5个元素即整个数组  \n\n### 结论：\n\n1. arr代表的是数组首元素的地址，+1跳过一个元素  \n2. &arr代表的是数组的首地址，+1跳过整个数组  \n3. arr和&arr在地址编号上是一样的，但是类型是完全不一样的\n\n> 注意：数组名 `arr` 是个符号常量，不能被修改(赋值)  `arr++ (错误)`\n\n\n\n\n-----------------------------------\n\n\n\n## 指向同一个数组的两个元素的指针变量间的关系\n\n\n案例1：问，p2-p1=？12还是3？  \n```C\n#include<stdio.h>\nint main(int argc,char *argv){\n    int arr[5] = {10,20,30,40,50};\n    int *p1 = arr;\n    int *p2 = arr+3;\n\n\n    //1、指向同一个数组的两个指针变量相减，返回的是相差的元素的个数\n    printf(\"%d\",p2-p1);//3\n\n    //2、指向同一个数组的指针变量可以比较大小\n    if(p2>p1){\n        printf(\"p2>p1\");\n    }else{\n         printf(\"p2<=p1\");\n    }\n\n    //3、指向同一个数组的两个指针变量，可以相互赋值\n    p1=p2;//p1和p2指向同一处\n\n    //4、指向同一数组的两个指针变量，不要相加\n    p1+p2;\n\n    //5、[]在不越界的情况下，里面可以为负数\n    printf(\"%d\\n\",p2[-2]);//   展开为*( p2 + (-2) )= *(p2-2)=20\n    return 0;\n}\n```\n\n\n案例2：  \n```C\n#include<stdio.h>\nint main(int argc,char *argv){\n    int arr[5] = {10,20,30,40,50};\n    int *p = arr;\n\n    printf(\"%d\\n\",*p++);//10\n    printf(\"%d\\n\",(*p)++);//20\n    printf(\"%d\\n\",*(p++));//21\n/*\n第一次做：20,21,30\n\n优先级() > ++(从右至左) = *(从右至左)\n\n*/\n    return 0;\n}\n```  \n![图片](./pic5.png)  \n讲解：  \n\n<!-- <video src=\"./ans.mp4\" controls=\"controls\"></video> -->\n<video src=\"/2020/05/11/C语言-day8/ans.mp4\" controls=\"controls\">\n播放器浏览器不支持\n</video>\n","tags":["随记"],"categories":["C语言"]},{"title":"C语言 day7","url":"/2020/05/11/C语言-day7/","content":"\n\n# 指针\n\n## 指针变量的强制类型转换\n\n案例：\n\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    int num = 0x01020304;\n    return 0;\n}\n```\n\n<!-- more -->\n\n需求:取出如图 橙色框框内的 `0x0203`  \n![图片](./pic1.png)  \n1. 如果跨度与宽度不等时，需要用到类型转换\n2. 观察需求的跨度与宽度\n3. 选择min(跨度,宽度) 定义指针变量\n\n* ### 方法一：\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    int num = 0x01020304;\n    char *p;\n    p = &num;\n    printf(\"%#x\",*(short *)(p + 1));\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic2.png)  \n分析：定义的 `char *p` ,指向的变量类型为 `char` 跨度为1字节，宽度为1字节，`p+1` 跨1个字节，`(short *)(p + 1)` 跨一个字节后强制类型转换将指针变量 `p` 指向变量类型转换成了  `short` 宽度为2字节，所以取出2个字节。\n\n\n* ### 方法二：\n不取小的定义指针变量，我偏取大的定义指针变量，复杂些\n\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    int num = 0x01020304;\n    short *p;\n    p = &num;\n    printf(\"%#x\",*(short *)(((char *)(p) + 1)));\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic2.png)  \n分析：定义的 `short *p` ，跨度、宽度都为2字节，先强制类型转换 `(char *)(p)` 将指针变量指向类型转换为 `char` 此时的跨度为1字节，然后`((char *)(p) + 1)`加一，跨一个字节，`(short *)`再强制类型转换将指针`p`指向`short`,此时的宽度为2字节，取空间内容即可得到`0x0203`  \n\n* ### 方法三：\n定义两个指针变量，一个用来当跨度，一个用来当宽度\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    int num = 0x01020304;\n    short *p1;\n    char *p2;\n    p2 = &num;\n    p1 = p2 + 1;\n    printf(\"%#x\",*p1);\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic2.png)  \n分析：定义了两个指针变量，一个用来当跨度，一个用来当宽度，不好描述，自己领悟好了  \n\n\n---------------\n\n\n\n\n## 指针变量的初始化\n\n### 1. 如果局部指针变量，不初始化，保存的是随机的地址编号（千万不要操作哦）  \n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    int *p;\n    printf(\"---------111---------\");\n    printf(\"%d\",*p);\n    printf(\"---------222---------\");\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic3.png)  \n`printf(\"---------222---------\");`这个语句并没有执行（段错误），非法内存无法访问  \n\n### 2. 不想让指针变量指向任何地方（也千万不要操作哦）  \n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    // #define NULL ((void *)0)\n    int *p=NULL;\n    printf(\"---------111---------\");\n    printf(\"%d\",*p);\n    printf(\"---------222---------\");\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic3.png)  \n一样的会出现段错误  \n\n### 3. 将指针变量初始化为合法地址（可以操作） \n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    int num = 10：\n    int *p = &num;\n    printf(\"%d\",*p);\n    return 0;\n}\n```\n\n### 总结：\n#### 1. 指针变量初始化为 `NULL`\n```C\nint *p = NULL;//不要对p进行*p操作，容易出段错误\n```\n\n#### 2. 指针变量初始化为 合法地址空间\n```C\nint num = 10;\nint *p = &num;//可以操作\n```\n\n-----------------\n\n\n##  `&` 取地址符 和 `*` 指针解引用符 的区别(使用中)\n\n### 引入：\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    int num = 10;\n}\n```\n上面代码中的 `num` 是 `int` 类型，这个是肯定的，那么请问 `&num` 是什么类型？... 是 `int *` 类型。  \n总结：如果对一个变量取地址 整个表达式类型 就是变量的类型加 `*`  \n\n* 问1：\n```C\nint *p;\n&p是什么类型？ 是int类型\n```\n\n* 问2：\n```C\nint ****p;\n&p是什么类型 是int ***类型\n```\n\n* 问3：\n```C\nint num = 10;\nint *p;\np = &num;\np是什么类型 是int *类型\n所以p = &num;这个赋值语句左右两边类型是相同的，是严谨的赋值语句\n```\n\n* 问3：\n```C\nint num = 10;\nint *p;\np = &num;\n在使用中，*p是是什么类型？\n是int，*p取得是对应地址的空间的内容\n```\n总结：如果对指针变量取 `*` 整个表达式的类型是 指针变量的类型减 `*`  \n\n### 总结：如果 `&` 和 `*` 同时存在可以相互抵消（从右至左抵消）。（重要）\n```C\n&*&*&num == &num;\n&*&**&p == p;\n```\n\n--------------\n\n## 指针的注意事项\n\n### 1.`void` 不能定义变量\n```C\nvoid num;//错误的 系统不知道num的内存大小，无法分配内存空间\n```\n\n### 2.`void *` 可以定义变量\n```C\nvoid *p;//p的类型为void *,而指针类型在32为平台都是4字节，系统知道给p开辟4字节的空间\n//能不能定义成功关键是看系统知不知道要给你分配多大的内存空间\n```\n* #### `p` 叫万能指针 `p` 可以保存 任意一级指针 ,如果是 `void **p` 就可以保存 任意二级指针···\n* #### 对于 `p` 不能直接 `*p` 因为他指向的类型为void，就没办法确定指针的宽度和跨度\n```C\n#include<stdio.h>\nint main(int argc, char* argv[]) {\n\tvoid* p;\n\tint num = 10;\n\tp = &num;\n\t//\tprintf(\"%d\\n\",*p); \n\tprintf(\"%#x\\n\", p);\n\t//printf(\"%#x\\n\", p + 1);\n\n\treturn 0;\n}\n```\n> 所以第六行代码编译直接报错，而第八行代码的跨度按道理也是错误的。但是有的编译器编译成功并且跨度当做1字节计算(如DEV C++)；在Visual Studio 2019下直接报错。 \n\n* #### 如果要使用的话，就必须进行强制类型转换\n```C\n#include<stdio.h>\nint main(int argc, char* argv[]) {\n\tvoid* p;\n\tint num = 10;\n\tp = &num;\n\tprintf(\"%d\\n\",*(int *)(p)); \n\tprintf(\"%#x\\n\", p);\n\tprintf(\"%#x\\n\", ((int *)(p) + 1));// p临时指向的类型为int\n\t//printf(\"%#x\\n\", p+1);//这里仍然会报错，因为上面的强制类型转换只是临时性的\n\treturn 0;\n}\n```\n运行结果：  \n\n![图片](./pic4.png)\n\n\n### 3. 不要操作 没有初始化的指针变量 即对其取 `*`\n\n```C\nint *p;\nprintf(\"p=%d\\n\",*p);\n//因为p没有初始化，内容随机，也就是p指向了一个位置的空间，系统不允许用户，进行取值*p的操作\n```\n\n\n\n### 4. 不要操作 初始化为`NULL`的指针变量 即对其取 `*`  \n\n```C\nint *p = NULL;\nprintf(\"p=%d\\n\",*p);\n//NULL 就是(void *)0 地址，也就是内存的起始地址，受系统保护，也不能取值 *p\n```\n\n\n### 5. 不要给指针变量赋无意义的普通数值\n```C\nint *p = 2000;\n//此时的2000对于p来说 是地址编号 2000\n// *p表示在地址编号为2000 的位置取值，而地址编号2000 不是合法的空间，所以不能*p 会出现段错误\n```\n> 内存必须申请后才能使用，通过人为调用函数申请、定义一个变量系统自动申请空间等等，这些都是合法空间；否则其他的都是非法空间，都不能使用，系统会保护的。\n\n\n\n### 6. 指针变量不要操作越界的空间\n```C\nchar num = 10;\nint *p = &num;\nprintf(\"num=%d\",*p);\n```\n运行结果：  \n![图片](./pic5.png)  ","tags":["随记"],"categories":["C语言"]},{"title":"C语言 day6","url":"/2020/05/11/C语言-day6/","content":"\n\n# 指针\n\n\n## 指针的概述  \n1. 在32位系统的寻址范围是4G  0x00 00 00 00 ~ 0xff ff ff ff\n2. 内存是以字节为单位来存储数据的 系统给每个字节分配一个编号 而这个编号就是内存的地址(指针) 所以在32位系统最多只能识别4G的内存 \n3. 内存的地址就是指针 指针就是地址  指针是C语言中给内存的地址起的好听高大上的名字\n\n<!-- more -->\n\n-----\n\n\n## 指针变量\n1. 指针变量：本质就是一个变量 只是这个变量存放的是内存的地址编号（指针）\n2. 在32位系统中 任何类型的地址编号都是4字节；在64位系统中 任何类型的地址编号都是8字节。  \n{% code lang:C %}  \n#include<stdio.h>\nint main(int argc,char *argv[]){\n    printf(\"%d\\n\",sizeof(char *));\n    printf(\"%d\\n\",sizeof(short *));\n    printf(\"%d\\n\",sizeof(int *));\n    printf(\"%d\\n\",sizeof(long *));\n    printf(\"%d\\n\",sizeof(float *));\n    printf(\"%d\\n\",sizeof(double *));\n    printf(\"%d\\n\",sizeof(double *****));\n    return 0;\n}\n{% endcode %}  \n运行结果：`4 4 4 4 4 4 4`  \n\n-----\n\n\n## 指针变量的定义\n步骤：  \n1、 *修饰 指针变量名  \n2、 保存啥类型的地址 就用该类型定义一个普通变量  \n3、 从上往下 整体替换  \n`int num;&num`  取num变量的空间的起始地址  \n\n---------------\n\n## 指正变量使用\n<b>通过 `p保存的地址空间` 进行读写操作</b>  \n\n在使用中 `*p` 取p所保存的地址编号 对应的空间的内容（指针变量`p`的解引用）\n\n\n--------------\n\n## 指针变量的类型\n\n\n\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    int num=10;\n    int *p;\n    p = &num;\n    printf(\"%d\\n\",*p);//10\n    return 0;\n}\n```\n问：  \n`*p`是如何取出10的？\n<br/>\n\n\n### 指针变量自身的类型：\n在定义中，将指针变量名拖黑 剩下啥类型 指针变量就是啥类型\n<br/>\n\n### 指针变量所指向的类型：\n在定义中，将指针变量名和离他最近的一个 `*` 一起拖黑 剩下啥类型 指针变量就指向啥类型\n<br/>\n<br/>\n\n\n### 案例：指针变量取值的宽度  \n\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    int num=0x01020304;//4字节\n    int *p;\n    p = &num;\n    printf(\"%d\\n\",*p);\n    return 0;\n}\n```\n>  `num` 在系统中要么是顺着存要么是倒着存，不论是顺着存还是倒着存，放心，他取出来都会自动颠倒过来，如图：  \n\n![图片](./pic1.png)  \n\n#### 指针变量取值的宽度：指针变量指向类型长度决定。\n\n* 这就是为什么`*p`能取出`num`的数据   \n\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    int num=0x01020304;//4字节\n    int *p;\n    short *p2;\n    char *p3;\n    p = &num;\n    p2 = &num;\n    p3 = &num;\n    printf(\"%#x\\n\",*p);\n    printf(\"%#x\\n\",*p2);\n    printf(\"%#x\\n\",*p3);\n    return 0;\n}\n```\n运行结果：    \n\n![图片](./pic3.png)    \n\n\n分析：  \n\n![图片](./pic2.png)  \n\n<br/>\n\n### 指针变量的跨度\n#### 指针变量的跨度：指针变量指向类型长度决定。\n\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    int num=0x01020304;//4字节\n    int *p;\n    short *p2;\n    char *p3;\n    p = &num;\n    p2 = &num;\n    p3 = &num;\n    printf(\"p=%u\\n\",p);\n    printf(\"p+1=%u\\n\",p+1);\n    printf(\"p2=%u\\n\",p2);\n    printf(\"p2+1=%u\\n\",p2+1);\n    printf(\"p3=%u\\n\",p3);\n    printf(\"p3+1=%u\\n\",p3+1);\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic4.png)  \n\n综合案例：  \n![图片](./pic5.png)  \n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    int num=0x01020304;//4字节\n    short *p;\n    p = &num;\n    printf(\"%#x\",*(p+1));\n    return 0;\n}\n```\n运行结果：  \n![图片](./pic6.png)  \n\n\n\n","tags":["随记"],"categories":["C语言"]},{"title":"C语言 day5","url":"/2020/05/11/C语言-day5/","content":"\n\n## 编译过程\n![图片](./pic1.png)  \n\n#### 预处理：头文件包含、宏替换、条件编译、删除注释、  不做语法检查\n\n#### 编译：将预处理后的文件 生成 汇编文件  做语法检查  \n\n#### 汇编：将汇编文件 编译成二进制文件  \n\n#### 链接：将众多的二进制文件+库+启动代码  生成可执行文件\n\n##### 总结：更多的时候是一步到位 编译：gcc 源文件 -o 可执行文件\n<!-- more -->\n\n<br/>\n\n### 预处理\n1. 头文件包含 #include\n2. 宏定义 #define\n3. 条件编译 #if #endif...\n4. 一些特殊作用的预定义宏\n\n#### 头文件包含(了解)\n`#include<aaa.h>`  表示从系统的指定目录下寻找aaa.h（用于包含系统的头文件）\n\n`#include\"aaa.h\"` 表示从当前目录下寻找 如果没找到再去到系统指定目录下寻找（用于包含用户自定义的头文件）  \n\n#### 宏定义#define\n宏只在当前源文件有效  \n终止宏的作用范围可以用`#undef N`\n1. 不带参数的宏  直接替换  替换的过程叫做`宏展开`\n2. 带参数的宏（宏函数）\n    * 格式： #define 宏名(参数1,,参数2...) 字符串（宏的参数不带类型 他不是函数只是一个宏）\n    * 调用：宏名(参数)\n    * 与普通函数的区别：\n        + 宏函数调用多少次就展开多少次，执行代码的时候没有函数调用的过程，也不需要函数的出入栈，所以带参数的宏 浪费空间 节省时间\n        + 带参数的函数 代码只有一份，存在代码段，调用的时候去代码段读取函数指令，调用的时候要压栈（保存调用函数前的相关信息），调用完出栈（恢复调用函数前的相关信息），所以函数浪费了时间 节省了空间。\n\n案例：  \n{% code lang:C %}\n\n#include<stdio.h>\n#define MY_MULL(a,b) a*b\n//#define MY_MULL(a,b) ((a)*(b))\nint main(int argc,char *argv[]){\n\n    printf(\"%d\",MY_MULL(10,20));//200\n    printf(\"%d\",MY_MULL(10+10,20+20));//230  宏展开 本质就是宏替换\n    return 0;\n}\n\n{% endcode %}\n\n案例：请计算结果  \n{% code lang:C %}\n#define MY_ADD(a,b) a+b\n#define MY_MUL(a,b) a*b\n\nprintf(\"%d\",MY_MUL(MY_ADD(10+10,20+20),MY_MUL(10+10,20+20)));\n\n{% endcode %}\n\n#### 条件编译\n![图片](./pic2.png)   \n\n\n-----------------------------------------\n### 防止头文件重复包含\n\n方法一：每个头文件前加#pragma once 编译器决定  \n方法二：c/c++标准制定  \n{% code lang:C %}\n\n#ifndef  头文件名//a.h-->__A_H__\n#define  头文件名\n\n内容\n\n#endif  \n\n{% endcode %}  \n总结：  \n#pragma once 编译器决定 强调文件名  \n#ifndef c/c++标准制定 强调的宏名 而不是文件\n\n\n### 原码 反码 补码\n![图片](./pic3.png)  \n注意：无符号数，正数  反码 原码 补码相等 \n重要：负数在计算机中存储的是补码（所有数据存储的都是补码只不过非负数反码、补码、原码都相同）\n#### 计算机为啥要补码？\n![图片](./pic4.png)  \n总结：  \n1. 补码的意义将减法运算变加法运算  \n2. 统一了0的编码  \n `+0 = 0000 0000=0000 0000（反码）=0000 0000（补码）`  \n `-0 = 1000 000 = 1111 1111（反码）= 0000 0000（补码）`\n![图片](./pic5.png)  \n","tags":["随记"],"categories":["C语言"]},{"title":"C语言 day4","url":"/2020/05/09/C语言-day4/","content":"\n\n## 函数\n1、 函数的形参 本质 是函数的局部变量  \n2、 形参在函数定义的时候不会开辟空间，只在函数调用的时候才开辟空间  \n3、 形参在函数结束的时候才会变量  \n4、 函数名代表的是函数的入口地址  \n5、 函数的返回值 <=4字节 存放在寄存器  |  >4字节放在栈区\n<!-- more -->\n\n## 内存的分区\n![图片](./p1.png)  \n![图片](./p2.png)\n\n\n\n## 变量的存储类别  \n\n### 1、 普通局部变量  \n定义形式：在{}里面定义的普通变量  \n作用范围：离它最近的{}的范围内有效  \n生命周期：离开{}的局部变量  系统回收  \n存储区域：栈区  \n注意事项：\na、普通局部变量不初始化 内容不确定（只要是在栈区的都是不确定的）\nb、普通局部变量同名的话 就近原则  \n<br/>\n\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    int data = 100;\n    {\n        int data = 200;\n        printf(\"A:data=%d\",data);\n    }\n    printf(\"B:data=%d\",data);\n    return 0;\n}\n```\n\n运行结果：`A:data=200   b:data=100`  \nB执行的时候，data=200已经释放了\n<br/>\n<br/>\n\n### 2、 静态局部变量  \n定义形式：在{}中定义 前面必须要加`static`修饰  \n作用范围：离他最近的{}之间有效\n生命周期：整个进程都有效(范围小 活得久) \n<br/>\n{% code lang:C %}\n#include<stdio.h>\nvoid fun1(void){\n    int num = 10;\n    num++;\n    printf(\"num=%d\",num);\n    return;\n}\nvoid fun2(void){\n    //静态局部变量只能被初始化一次 当执行第二个函数时，这条语句不执行\n    static int num = 10;\n    num++;\n    printf(\"num=%d\",num);\n    return;\n}\nint main(int argc,char *argv[]){\n    fun1();//11\n    fun1();//11\n    fun1();//11\n    fun1();//11\n    fun2();\n    fun2();\n    fun2();\n    fun2();\n    return 0;\n}\n{% endcode %}\n\n可以用来统计函数调用的次数\n存储区域：全局区（这就是上面的原因）  \n注意事项：\na、 静态局部变量 不初始化内容为0（全局区）  \nb、 只能被定义一次  \n<br/>\n<br/>\n\n### 3、 普通全局变量  \n定义形式：在函数外面定义的\n作用范围：  \na、 当前源文件都有效，在定义之前使用需要进行声明  （声明的时候尽量推荐加上`extern`可以不加。不然容易当成是变量的定义）\nb、其他源文件都有效  在其他源文件使用全局变量是 必须加上`extern`\n生命周期：整个进程都有效 （程序结束的时候 才被释放）  \n存储区域：全局区  \n注意事项：  \na、全局变量不初始化，内容为零（全局变量会被放到bss区，bss区会自动补0）  \nb、如果全局变量 要在其他源文件里使用  必须要加extern声明   \nc、如果全局变量与局部变量同名 在{}中优先使用全局变量  \n<br/>\n<br/>\n\n### 4、 静态全局变量  \n定义形式：在函数外面定义 同时加`static`修饰  \n作用范围：只能在当前源文件里使用（多人开发 防止重名）  \n生命周期：整个进程  \n存储区域：全局区\n注意事项：\na、静态全局变量不初始化 内容为0  \nb、静态全局变量 只在当前源文件内有效\n<br/>\n<br/>\n\n\n\n## 全局函数（普通函数）和静态函数（局部函数）\n\n### 1. 全局函数（普通函数） \n特点：可以在其他源文件中使用 必须加extern声明  \n\n### 2. 静态函数（局部函数）  \n定义的时候加了`static`\n特点：只能在当前源文件里使用  不能在其他源文件中使用  \n非得使用也可以，需要将静态函数封装在全局函数中，同时全局函数和静态函数必须是在同一个源文件   \n<br/>\n\n\n> 练习：写出运行结果。  \n\n![图片](./p3.png)\n\n\n\n","tags":["随记"],"categories":["C语言"]},{"title":"C语言 day3","url":"/2020/05/08/C语言-day3/","content":"\n\n## 数组\n数组的定义：  \n1. arr[]  arr和[]结合是数组  \n2. 将确定的元素的个数放入[]中\n3. 用元素的类型  定义一个变量\n4. 从上往下整体替换  \n注：后面复杂数组的定义使用此方法\n\n<!-- more -->\n### 一维字符数组\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    char str1[] = {'h','e','l','l','o'};\n    char str2[6] = {'h','e','l','l','o'};\n    char str3[] = \"hello\";\n    printf(\"str1=%s,sizeof(str1)=%d\\n\",str1,sizeof(str1));\n    printf(\"str2=%s,sizeof(str2)=%d\\n\",str2,sizeof(str2));\n    printf(\"str3=%s,sizeof(str3)=%d\\n\",str3,sizeof(str3));\n\n    return 0;\n}\n\n```\n运行结果：  \n![图片](./pic1.png)    \n分析：由于`str1`没有中没有`'\\0'`所以以`%s`格式化输出时不会停止，会打印后面内存中的值，直到在后面的内存中遇到`'\\0'`才会停止；  \n`str2`中总大小是6字节，初始化了5个元素，剩下一个未初始化的元素会自动初始化为`0`,然而`0`与`'\\0'`在内存中储存形式是一致的，即等效  \n`str3`以`\"\"`字符串的方式进行初始化，字符串的末尾系统会自动加`'\\0'`  \n\n案例1：获取键盘字符串  \n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    char str[128]=\"\";\n    scanf(\"%s\",str);\n    pritnf(\"%s\",str);\n    return 0;\n}\n```\n缺点：`scanf()`遇到空格会结束输入，无法输入空格\"hello world\"  \n改进1：\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    char str[128]=\"\";\n    // scanf(\"%s\",str);\n    gets(\"%s\",str);\n    fgets(str,sizeof(str),stdin);\n    printf(\"str=%s\", str);\n    return 0;\n}\n```\n优点：可以获取到空格  \n缺点：`gets()`获取输入时，不会去管`str`的大小，容易造成内存污染  \n如图：定义的`str`长度为5但是输入的字符长度大于5，依然存到内存中去了，如果后面内存有重要的数据，则污染了\n![图片](./pic2.png)   \n\n改进2：使用`fgets()`  \n参数：第一个：存到哪 第二个：最大长度 如3，则只会存2个字符 第三个：字符来源 stdin（标准输入设备）  \n原型：![图片](./pic3.png)   \n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    char str[128]=\"\";\n    // scanf(\"%s\",str);\n    //gets(\"%s\",str);\n    fgets(str,sizeof(str),stdin);\n    printf(\"str=%s\", str);\n    return 0;\n}\n```   \n优点：既能获取到空格，又能保证字符数组不越界，推荐使用    \n\n\n### 二维字符数组  \n一维字符数组是存放多个字符  \n二维字符数组是存放多个字符串 每个字符串占一行\n```C\n//二维数组 初始化时可以省略行标 不能省略列标\nchar str[][16]={\"haha\",\"xixi\",\"heihei\"};\n```  \n案例：输入 输出\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    // char str[3][16]=\"\";\n    char str[3][16]={\"\"};\n    int i=0;\n\n    for(i=0;i<3;i++){\n        scanf(\"%s\",str[i]);\n    }\n\n    for(i=0;i<3;i++){\n        printf(\"str[%d]=%s\\t\",i,str[i]);\n    }\n    return 0;\n}\n```\n![图片](./pic4.png)  \n","tags":["随记"],"categories":["C语言"]},{"title":"C语言 day2","url":"/2020/05/03/C语言-day2/","content":"\n## 类型转换\n### 1. 自动类型转换  \n字节数小的向字节数大的转换  \n![图片](./p1.png)  \n* 案例1：  \n<!-- more -->\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    int num1 = -20;\n    unsigned int num2= 10;\n    if(num1 + num2 >0){\n        printf(\">0;num1+num2=%d\\n\",num1+num2);\n    }else{\n        printf(\"<0;num1+num2=%d\\n\",num1+num2);\n    }\n\n    return 0;\n}\n```\n运行结果： `>0;num1+num2=-10`  \n![图片](./p2.png)   \n原因：是因为无符号整型加有符号整型会自动转化为无符号整型，然而-20的补码是个很大的数，加上10必然大于0，所以结果是大于零的；但为什么`num1+num2=-10`呢？因为输出时，系统是将其当成有符号数输出的\n\n* 案例2：`int` 与 `double`  \n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    int num = 10;\n    printf(\"%d\\n\",sizeof(num+3.14f));\n    printf(\"%d\\n\",sizeof(num+3.14));\n    return 0;\n}\n```\n运行结果：  \n`4 8`  \n![图片](./p3.png) \n\n\n* 案例3： char和short类型转换 \n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    char ch = 'a';\n    short num = 10;\n    printf(\"%d\\n\",sizeof(ch));\n    printf(\"%d\\n\",sizeof(num));\n    printf(\"%d\\n\",sizeof(ch + ch));\n    printf(\"%d\\n\",sizeof(num + num));\n    printf(\"%d\\n\",sizeof(ch + num));\n    return 0;\n}\n```\n运行结果：  \n`1 1 4 4 4`\n![图片](./p4.png)   \n原因：`char` 和 `short`自身字节数过小，只有一个字节，只要0到255的范围，很容易溢出，超过255就溢出了，所以系统为了防止溢出，只要char 和 short类型参加运算，系统会将自身类型转化成int\n\n\n### 2. 强制类型转换  \n(类型说明符)(表达式)  \n* 案例3： char和short类型转换 \n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    float x = 3.14f;\n    int j = 0;\n    // j=x;\n    j=(int)(x);\n    printf(\"j=%d\\n\",j);\n    printf(\"x=%f\\n\",x);\n    return 0;\n}\n```\n运行结果：  \n`j=3 x=3.140000`  \n![图片](./p5.png)  \n\n> 无论强制类型转换，还是自动类型转换，都是进行临时的转换，不会改变原来数据的类型\n\n## 运算符\n练习：键盘输入一个数，取出每位上的数值    \n### 1.位运算符  \n* `&：`按位与   全1为1 其他为0  \n&nbsp;&nbsp;&nbsp;&nbsp;1010 1010  \n& 1111 0000  \n······························  \n&nbsp;&nbsp;&nbsp;&nbsp;1010 0000  \n特点：和1相与 保持不变 和0相与清0  \n应用场景：将固定位清0\n> 第几位是从右往左看的，从第0位开始  \n\n\n\n* `|：`按位或    有1为1 全0为0  \n&nbsp;&nbsp;&nbsp;&nbsp;1010 1010  \n& 1111 0000  \n······························  \n&nbsp;&nbsp;&nbsp;&nbsp;1111 1010  \n特点：和1相或 值为1  和0相或 保持不变   \n应用场景：将固定位置1  \n\n* `~：`按位取反  1变0  0变1  \n~1010 1010 == 0101 0101\n应用场景：配合按位与、按位或使用  \n\n\n* `^：`按位异或  相同为0 不同为1  \n&nbsp;&nbsp;&nbsp;&nbsp;1010 1010  \n& 1111 0000  \n······························  \n&nbsp;&nbsp;&nbsp;&nbsp;0101 1010  \n特点：与0异或 保持不变；与1异或 取反  \n应用场景：将固定位发生高低电频翻转  \n\n* `<<`左移  \n左移，低位补0  \n例如：`1010 0110<<2`→`1001 1000`  \n\n* `>>`右移  \n逻辑右移：低位右移，高位补0  \n算术右移：\n    1. 无符号数： 低位右移，高位补0  \n    2. 有符号数： 低位右移，高位补符号位 \n\n> 逻辑右移还是算术右移是由编译器决定的  \n\n综合案例：  \nC语言中是不能直接表示二进制的，我们可以用十六进制来进行表示二进制四位和正好为十五，所以用十六进制表示很方便  \n```C\nunsigned char data = 0xaa;//1010 1010\n//1*2^3+0*2^2+1*2^1+0*2^0=8+0+2+0=10;10在十六进制中即为a  故为0xaa\n\n//将data的第1、5位清0\ndata = data & 1101 1101;\n/*\n1101 1101=~(0010 0010)=~(0010 0000|0000 0010)=~(0000 0001<<5|0000 0001<<1)=~(0x01<<5|0x01<<1)\n*/ \ndata = data & ~(0x01<<5|0x01<<1);\n\n//将data的第3、4位 置1\ndata = data | 0001 1000;\n/*\n0001 1000 = 0001 0000|0000 1000=0x01<<4|0x01<<3\n*/\ndata = data | 0x01<<4|0x01<<3;\n```\n> 以后一般都是这样操作的，将第m、n位清0`~(0x01<<m|0x01<<n)`  将第m、n位置1`(0x01<<m|0x01<<n)`\n\n* `,`逗号运算符  取最后一个逗号的数  \n案例1:\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    int num1=0;\n    int num2=0;\n    num1 = 3,4,5,6;\n    num2 = (3,4,5,6);\n    printf(\"num1=%d\",num1);\n    printf(\"num2=%d\",num2);\n    return 0;\n}\n```\n运行结果：`num1=3  num2=6`  \n\n* 自增自减`++ --`  \n`++i` 先加后使用\n`i++` 先使用后加  \n> 如果单独使用就没什么区别  \n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    int a=0,i=0;\n    a=i++;\n    /*即a=i;\n    i=i+1;*/\n\n    /*a=++i;\n    即i=i+1；*/\n    a=i；\n\n    return 0;\n}\n```","tags":["随记","C语言"],"categories":["随记","C语言"]},{"title":"C语言 day1","url":"/2020/05/02/C语言-day1/","content":"\n## 一、位数 字节\n一字节即1byte  \n一位即1bit  \n1b == 1024bit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<sapn style=\"color:#16a085;\">10.24程序猿节</sapn>  \n1kb == 1024b  \n1M == 1024kb  \n1G == 1024M  \n1T == 1024G  \n···········  \n\n<!-- more -->\n\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n\tprintf(\"sizeof(char)=%d\\n\",sizeof(char));\n\tprintf(\"sizeof(short)=%d\\n\",sizeof(short));\n\tprintf(\"sizeof(int)=%d\\n\",sizeof(int));\n\tprintf(\"sizeof(long)=%d\\n\",sizeof(long));\n\tprintf(\"sizeof(float)=%d\\n\",sizeof(float));\n\tprintf(\"sizeof(double)=%d\\n\",sizeof(double));\n\treturn 0;\n} \n```\n\n------------------32位平台-----------------  \nchar 字符类型 占1字节的空间（8位二进制位）  \nshort 短整型 占2字节的空间（16位二进制位）\nint 整型 占4字节的空间（32位二进制位）  \nlong 长整型 占4字节的空间（32位二进制位）  \nfloat 单精度浮点型 占4字节的空间（32位二进制位）  \ndouble 双精度浮点型 占8字节的空间（64位二进制位）  \n------------------64位平台-----------------    \nchar 字符类型 占1字节的空间（8位二进制位）    \nshort 短整型 占2字节的空间（16位二进制位）  \nint 整型 占4字节的空间（32位二进制位）  \nlong 长整型 占8字节的空间（32位二进制位）[与32位平台的差别]  \nfloat 单精度浮点型 占4字节的空间（32位二进制位）  \ndouble 双精度浮点型 占8字节的空间（64位二进制位）  \n\n\n\n## 二、 `siged` 与 `unsigned`\n1. `signed`（一般省略）  \n二进制最高位为符号位，其他位为数据位；其中1表示负数，0表示正数。\n2. `unsigned`（不能省略）  \n数据没有符号位，所有位数都是数据位。\n比如：`unsigned char` 范围0000 0000 ~ 1111 1111\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    // 定义一个有符号的int\n    signed int num1 = 10;//num1是有符号的int\n\n    // signed 默认是省略的（推荐）\n    int num2 = 10;//num2也是有符号的int\n\n    // 定义无符号的int，unsigned不能省略\n    unsigned int num3 = 10;\n\n    return 0;\n}\n```\n\n3. 输出\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    // 有符号int数据输出\n    int num1 = 0;\n    printf(\"%d\\n\",num1);\n\n    // 无符号int数据输出\n    unsigned int num2 = 0;\n    printf(\"%u\\n\",num2);\n\n    // 有符号long数据输出\n    long num3 = 0;\n    printf(\"%ld\\n\",num3);\n\n    // 无符号long数据输出\n    long num4 = 0;\n    printf(\"%lu\\n\",num4);\n\n    // 有符号short数据输出\n    long num5 = 0;\n    printf(\"%hd\\n\",num5);\n\n    // 无符号short数据输出\n    long num6 = 0;\n    printf(\"%hu\\n\",num6);\n\n    return 0;\n}\n```\n4. 输入  \n与输出类似\n\n## 三、进制\n\n## 四、`register` `sizeof` `typedef` `volatile`\n1. `register`  \n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    register int num;\n}\n```\n* 尽量把num放到寄存器中，寄存器可能满了，放不下。  \n* 如果没有标明register，如果num被高频繁使用，系统也会将其放到寄存器中  \n* <b>注意：</b>寄存器的变量不能对其取地址&num，只有在内存中的变量才有地址\n\n2. `sizeof()`  \n输出数据类型所占的字节数\n\n3. `typedef`  \n给已有的类型取一个别称\n\n步骤：\n> 1. 用已有的类型 定义一个变量\n> 2. 用别名 替换 变量名\n> 3. 在整个表达式的前方加上`typedef`   \n\n千万不要认为简单就不按步骤走；不要以为一个`typedef`后面第一个是已有类型 第二个是起的别名，旧的在中间，新的在后面。看看案例2就了解了 \n\n案例1：\n```C\n    // 1、\n    int num;\n    // 2、\n    int INT32;\n    // 3、\n    typedef int INT32;\n```\n案例2：给`int arr[5]` 取个别名\n```C\n    typedef int arr[5] ARR // × 大错特错了\n\n    // 1、\n    int arr[5];\n    // 2、\n    int ARR[5];\n    // 3、\n    typedef int ARR[5];\n// 使用 用ARR去定义变量\n    ARR arr;//arr就是一个拥有5个int元素的数组\n```\n\n4. `volatile`  \n防止编译器优化 强制访问内存的操作\n编译器对访问该变量的代码就不再进行优化，系统总是重新从它所在的内存读取数据\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    volatile int i=10\n    return 0;\n}\n```\n比如，现在有个有害气体检测装置，他检测到有害的气体的浓度，后通过一定的方式，最后存到内存中，由于气体浓度检测要求是实时的，会被CPU高频次的访问，这个时候系统会干个好事，将存在内存中的气体浓度值放到寄存器中，这个时候CPU每次都会是在寄存器中访问了，这个时候就非常危险。如果放在寄存器时的那个时刻有害气体浓度只有5%，而后有害气体浓度到达了95%这个时候cpu还是从寄存器中读取出的5%，展示给我们人的也是5%，但是这个时候实际上有害气体浓度已经很高了，人会有生命危险。\n\n## 五、实型数据 (float 与double的一些问题)\n1. 实型常量  \n实型常量也称为实数或者浮点数  \n<b>十进制形式:</b>由小数点或数字组成 0.0、0.31/4.0\n<b>指数形式:</b>123e3 表示123*10^3  \n\n> 不以f结尾的常量是double类型\n\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    printf(\"%d\",sizeof(3.14));//输出8\n    printf(\"%d\",sizeof(3.14f));//输出4\n    return 0;\n}\n```\n<b>问题</b>：  \n`float f = 3.14;`有没有问题？  \n\n答：3.14为const double 赋给 float f,将一个八字节的数据赋给了四字节的数据，但对于这个细品又似乎没有问题，好比把一个能装八升水的瓶子里的水往只能装四升水的空瓶子的倒，但是能装吧升水的瓶子也有可能只装了一升水  \n<sapn style=\"color:#e67e22;\">赋值语句等号两边类型尽量匹配</sapn> \n\n## 六、字符与字符串\n计算机是只能储存数字的，对于字符，先将其转换成对应的ASCII码值，再进行存储  \n\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    char ch = 'a';\n    return 0;\n}\n```\n过程分析：计算机先去找a对应的ASCII码值为97在赋给ch；'a'中的单引号''是取字符的ASCII码。  \n`char ch = 'a';` 与 `char ch = 97;`完全等效\n\n思考：下面现象是为什么？\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    char ch = 'a';\n    printf(\"%d\",sizeof('a'));//4字节\n    printf(\"%d\",sizeof(char));//1字节\n    printf(\"%d\",sizeof(ch));//1字节\n\n    return 0;\n}\n```\n答：单引号''是取字符的ASCII码值，第一个printf本质上是测常量97的字节数；而第二个printf测的是char类型，第三个printf测的是char类型的变量。\n\n案例：实现键盘输入abc，然后输出字符ac。  \n答：先来了解一下原理，当从键盘输入abc后，按下回车键Enter后键盘输入的abc会到标准输入设备，说人话就是一个用来缓冲的内存，当执行`ch1=getchar()`时，系统会把缓冲内存的第一个字符a拿出来给内存中的`ch1`;如果执行`getchar()`,同样的系统会把缓冲区内存中的第二个字符b取到，`getchar()`的本质就是去缓冲区拿一个字符，由于没有赋给任何变量，没有人要，那我给谁呢，系统索性就把取到的字符给扔掉了，丢弃一个字符。  \n![图片](./p4.png)\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n    char ch1='\\0',ch2='\\0';\n    printf(\"请输入abc:\");\n\n    ch1=getchar();//取到a\n    getchar();//丢弃一个字符b\n    ch2=getchar();//取到c\n\n    printf(\"ch1=%c\\n\",ch1);\n    printf(\"ch2=%c\\n\",ch2);\n\n    return 0;\n}\n```\n1. 转义字符  \n'\\n'换行  \n'\\t'缩进  \n'\\\\\\\\'表示一个斜杠'\\'  \n'%%'表示一个百分号'%'   \n\n问题：下面四项哪两个是相等的？  \nA： `printf(\"%d\",'0');`  \nB： `printf(\"%d\",'\\0');`  \nC： `printf(\"%d\",0);`  \nD： `printf(\"%d\",\"0\");`  \n答案：BC  \n\n其实看他们中哪两个相等，其实就是去判断他们中哪两个在计算机中储存的二进制相同A：字符'0'的ASCII码值为48；B：转义字符'\\0'表示的就是0；C：0就是0，不用多说了；D：字符串\"0\",表示字符串\"0\"的第0个元素的地址。\n\n2. 字符串 `\"\"`\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n\n    printf(\"%s\\n\",\"hello\");\n    printf(\"%d\\n\",sizeof(\"hello\"));//打印6\n\n    return 0;\n}\n```\n思考一下：上面hello只有五个字符，hello所占的字节数为什么是6？  \n原因就是：系统会给每个字符串的末尾自动添加一个结束符'\\0'来让计算机知道，什么时候该结束打印；字符串是第0个元素的首地址，打印的时候会一次从第0个元素往后打印知道碰到'\\0'时结束打印。我们可以用如下代码来进行验证。  \n\n> * 单引号取得是字符的ASCII码值  \n> * 双引号取得是字符串首元素的地址  \n> * `%s`从字符串的首元素逐个输出字符，直到遇到'\\0'结束\n\n```C\n#include<stdio.h>\nint main(int argc,char *argv[]){\n\n    printf(\"%s\\n\",\"hello world\");//打印hello world\n    printf(\"%s\\n\",\"hello\\0 world\");//打印hello\n    printf(\"##%s###\\n\",\"\\0hello\\0 world\");//什么都没有\n    printf(\"%d\\n\",sizeof(\"hello world\"));//打印12\n    printf(\"%d\\n\",sizeof(\"hello\\0 world\"));//打印13\n\n    return 0;\n}\n```\n思考：'a'与\"a\"有什么区别？  \n\n## 二、格式化输出\n%d 十进制有符号整数&nbsp;&nbsp;&nbsp;&nbsp;%u 十进制无符号整数  \n%x 以十六进制表示整数&nbsp;&nbsp;&nbsp;&nbsp;%0 以八进制表示整数  \n%f float性浮点数&nbsp;&nbsp;&nbsp;&nbsp;%lf double型浮点数  \n%e指数形式的浮点数&nbsp;&nbsp;&nbsp;&nbsp;%s 字符串  \n%c 单个字符&nbsp;&nbsp;&nbsp;&nbsp;%p 指针的值  \n\n<b>特殊应用： </b>   \n%3d  \n%03d 不足补0  \n%-3d 左对齐  \n%5.2  \n注意：%-03d 千万不要这样写\n\n","tags":["随记","C语言"],"categories":["随记","C语言"]},{"title":"hexo个人博客搭建","url":"/2020/04/29/hexo个人博客搭建/","content":"## 博客搭建\n**首先准备**  \n1. 安装node.js\n2. windows用户需要安装git，Mac系统自带有git  \n\n<b>百度网盘： </b> \n> https://pan.baidu.com/s/1JZc1BQ8nMCd9tibFZfS_1Q 提取码：`za4j`  \n\n<b>蓝奏云：</b>   \n> windows: git：32位[Git-2.26.2-32-bit](https://ww.lanzous.com/icsdqla) 64位[Git-2.26.2-64-bit](https://ww.lanzous.com/icsds2d)  &nbsp;&nbsp;&nbsp;&nbsp;node:32位[node-v12.16.3-x86](https://ww.lanzous.com/icsdzpi) 64位[node-v12.16.3-x64](https://ww.lanzous.com/icsdyxa)  \n\n> Mac:&nbsp;&nbsp;node &nbsp;&nbsp;[node-v12.16.3](https://ww.lanzous.com/icsew0b)  \n\n<b>本地下载： </b>   \n> windows: git：32位[Git-2.26.2-32-bit](.//Git-2.26.2-32-bit.exe) 64位[Git-2.26.2-64-bit](./Git-2.26.2-64-bit.exe)  &nbsp;&nbsp;&nbsp;&nbsp;node:32位[node-v12.16.3-x86](./node-v12.16.3-x86.msi) 64位[node-v12.16.3-x64](./node-v12.16.3-x64.msi)  \n\n> Mac:&nbsp;&nbsp;node &nbsp;&nbsp;[node-v12.16.3](./node-v12.16.3.pkg)  \n\n\n\n<!-- more -->\n### 一、第一步\n1、 在电脑中创建一个存放博客的文件夹  \n2、 终端里进入这个文件夹 `cd 文件夹路径`  \n3、 全局安装hexo `npm install hexo-cli -g`  \n因为npm是国外的源，被墙了，这里我们把源修改成国内的淘宝镜像源 `npm install -g cnpm --registry=https://registry.npm.taobao.org`后面的所有操作npm都改为cnpm\n\n### 二、第二步 建站\n1.  `hexo init` 初始化文件夹，从git克隆所需文件  \n完成后文件内容目录：  \n![目录](./pic1.png)\n2. `npm install（cnpm install）` 安装一些包\n3. `hexo server`可以简化为`hexo s`启动服务器，默认端口号为4000，地址：`http://localhost:4000/`   \n![show](./show.png)\n\n### 三、写博客\n1. `hexo new 文章名字`（`new` 可简化为`n`）\n![pic](./add1.png)\n2. 我们可以在这里找到这个刚才新建的文章\n![pic](./add2.png)\n3. 用编辑器打开就可以写了\n4. `hexo generate`(`generate`可以简化为`g`)生成静态文件\n5. `hexo s`启动服务器，我们就可以在本地`http://localhost:4000/`看到刚才写的文章了\n![pic](./pic2.png)\n\n\n### 四、部署在github\n1. 首先得有一个github账号；\n2. 新建一个仓库，注意，仓库名必须为`你的github账户.github.io`  \n比如，你的github账户名为`abc123`；那么仓库名就是`abc123.github.io`\n3. 复制仓库地址 仓库右上角那里  \n![地址](./pic3.png)\n4. 配置文件。在博客文件夹的根目录中找到`_config.yml`这个文件，打开；\n    * 翻到最底下找到\n```yml\ndeploy:\n  type: ''\n```\n![pic](./pic4.png)\n修改为：\n```yml\ndeploy:\n  type: 'git'\n  # repo: 仓库地址\n  # 例如:\n  repo: https://github.com/abc123/abc123.github.io.git\n  branch: master\n```\n5. `npm install hexo-deployer-git --save` 安装github部署插件\n6. 安装成功后。`hexo deploy`部署到github(`deploy`可简化为`d`)\n![pic](./pic5.png)\n7. 会提示输入用户名和密码，输入后就可以把文件提交到仓库去了\n8. 提交成功后，就可以通过仓库名进行访问了，例如`https://abc123.github.io`\n\n\n### 五、换主题\n1. ","tags":["博客搭建"],"categories":["hexo"]},{"title":"jQuery设计思想03","url":"/2020/04/27/jQuery设计思想03/","content":"## JQ与JS的关系\njq地下都是由js面向对象进行封装的\n`$(\"#div1\")`他实际上是一个jQuery对象，只能调用jQuery封装的函数，不能使用js原生的方法\n\n**可以共存，不能混用**  \n> 不能前一半js后一半jq  \n> 也不能前一半jq后一半js\n<!-- more -->","tags":["jq"],"categories":["jQuery入门","jq设计思想"]},{"title":"jQuery设计思想02","url":"/2020/04/27/jQuery设计思想02/","content":"## jQuery写法\n1、方法函数化  \n2、链式操作  \n3、取值赋值一体化(合体)\n<!-- more -->\n---\n\n### 一、方法函数化\n1. 在js中，我们如果把js代码写在html代码之前，而且要获取到html中的元素，通常我们会写`window.onload = function () {···}`  \n那么在jq中，将其函数化了成了`$(fuction(){···});`  \n2. 在js中事件函数是这样的`abtn.onclick = fuction(){···}`，而在jq中将其函数化成了`$(\"button\").click(fuction{···})`  \n其他的事件也是类似的，了解这一个其他的所有事件就都会了\n3. 在js中，要修改或者获取样式时需要这样`div.style.background = ···`，对于获取样式来说，这个还只能获取到某个元素的行间样式，如果要获取到非行间样式的话就有几种方法了，而且还要做兼容处理  \n然而jq中就很方便了只需使用`css()`这个方法，行间和非行间样式都能获取到  \n例如，\n```html\n    <style>\n        div{\n            background-color: green;\n        }\n    </style>\n    <div style=\"font-size: 18px;\">我是一个div</div>\n    <script>\n        console.log($(\"div\").css(\"background\"));\n        console.log($(\"div\").css(\"fontSize\"));\n    </script>\n```\n## 注： ##  \n`css()`要想修改多个样式，可通过一个对象来进行传参。\n```html\n    <script>\n        $(\"div\").css({\n            \"background\" : \"blue\",\n            \"fontSize\" : \"18px\",\n            \"color\" : \"orange\"\n        });\n    </script>\n```\n效果：  \n![效果](./p1.png)\n\n### 二、链式操作\n如果我们要对一个对象进行多个不同的操作时，我们可以通过这个来简化代码。  \n例如：  \n```html\n<div>快到我碗里来！</div>\n    <script>\n        $(\"div\").css({\n            \"background\" : \"blue\",\n            \"fontSize\" : \"18px\",\n            \"color\" : \"orange\"\n        });\n        $(\"div\").click(function(){\n            alert(\"hello\");\n        });\n        $(\"div\").mouseover(function(){\n            $(this).css(\"background\",\"pink\")\n        });\n        $(\"div\").mouseout(function(){\n            $(this).css(\"background\",\"blue\")\n        });\n    </script>\n```\n\n可修改为：  \n{% code lang:html %}\n<div>快到我碗里来！</div>\n    <script>\n        $(\"div\").css({\n                \"background\": \"blue\",\n                \"fontSize\": \"18px\",\n                \"color\": \"orange\"\n            })\n            .click(function () {\n                alert(\"hello\");\n            })\n            .mouseover(function () {\n                $(this).css(\"background\", \"pink\")\n            })\n            .mouseout(function () {\n                $(this).css(\"background\", \"blue\")\n            });\n    </script>\n{% endcode %}\n只用将第一个语句的分号去掉，后面用.号连起来就ok了  \n效果是同样的：  \n\n![效果](./p2.png)\n\n### 三、取值赋值一体化(合体)  \n\njq中将取值赋值合体了，学会一个相当于学会了两个。  \n## 1. 取值\n取值不传入参数就行了。  \njs中的`innerHTML`jq中为`html()`  \njs中的`value`jq中为`val()`  \n\n{% code lang:html %}\n    <div>快到我碗里来！</div>\n    <input type=\"text\" value=\"我不！\">\n    <script>\n        console.log($(\"div\").html());\n        console.log($(\"input\").val());\n    </script>\n{% endcode %}\n效果：  \n![效果](./p3.png)  \n\n## 2. 赋值\n需要传入参数  \n\n{% code lang:html %}\n    <div>快到我碗里来！</div>\n    <input type=\"text\" value=\"我不！\">\n    <script>\n        $(\"div\").html(\"hello\")\n        $(\"input\").val(\"world!\")\n    </script>\n{% endcode %}\n效果：  \n![效果](./p4.png)  \n\n\n","tags":["jq"],"categories":["jQuery入门","jq设计思想"]},{"title":"解决网易云版权原因无法生成外链","url":"/2020/04/26/解决网易云版权原因无法生成外链/","content":"## 问题\n没有生成外链播放器的图标，或者即使有也是由于版权原因无法生成，如图：  \n![问题](./pic1.png)  \n<!-- more -->\n没有生成图标  \n![问题](./pic2.png)  \n这个是有图标的  \n![问题](./pic6.png)\n## 解决方案\n1. 打开需要生成外链的歌单或者歌曲；\n2. 找到播放按钮；\n3. 右键，检查元素；\n4. 找到data-res-id=\"\"的值，即为id；  \n如图：\n![问题](./pic3.png)  \n![问题](./pic4.png)  \n![问题](./pic5.png)  \n\n\n### 最后最后最后\n\n1. 最后我们可以找一个没有版权可以生成外链的歌单或者歌曲（什么？你问我怎么判断哪个歌单或者歌曲没有版权？！！）\n> 两张图片自己领会  \n\n![问题](./pic7.png)  \n![问题](./pic8.png)  \n\n2. 找到没有版权问题的歌曲或者歌单后点击生成外链播放器\n\n3. 把得到iframe代码把其src中的查询字符串中的id改成刚才得到的id,然后放在自己的blog中，然后呢？...然后就没然后了。给个效果吧。\n```html\n<body>\n    <iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=522510615&auto=1&height=66\"></iframe>\n    <iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=450 src=\"//music.163.com/outchain/player?type=0&id=2857711620&auto=1&height=430\"></iframe>\n</body>\n```\n![问题](./pic9.png)  \n\n\n> [我的博客](http://desire599.github.io/)中的的音乐播放器也是类似的哦，也给个效果吧\n![问题](./pic10.png)  \n![问题](./pic11.png)  \n\n\n","categories":["随记"]},{"title":"jQuery设计思想01","url":"/2020/04/26/jQuery设计思想01/","content":"## 选择网页元素\n1. 模拟css选择元素    \n{% raw %}  \n<div>\n<span style=\"color:#ff6666\">请参阅CSS选择器参考手册：</span>\n<a href=\"http://www.runoob.com/cssref/css-selectors.html\">http://www.runoob.com/cssref/css-selectors.html</a>\n</div>\n{% endraw %}  \n2. 独有表达式选择    \n3. 多种筛选方式\n\n<!-- more -->\n\n---\n###  一、模拟css选择元素\n在css中我们可以通过下面这种方式获取到元素，并修改其样式\n```html\n    <style>\n        #div1{\n            background-color: brown;\n        }\n        .p1{\n            background-color: cadetblue;\n            color: darkgreen;\n        }\n    </style>\n    <div id=\"div1\">我是div1</div>\n    <p class=\"p1\">我是p1</p>\n```\n效果：  \n{% raw %}  \n    <style>\n        #div1{\n            background-color: brown;\n        }\n        .p1{\n            background-color: cadetblue;\n            color: darkgreen;\n        }\n    </style>\n    <div id=\"div1\">我是div1</div>\n    <p class=\"p1\">我是p1</p>\n{% endraw %} \n\n在jQuery中，模仿css选择器获取元素，同样地也是这个样子，如下：\n```html\n    <div id=\"div2\">我是div2</div>\n    <p class=\"p2\">我是p2</p>\n    <script src=\"https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js\"></script>\n    <script>\n        $(\"#div2\").css(\"backgroundColor\", \"brown\");\n        $(\".p2\").css({\n            \"backgroundColor\": \"cadetblue\",\n            \"color\": \"darkgreen\"\n        });\n    </script>\n```\n效果跟上面是同样的：(为了避免上面css对下面的影响，id与class修改了)   \n{% raw %}\n    <div id=\"div2\">我是div2</div>\n    <p class=\"p2\">我是p2</p>\n    <script src=\"https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js\"></script>\n    <script>\n        $(\"#div2\").css(\"backgroundColor\", \"brown\");\n        $(\".p2\").css({\n            \"backgroundColor\": \"cadetblue\",\n            \"color\": \"darkgreen\"\n        });\n    </script>\n{% endraw %}\n\n* **css中能使用的选择器，在jQuery几乎都可以使用**  \n> [jQuery选择器](https://www.runoob.com/jquery/jquery-ref-selectors.html)  \n\n---\n### 二、独有表达式选择  \n{% raw %}\n<table border=\"1\">\n  <tr>\n    <th>选择器</th>\n    <th>实例</th>\n    <th>选取</th>\n  </tr>\n  <tr>\n    <td>:first</td>\n    <td>$(\"p:first\")</td>\n    <td>页面所有p元素中的第一个 p 元素</td>\n  </tr>\n  <tr>\n    <td>:last</td>\n    <td>$(\"p:last\")</td>\n    <td>页面所有p元素中的最后一个 p 元素</td>\n  </tr>\n  <tr>\n    <td>:even</td>\n    <td>$(\"li:even\")</td>\n    <td>所有偶数 li 元素，索引值从 0 开始，第一个元素是偶数 (0)，第二个元素是奇数 (1)，以此类推。</td>\n  </tr>\n  <tr>\n    <td>:odd</td>\n    <td>$(\"li:even\")</td>\n    <td>所有奇数 li 元素，索引值从 0 开始，第一个元素是偶数 (0)，第二个元素是奇数 (1)，以此类推。</td>\n  </tr>\n  <tr>\n    <td>:eq</td>\n    <td>$(\"li:eq(2)\")</td>\n    <td>li兄弟节点中的第三个</td>\n  </tr>\n  \n</table>\n{% endraw %}  \n\n* `:first`与`:last`\n```html\n    <p>我是第1个p</p>\n    <p>我是第2个p</p>\n    <p>我是第3个p</p>\n    <script>\n        $(\"p:first\").css(\"background\",\"red\");\n        $(\"p:last\").css(\"background\",\"blue\");\n    </script>\n```\n运行结果：  \n![代码结果](./pic1.png) \n\n* `:even`与`:odd`\n```html\n    <ul>\n        <li>我是第1个li</li>\n        <li>我是第2个li</li>\n        <li>我是第3个li</li>\n        <li>我是第4个li</li>\n        <li>我是第5个li</li>\n    </ul>\n    <script>\n        $(\"li:even\").css(\"background\",\"#99CC99\");//浅绿\n        $(\"li:odd\").css(\"background\",\"#FF6666\");//淡红\n    </script>\n```\n运行结果：  \n![代码结果](./pic2.png) \n\n* `:eq()`\n```html\n    <ul>\n        <li>我是第1个li</li>\n        <li>我是第2个li</li>\n        <li>我是第3个li</li>\n        <li>我是第4个li</li>\n        <li>我是第5个li</li>\n    </ul>\n    <script>\n        $(\"li:eq(2)\").css(\"background\",\"blue\");\n    </script>\n```\n运行结果：  \n![代码结果](./pic3.png)\n\n### 三、多种筛选方式\n{% raw %}\n<p style=\"color:#FF6600;font-weight:bold;font-size:15px\">一种效果有多种方式去实现，想怎么操作就怎么操作</p>\n{% endraw %}\n1. 比如，我们要使下面第三个li标签背景变为绿色，除了可以使用`:eq()`,还可以使用`.eq()`\n```html\n    <ul>\n        <li>我是第1个li</li>\n        <li>我是第2个li</li>\n        <li>我是第3个li</li>\n        <li>我是第4个li</li>\n        <li>我是第5个li</li>\n    </ul>\n```\n```html\n    <script>\n        $(\"li\").eq(2).css(\"background\",\"green\");\n    </script>\n```\n运行结果：  \n![代码结果](./pic4.png)\n\n2. 再比如，我们要使li标签中，class=box的标签背景色变为粉红色，下面两种方法都可以\n```html\n    <ul>\n        <li class=\"box\">我是第1个li</li>\n        <li>我是第2个li</li>\n        <li>我是第3个li</li>\n        <li class=\"box\">我是第4个li</li>\n        <li>我是第5个li</li>\n    </ul>\n```\n方法1：\n```html\n    <script>\n        $(\"li.box\").css(\"background\",\"pink\");\n    </script>\n```\n方法2：\n```html\n    <script>\n        $(\"li\").filter(\".box\").css(\"background\",\"pink\");\n    </script>\n```\n运行结果：  \n![代码结果](./pic5.png)\n\n## jQuery写法\n1、方法函数化  \n2、链式操作  \n3、取值赋值一体化(合体)\n\n## JQ与JS的关系\n\njq地下都是由js面向对象进行封装的\n$(\"#div1\")他实际上是一个jQuery对象，只能调用jQuery封装的函数\n\n**可以共存，不能混用**\n不能前一半js后一般jq\n也不能前一半jq后一般js","tags":["jq","教程"],"categories":["jQuery入门","jq设计思想"]},{"title":"jQuery简介01","url":"/2020/04/26/jQuery简介/","content":"## 什么是jQuery?  \n![jquery](./pic1.png)  \n1、 一个快速、简洁、小型且功能丰富的JavaScript库;<!-- more -->  \n2、设计宗旨“write Less，Do more”;  \n3、jQuery兼容各种主流浏览器，如IE 6.0+、FF 1.5+、Safari 2.0+、Opera 9.0+等;\n\n## jQuery的好处？\n1、简化的js的复杂操作;  \n2、不再需要关心兼容性;  \n3、提供了大量实用方法;  \n4、使HTML文档的遍历和操作，事件处理，动画和Ajax等事情变得更加简单;  \n5、兼具多功能性和可扩展性;\n\n## 如何学习jQuery？  \n1、[jQuery官网](https://jquery.com/) JQ的官方网站(查阅中文文档)  \n2、JQ只是一个辅助工具，要正确面对  \n3、分阶段学习（先打好js的基础）  \n\n+ **jQ版本的区别**  \n\n| 版本 |  描述 |\n| :----: | :----: |\n|1.x|兼容ie678，使用最为广泛的，官方只做bug维护，功能不再新增。因此一般项目来说，使用1.x版本就可以了，最终版本：1.12.4|\n|2.x|不兼容ie678，很少人使用，官方只做bug维护，功能不再新增。如果不考虑兼容版本低的浏览器可以使用2.x，最终版本：2.2.4|\n|3.x|不兼容ie678，只支持最新的浏览器。除非特殊要求，一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。目前该版本是官方主要更新维护的版本。截至2018年6月13日，最新版本：3.5.0|  \n\n`后面所有代码均以1.x版本为准`\n> 版本区别参考：[吠品的IT笔记](https://www.cnblogs.com/osfipin/p/6211468.html)\n","tags":["jq","教程"],"categories":["jQuery入门","介绍"]},{"title":"如何获取被选择的文本","url":"/2020/04/24/获取被选择的文字/","content":"\n* 兼容性   \nIE9以下支持：`document.selection `  \nIE9、Firefox、Safari、Chrome和Opera支持：`window.getSelection()`\n---\n### 解决方法\n* 直接上代码\n<!-- more -->\n```html\n    <div id=\"content\">\n        心墙<br />\n        林俊杰<br />\n        一个人 眺望碧海和蓝天<br />\n        在心里面那抹灰就淡一些 海豚从眼前飞越<br />\n        我看见了最阳光的笑脸<br />\n        好时光都该被宝贝 因为有限<br />\n        我学着不去担心得太远 不计划太多反而能勇敢冒险<br />\n        丰富地过每一天 快乐地看每一天<br />\n    </div>\n    <script>\n        //封装一个获取被选择文本的函数\n        function getSelectedText() {\n            if (document.selection) {\n                return document.selection.createRange().text;\n            } else {\n                return window.getSelection().toString();\n            }\n        }\n        const oContent = document.getElementById(\"content\");\n        oContent.onmouseup = function () {\n            let words = getSelectedText();\n            if (words) {\n                alert(words);\n            }\n        }\n    </script>\n```\n运行结果：  \n![运行结果](./images/result1.png \"运行结果\")  \n\n---\n### 拓展\n> * [`Selection` API文档](https://developer.mozilla.org/zh-CN/docs/Web/API/Selection)\n","tags":["js"],"categories":["随记"]},{"title":"option触发事件","url":"/2020/04/23/option触发事件/","content":"## 实现select指定option选中触发事件\n有时候我们需要对下拉列表select中的option添加事件，但实际上option是没有触发事件的，那怎么办呢？  \n但是，select是有触发事件的，我们可以利用他的触发事件来间接的给option添加触发事件\n### 解决方案\n<!-- more -->\n* 代码实现\n```html\n    <select name=\"\" id=\"sel\">\n        <option value=\"a\" name=\"beijing\">北京</option>\n        <option value=\"b\" name=\"shanghai\">上海</option>\n        <option value=\"c\" name=\"wuhan\">武汉</option>\n    </select>\n    <script>\n        var select = document.getElementById(\"sel\");\n        select.onchange = function(){\n            console.log(\"点击了第\" + select.selectedIndex + 1 + \"选项\");\n            console.log(\"这个选项的内容是\" + select.options[select.selectedIndex].innerHTML);\n        }\n    </script>\n```\n运行结果如图：\n![代码结果](./result1.png)\n\n---\n\n* 分析  \n我们通过给select添加onchange事件，当我们选择(点击)某一项时，也就触发了这个事件，接下来我们通过select.selectedIndex获得到了被选择的选项，然后就可以对被选择的项进行操作；看起来就像是option的事件，实际上是在select上添加的onchange事件。\n\n* 深入  \n看一看这些属性\n```html\n    <select name=\"\" id=\"sel\">\n        <option value=\"a\" name=\"beijing\">北京</option>\n        <option value=\"b\" name=\"shanghai\">上海</option>\n        <option value=\"c\" name=\"wuhan\">武汉</option>\n    </select>\n    <script>\n        var select = document.getElementById(\"sel\");\n        console.log(select.options);\n        console.log(select.options[0]);\n        console.log(select.options[0].innerHTML);\n        console.log(select.options[0].value);\n\n        select.onchange = function(){\n            //输出当前点击元素的下标\n            console.log(select.selectedIndex);\n        }\n    </script>\n```\n运行结果如图：\n![运行结果](./analyze1.png)  \n---","tags":["jq","js"],"categories":["随记"]},{"title":"css布局-flex","url":"/2020/04/23/css布局-flex/","content":"{% raw %}\n\n    <div>一、Flex布局是什么？</div>\n    <div>    Flex是Flexible Box的缩写，意为“弹性布局”，用来给盒状模型提供最大的灵活性。</div>\n    <div>    任何一个容器都可以指定为flex布局。</div>\n    <!-- more -->\n    <div\n        style=\"box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;\">\n        <div>.box{</div>\n        <div>  display: flex;</div>\n        <div><span style=\"font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco;\">}</span></div>\n    </div>\n    <div>    行内元素也可以使用flex布局。</div>\n    <div\n        style=\"box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;\">\n        <div>.box{</div>\n        <div>  display: inline-flex;</div>\n        <div>}</div>\n    </div>\n    <div>    Webkit内核的浏览器，必须加上<span\n            style=\"font-weight: bold; background-color: rgb(255, 250, 165);-evernote-highlight:true;\">-webkit</span>前缀。\n    </div>\n    <div\n        style=\"box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;\">\n        <div>.box{</div>\n        <div>  display: -webkit-flex; /* Safari */</div>\n        <div>  display: flex;</div>\n        <div>}</div>\n    </div>\n    <div>    注意：设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。</div>\n    <hr />\n    <div>二、基本概念</div>\n    <div><span style=\"font-size: 14px; font-family: &quot;Helvetica Neue&quot;;\">    采用 Flex 布局的元素，称为 Flex 容器（flex\n            container），简称\"容器\"。它的所有子元素自动成为容器成员，</span></div>\n    <div><span style=\"font-size: 14px; font-family: &quot;Helvetica Neue&quot;;\">    称为 Flex 项目（flex\n            item），简称\"项目\"。</span></div>\n    <div><img src=\"./68E3597E-83A8-46D5-B234-7EC273DC7F03.png\" height=\"333\"\n            width=\"563\" /><br /></div>\n    <div><span style=\"font-size: 14px; font-family: &quot;Helvetica Neue&quot;;\">    容器默认存在两根轴：水平的主轴（main\n            axis）和垂直的交叉轴（cross axis）。主轴的开始位置</span></div>\n    <div><span style=\"font-family: &quot;Helvetica Neue&quot;; font-size: 14px;\">    （与边框的交叉点）叫做</span><span\n            style=\"font-family: &quot;Helvetica Neue&quot;; font-size: 14px; font-weight: bold; background-color: rgb(255, 250, 165);-evernote-highlight:true;\">main\n            start</span><span style=\"font-family: &quot;Helvetica Neue&quot;; font-size: 14px;\">，结束位置叫做</span><span\n            style=\"font-family: &quot;Helvetica Neue&quot;; font-size: 14px; font-weight: bold; background-color: rgb(255, 250, 165);-evernote-highlight:true;\">main\n            end</span><span style=\"font-family: &quot;Helvetica Neue&quot;; font-size: 14px;\">；交叉轴的开始位置叫做</span><span\n            style=\"font-family: &quot;Helvetica Neue&quot;; font-size: 14px; font-weight: bold; background-color: rgb(255, 250, 165);-evernote-highlight:true;\">cross\n            start</span><span style=\"font-family: &quot;Helvetica Neue&quot;; font-size: 14px;\">，</span></div>\n    <div><span style=\"font-family: &quot;Helvetica Neue&quot;; font-size: 14px;\">    结束位置叫做</span><span\n            style=\"background-color: rgb(255, 250, 165);-evernote-highlight:true;\"><span\n                style=\"font-family: &quot;Helvetica Neue&quot;; font-size: 14px; background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;\">cross\n                end</span></span><span style=\"font-family: &quot;Helvetica Neue&quot;; font-size: 14px;\">。</span></div>\n    <div><span style=\"font-size: 14px;\"><br /></span></div>\n    <div><span style=\"font-size: 14px; font-family: &quot;Helvetica Neue&quot;;\">    项目默认沿主轴排列。单个项目占据的主轴空间叫做</span><span\n            style=\"font-weight: bold; background-color: rgb(255, 250, 165); font-family: &quot;Helvetica Neue&quot;; font-size: 14px;-evernote-highlight:true;\">main\n            size</span><span style=\"font-size: 14px; font-family: &quot;Helvetica Neue&quot;;\">，占据的交叉轴空间叫做</span><span\n            style=\"font-size: 14px; background-color: rgb(255, 250, 165);-evernote-highlight:true;\"><span\n                style=\"background-color: rgb(255, 250, 165); font-family: &quot;Helvetica Neue&quot;; font-size: 14px; font-weight: bold;-evernote-highlight:true;\">cross\n                size</span></span><span style=\"font-size: 14px; font-family: &quot;Helvetica Neue&quot;;\">。</span></div>\n    <hr />\n    <div><span style=\"font-family: &quot;Helvetica Neue&quot;; font-size: 14px;\">三、容器的属性</span></div>\n    <div><span style=\"font-family: &quot;Helvetica Neue&quot;; font-size: 14px;\">    以下六个属性是作用在容器上的</span></div>\n    <div>\n        <font face=\"Helvetica Neue\" style=\"font-size: 14px;\">\n            <div\n                style=\"box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;\">\n                <div>* flex-direction</div>\n                <div>* flex-wrap</div>\n                <div>* flex-flow</div>\n                <div>* justify-content</div>\n                <div>* align-items</div>\n                <div>* align-content</div>\n            </div>\n        </font>\n    </div>\n    <div><span style=\"font-family: &quot;Helvetica Neue&quot;; font-size: 14px;\">   </span></div>\n    <div><span style=\"font-family: &quot;Helvetica Neue&quot;; font-size: 14px; font-weight: bold;\">    3.1</span><span\n            style=\"font-family: &quot;Helvetica Neue&quot;; font-size: 14px;\">  flex-direction属性</span></div>\n    <div><span style=\"font-family: &quot;Helvetica Neue&quot;; font-size: 14px;\">        </span><span\n            style=\"font-family: &quot;Helvetica Neue&quot;; font-size: 14px; font-weight: bold; background-color: rgb(255, 250, 165);-evernote-highlight:true;\">flex-derection</span><span\n            style=\"font-family: &quot;Helvetica Neue&quot;; font-size: 14px;\">属性决定项目在主轴的方向（即项目的排序方向）。</span></div>\n    <div>\n        <font style=\"font-size: 14px;\" face=\"Helvetica Neue\">\n            <div\n                style=\"box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;\">\n                <div>.box {</div>\n                <div>  flex-direction: row | row-reverse | column | column-reverse;</div>\n                <div>}</div>\n            </div>\n        </font>\n    </div>\n    <div><br /></div>\n    <div><img src=\"./5A8FDE38-43E7-4B95-ADC1-B7E05A7A6A03.png\" height=\"203\"\n            width=\"796\" /><br /></div>\n    <div>\n        <font style=\"font-size: 14px;\" face=\"Helvetica Neue\"><br /></font>\n    </div>\n    <div\n        style=\"box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;\">\n        <div>\n            <font style=\"font-size: 14px;\">* row（默认值）：主轴为水平方向，起点在左端。</font>\n        </div>\n        <div>\n            <font style=\"font-size: 14px;\">* row-reverse：主轴为水平方向，起点在右端。</font>\n        </div>\n        <div>\n            <font style=\"font-size: 14px;\">* column：主轴为垂直方向，起点在上沿。</font>\n        </div>\n        <div>\n            <font style=\"font-size: 14px;\">* column-reverse：主轴为垂直方向，起点在下沿。</font>\n        </div>\n    </div>\n    <hr />\n    <div>    <span style=\"font-weight: bold;\">3.2 </span>flex-wrap属性</div>\n    <div>    <span\n            style=\"font-family: &quot;Helvetica Neue&quot;;\">默认情况下，项目都排在一条线（又称\"轴线\"）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。</span>\n    </div>\n    <div>\n        <font style=\"font-size: 14px;\" face=\"Helvetica Neue\"><br /></font>\n    </div>\n    <div><img src=\"./25C8694E-B101-4E44-9171-416DC1FDF9A9.png\" height=\"276\"\n            width=\"798\" /><br /></div>\n    <div><br /></div>\n    <div\n        style=\"box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;\">\n        <div>\n            <div>.box{</div>\n        </div>\n        <div>  flex-wrap: nowrap | wrap | wrap-reverse;</div>\n        <div>}</div>\n    </div>\n    <div>\n        <font style=\"font-size: 14px;\" face=\"Helvetica Neue\"><br /></font>\n    </div>\n    <div><span style=\"font-family: &quot;Helvetica Neue&quot;; font-size: 14px;\">    </span><span\n            style=\"font-family: &quot;Helvetica Neue&quot;; font-size: 14px; font-weight: bold;\">（1）</span><span\n            style=\"font-family: &quot;Helvetica Neue&quot;; font-size: 14px;\">nowrap（默认）：不换行</span></div>\n    <div>\n        <font style=\"font-size: 14px;\" face=\"Helvetica Neue\"><br /></font>\n    </div>\n    <div><img src=\"./AF0C0306-2F02-4180-A10A-6CBC8038D983.png\" height=\"145\"\n            width=\"700\" /><br /></div>\n    <div>    <span style=\"font-weight: bold;\">（2）</span>wrap：换行，第一行在上方</div>\n    <div><br /></div>\n    <div><img src=\"./D12922E9-32AF-4412-A144-787253F41EDA.png\" height=\"177\"\n            width=\"700\" /><br /></div>\n    <div>\n        <font style=\"font-size: 14px;\" face=\"Helvetica Neue\"><br /></font>\n    </div>\n    <div><span style=\"font-family: &quot;Helvetica Neue&quot;; font-size: 14px;\">    </span><span\n            style=\"font-family: &quot;Helvetica Neue&quot;; font-size: 14px; font-weight: bold;\">（3）</span><span\n            style=\"font-family: &quot;Helvetica Neue&quot;; font-size: 14px;\">wrap-reverse : 换行，第一行在下方。</span></div>\n    <div>\n        <font style=\"font-size: 14px;\" face=\"Helvetica Neue\"><br /></font>\n    </div>\n    <div><img src=\"./A34887DC-0230-4AC7-90BD-ADE77D2F809A.png\" height=\"177\"\n            width=\"700\" /><br /></div>\n    <div>\n        <font style=\"font-size: 14px;\" face=\"Helvetica Neue\"><br /></font>\n    </div>\n    <div><span style=\"font-family: &quot;Helvetica Neue&quot;; font-size: 14px; font-weight: bold;\">    3.3 </span><span\n            style=\"font-family: &quot;Helvetica Neue&quot;; font-size: 14px;\">flex-flow</span></div>\n    <div><span style=\"font-family: &quot;Helvetica Neue&quot;; font-size: 14px;\">      \n             flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</span></div>\n    <div><br /></div>\n    <div\n        style=\"box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;\">\n        <div>\n            <div>.box {</div>\n            <div>  flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</div>\n            <div>}</div>\n        </div>\n    </div>\n    <div>\n        <font style=\"font-size: 14px;\" face=\"Helvetica Neue\"><br /></font>\n    </div>\n    <div>   <font style=\"font-size: 14px;\"><span\n                style=\"font-size: 14px; font-family: &quot;Helvetica Neue&quot;;\"> </span><span\n                style=\"font-size: 14px; font-family: &quot;Helvetica Neue&quot;; font-weight: bold;\">3.4</span><span\n                style=\"font-size: 14px; font-family: &quot;Helvetica Neue&quot;;\"> justify-content属性</span></font>\n    </div>\n    <div><span style=\"font-family: &quot;Helvetica Neue&quot;; font-size: 14px;\">      \n             justify-content属性定义了项目在主轴上的对齐方式。</span></div>\n    <div><br /></div>\n    <div\n        style=\"box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;\">\n        <div>\n            <div>.box {</div>\n            <div>  justify-content: flex-start | flex-end | center | space-between | space-around;</div>\n            <div>}</div>\n        </div>\n    </div>\n    <div><br /></div>\n    <div\n        style=\"box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;\">\n        <div>\n            <font face=\"Helvetica Neue\" style=\"font-size: 14px;\">它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</font>\n        </div>\n        <div>\n            <font face=\"Helvetica Neue\" style=\"font-size: 14px;\"><br /></font>\n        </div>\n        <div>\n            <font face=\"Helvetica Neue\" style=\"font-size: 14px;\">* flex-start（默认值）：左对齐</font>\n        </div>\n        <div>\n            <font face=\"Helvetica Neue\" style=\"font-size: 14px;\">* flex-end：右对齐</font>\n        </div>\n        <div>\n            <font face=\"Helvetica Neue\" style=\"font-size: 14px;\">* center： 居中</font>\n        </div>\n        <div>\n            <font face=\"Helvetica Neue\" style=\"font-size: 14px;\">* space-between：两端对齐，项目之间的间隔都相等。</font>\n        </div>\n        <div>\n            <font face=\"Helvetica Neue\" style=\"font-size: 14px;\">* space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍\n            </font>\n        </div>\n    </div>\n    <div><img src=\"./107B8607-5917-4F10-950F-4FFD1FD2E057.png\" height=\"763\"\n            width=\"637\" /><br /></div>\n    <div><br /></div>\n    <div><span style=\"font-size: 14px; font-family: &quot;Helvetica Neue&quot;;\"><span\n                style=\"font-family: &quot;Helvetica Neue&quot;; font-size: 14px; font-weight: bold;\">3.5</span>\n            align-items属性</span></div>\n    <div><span style=\"font-size: 14px; font-family: &quot;Helvetica Neue&quot;;\">    align-items属性定义项目在交叉轴上如何对齐。</span>\n    </div>\n    <div><br /></div>\n    <div\n        style=\"box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;\">\n        <div>\n            <div>\n                <font face=\"Helvetica Neue\" style=\"font-size: 14px;\">.box {</font>\n            </div>\n            <div>\n                <font face=\"Helvetica Neue\" style=\"font-size: 14px;\">  align-items: flex-start | flex-end | center |\n                    baseline | stretch;</font>\n            </div>\n            <div>\n                <font face=\"Helvetica Neue\" style=\"font-size: 14px;\">}</font>\n            </div>\n        </div>\n    </div>\n    <div>\n        <font style=\"font-size: 14px;\" face=\"Helvetica Neue\"><br /></font>\n    </div>\n    <div>\n        <font style=\"font-size: 14px;\" face=\"Helvetica Neue\"><br /></font>\n    </div>\n    <div><img src=\"./BE917C52-1217-4FAE-B0CB-F32C3EC3BE0A.png\" height=\"786\"\n            width=\"617\" /><br /></div>\n    <div>\n        <font style=\"font-size: 14px;\" face=\"Helvetica Neue\"><br /></font>\n    </div>\n    <div\n        style=\"box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;\">\n        <div>\n            <font face=\"Helvetica Neue\" style=\"font-size: 14px;\">它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</font>\n        </div>\n        <div>\n            <font face=\"Helvetica Neue\" style=\"font-size: 14px;\"><br /></font>\n        </div>\n        <div>\n            <div>\n                <font face=\"Helvetica Neue\" style=\"font-size: 14px;\">* flex-start：交叉轴的起点对齐。</font>\n            </div>\n            <div>\n                <font face=\"Helvetica Neue\" style=\"font-size: 14px;\">* flex-end：交叉轴的终点对齐。</font>\n            </div>\n            <div>\n                <font face=\"Helvetica Neue\" style=\"font-size: 14px;\">* center：交叉轴的中点对齐。</font>\n            </div>\n            <div>\n                <font face=\"Helvetica Neue\" style=\"font-size: 14px;\">* baseline: 项目的第一行文字的基线对齐。</font>\n            </div>\n            <div>\n                <font face=\"Helvetica Neue\" style=\"font-size: 14px;\">* stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</font>\n            </div>\n        </div>\n    </div>\n    <div><br /></div>\n    <div><span style=\"font-size: 14px; font-family: &quot;Helvetica Neue&quot;;\">3.6 align-content属性</span></div>\n    <div><span style=\"font-size: 14px; font-family: &quot;Helvetica Neue&quot;;\">  \n             align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</span></div>\n    <div><br /></div>\n    <div\n        style=\"box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;\">\n        <div>\n            <div>\n                <font face=\"Helvetica Neue\" style=\"font-size: 14px;\">.box {</font>\n            </div>\n            <div>\n                <font face=\"Helvetica Neue\" style=\"font-size: 14px;\">  align-content: flex-start | flex-end | center |\n                    space-between | space-around | stretch;</font>\n            </div>\n            <div>\n                <font face=\"Helvetica Neue\" style=\"font-size: 14px;\">}</font>\n            </div>\n        </div>\n    </div>\n    <div><br /></div>\n    <div\n        style=\"box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;\">\n        <div>\n            <font face=\"Helvetica Neue\" style=\"font-size: 14px;\">该属性可能取6个值。</font>\n        </div>\n        <div>\n            <div>\n                <font face=\"Helvetica Neue\" style=\"font-size: 14px;\">* flex-start：与交叉轴的起点对齐。</font>\n            </div>\n            <div>\n                <font face=\"Helvetica Neue\" style=\"font-size: 14px;\">* flex-end：与交叉轴的终点对齐。</font>\n            </div>\n            <div>\n                <font face=\"Helvetica Neue\" style=\"font-size: 14px;\">* center：与交叉轴的中点对齐。</font>\n            </div>\n            <div>\n                <font face=\"Helvetica Neue\" style=\"font-size: 14px;\">* space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</font>\n            </div>\n            <div>\n                <font face=\"Helvetica Neue\" style=\"font-size: 14px;\">* space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n                </font>\n            </div>\n            <div>\n                <font face=\"Helvetica Neue\" style=\"font-size: 14px;\">* stretch（默认值）：轴线占满整个交叉轴。</font>\n            </div>\n        </div>\n    </div>\n    <div><br /></div>\n    <div><img src=\"./57712AF8-A499-4406-A218-82361B032F1F.png\" height=\"786\"\n            width=\"620\" /><br /></div>\n    <div><br /></div>\n    <hr />\n    <div><br /></div>\n    <div>四、项目的属性</div>\n    <div>    以下六个属性是作用在项目上的。</div>\n    <div\n        style=\"box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;\">\n        <div>* order</div>\n        <div>* flex-grow</div>\n        <div>* flex-shrink</div>\n        <div>* flex-basis</div>\n        <div>* flex</div>\n        <div>* align-self</div>\n    </div>\n    <div><br /></div>\n    <div><span style=\"font-weight: bold;\">4.1</span> order属性</div>\n    <div>    order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</div>\n    <div><br /></div>\n    <div\n        style=\"box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;\">\n        <div>\n            <div>.item {</div>\n            <div>  order: &lt;integer&gt;;</div>\n            <div>}</div>\n        </div>\n    </div>\n    <div><br /></div>\n    <div><img src=\"./D5DF8BA5-42B3-41E0-B8FF-148AD6892DC1.png\" height=\"480\"\n            width=\"751\" /><br /></div>\n    <div><br /></div>\n    <div><span style=\"font-weight: bold;\">4.2</span>  flex-grow属性</div>\n    <div>    flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</div>\n    <div><br /></div>\n    <div\n        style=\"box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;\">\n        <div>\n            <div>.item {</div>\n            <div>  flex-grow: &lt;number&gt;; /* default 0 */</div>\n            <div>}</div>\n        </div>\n    </div>\n    <div><img src=\"./D108F3DF-7747-44DC-BFE0-9CCCD1EA43CB.png\" height=\"211\"\n            width=\"802\" /><br /></div>\n    <div><br /></div>\n    <div>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的</div>\n    <div>flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</div>\n    <div><br /></div>\n    <div><span style=\"font-weight: bold;\">4.3 </span>flex-shrink属性</div>\n    <div>    flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</div>\n    <div><br /></div>\n    <div\n        style=\"box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;\">\n        <div>\n            <div>.item {</div>\n            <div>  flex-shrink: &lt;number&gt;; /* default 1 */</div>\n            <div>}</div>\n        </div>\n    </div>\n    <div><br /></div>\n    <div><img src=\"./5945F537-BAA0-4FFC-84E7-49110C65FBCB.png\" height=\"145\"\n            width=\"700\" /><br /></div>\n    <div>\n        <font style=\"font-size: 14px;\" face=\"Helvetica Neue\"><br /></font>\n    </div>\n    <div><span\n            style=\"font-family: &quot;Helvetica Neue&quot;; font-size: 14px;\">如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink</span>\n    </div>\n    <div><span style=\"font-family: &quot;Helvetica Neue&quot;; font-size: 14px;\">属性为0，其他项目都为1，则空间不足时，前者不缩小。</span><span\n            style=\"font-size: 14px; font-family: &quot;Helvetica Neue&quot;;\">负值对该属性无效。</span></div>\n    <div><br /></div>\n    <div><span style=\"font-weight: bold;\">4.4 </span>flex-basis属性</div>\n    <div>    flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，</div>\n    <div>    计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</div>\n    <div><br /></div>\n    <div\n        style=\"box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;\">\n        <div>\n            <div>.item {</div>\n            <div>  flex-basis: &lt;length&gt; | auto; /* default auto */</div>\n            <div>}</div>\n        </div>\n    </div>\n    <div><span style=\"font-size: 14px;\">    它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</span></div>\n    <div><br /></div>\n    <div><span style=\"font-weight: bold;\">4.5 </span>flex属性</div>\n    <div>    flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</div>\n    <div><br /></div>\n    <div\n        style=\"box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;\">\n        <div>\n            <div>.item {</div>\n            <div>  flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]</div>\n            <div>}</div>\n        </div>\n    </div>\n    <div><br /></div>\n    <div>    该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。</div>\n    <div>    建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</div>\n    <div><br /></div>\n    <div><span style=\"font-weight: bold;\">4.6 </span>align-self属性</div>\n    <div>    align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，</div>\n    <div>    表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</div>\n    <div><br /></div>\n    <div\n        style=\"box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;\">\n        <div>\n            <div>.item {</div>\n            <div>  align-self: auto | flex-start | flex-end | center | baseline | stretch;</div>\n            <div>}</div>\n        </div>\n        <div>\n            <font style=\"font-size: 14px;\">该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</font>\n        </div>\n    </div>\n    <div><br /></div>\n    <div><img src=\"./72AFE36E-F8C8-4EBA-92F5-3761F6F5396C.png\" height=\"390\"\n            width=\"743\" /><br /></div>\n    <div><br /></div>\n    <div><br /></div>\n    <div><br /></div>\n    <div><br /></div>\n    <div><br /></div>\n    <div><br /></div>\n    <div><br /></div>\n    <div><br /></div>\n    <div><br /></div>\n\n{% endraw %}","tags":["css"]}]